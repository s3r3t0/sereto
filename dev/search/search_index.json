{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>In a penetration test, the reporting phase is considered one of the most crucial aspects. It serves as the final deliverable, yet it is often met with disdain. This phase is time-consuming and lacks excitement, making it less appealing.</p> <p>SeReTo offers a solution by enabling the creation of semi-automated penetration testing reports. This tool significantly reduces the time spent on writing reports and ensures consistency across the entire team.</p>"},{"location":"usage/","title":"Usage","text":"<p>SeReTo provides a command line interface (CLI) to help you create and manage your projects. After you have set it up, you can continue with the following steps.</p>"},{"location":"usage/#getting-help","title":"Getting help","text":"<p>Any time you are unsure about anything, or cannot remember a command structure, you can always check the command's help:</p> <pre><code>sereto --help\n</code></pre> <p>You can also use help in the nested commands. For example, if you would like to know, what you can do with the dates in your project's configuration, you can run:</p> <pre><code>sereto config dates --help\n</code></pre>"},{"location":"usage/#create-project","title":"Create project","text":"<p>To create a new project using SeReTo, you can use the <code>new</code> command. The command takes a unique identifier for the project as a positional argument. For example, to create a project with the identifier <code>TEST</code>, you would run the following command:</p> <pre><code>sereto new TEST\n</code></pre> <p>During the creation process, you will be prompted with questions about the project, such as its name. Please provide the necessary information when prompted.</p> <p>Please note that the project identifier should meet the following requirements:</p> <ul> <li>It can only contain letters (<code>a-zA-Z</code>), numbers (<code>0-9</code>), underscore (<code>_</code>), dash (<code>-</code>), and dot (<code>.</code>).</li> <li>It should be between 1 and 20 characters long.</li> </ul> <p>For more information on the <code>new</code> command, you can refer to the SeReTo CLI documentation.</p> <p></p>"},{"location":"usage/#list-projects","title":"List projects","text":"<p>You can see the list of all projects using the following command, which will show you the ID and name of the project, as well as the location of the project's file structure:</p> <pre><code>sereto ls\n</code></pre> <p></p>"},{"location":"usage/#configuring-the-projects-details","title":"Configuring the project's details","text":"<p>SeReTo will need some information from you to generate the project. In our example, please change your working directory to your project's directory (you can discover it by running <code>sereto ls</code>). It can look something like this:</p> <pre><code>cd projects/TEST\n</code></pre> <p>Now you can change the project's configuration. You should set up the dates, targets and people for the project.</p> <p>To view a summary of the current configuration, you can run:</p> <pre><code>sereto config show\n</code></pre>"},{"location":"usage/#dates","title":"Dates","text":"<p>Run the following command:</p> <pre><code>sereto config dates add\n</code></pre> <p>SeReTo will ask you which date you would like to configure:</p> <ul> <li>sow_sent = date when you will be sending your Statement of Work</li> <li>pentest_ongoing = pair of dates indicating when the assessment will be performed</li> <li>review = date when the review is going to be done</li> <li>report_sent = date when you will be delivering the report to your customer</li> </ul> <p>You then set the dates using the format DD-Mmm-YYYY, such as 18-Apr-2024.</p> <p></p> <p>Run this command multiple times for each type of date you would like to set.</p>"},{"location":"usage/#targets","title":"Targets","text":"<p>Run the following command:</p> <pre><code>sereto config targets add\n</code></pre> <p>SeReTo will ask you about some details you would like to set. Make sure to include all necessary details, such as target locators, source IP addresses (<code>src_ips</code>), etc.</p> <p>Example locators configuration:</p> <pre><code>\"locators\": [\n  {\"type\": \"url\", \"value\": \"https://example.com/\"},\n  {\"type\": \"ip\", \"value\": \"192.0.2.0\", \"description\": \"Example target IP address\"},\n]\n</code></pre> <p></p> <p>Run this command multiple times for each target.</p>"},{"location":"usage/#people","title":"People","text":"<p>Run the following command:</p> <pre><code>sereto config people add\n</code></pre> <p>SeReTo will let you choose the role (type) and details of the person you are currently setting.</p> <p></p> <p>Run this command multiple times for each person you would like to set.</p>"},{"location":"usage/#adding-findings-to-a-target","title":"Adding findings to a target","text":"<p>The findings TUI allows you to add findings for a target in an interactive way. To start it, run the following command:</p> <pre><code>sereto findings add\n</code></pre> <p>To exit the TUI at any point, press <code>Ctrl+Q</code>.</p> <p>The TUI utilizes fuzzy search to help you effectively locate the desired finding templates. You can filter the list by selecting specific categories.</p> <p>It also supports advanced search with query operators, similar to Google Search. You can search across the following fields:</p> <ul> <li><code>name:</code> or <code>n:</code> matches against the finding title (this is also the default field if no operator is used)</li> <li><code>keyword:</code> or <code>k:</code> matches keywords Matched results are immediately displayed in the option list.</li> </ul> <p>Additionally, you can search within the template content using:</p> <ul> <li><code>description:</code> or <code>d:</code> matches content inside the description block of the template</li> <li><code>likelihood:</code> or <code>l:</code> matches content inside the likelihood block of the template</li> <li><code>impact:</code> or <code>i:</code> matches content inside the impact block of the template</li> <li><code>recommendation:</code> or <code>r:</code> matches content inside the recommendation block of the template</li> </ul> <p>Matched text segments are highlighted when the finding is opened for preview.</p> <p>Once you select a finding, a scrollable preview is displayed. Pressing <code>Ctrl+S</code> opens a screen where the details of the findings can be filled in. It is required to enter the finding name, choose a target to which the finding will be added and specify all required variables from the template (e.g. image proof). After confirmation, the finding will be added to the specified target.</p> <p>Once a finding is added, it is included in the findings.toml file of the target and a corresponding <code>.md.j2</code> file is created in the <code>findings</code> directory of the target. The <code>.md.j2</code> file is a Markdown Jinja template that should be edited to include specific details about the finding.</p> <p></p>"},{"location":"usage/#editing-the-finding-template","title":"Editing the finding template","text":""},{"location":"usage/#findingstoml","title":"findings.toml","text":"<p>When you add a finding from the TUI, the file findings.toml in the target's directory, e.g. <code>target_dast_example_target</code>, is updated. It may look as follows:</p> <pre><code>[\"Remote code execution\"]\nrisk = \"critical\"\nfindings = [\"generic_test_finding\"]\n</code></pre> <p>The <code>Remote code execution</code> is the name of the finding group, <code>risk</code> is the risk level of the finding group, and <code>findings</code> is a list of one or more nested findings that belong to the group. Specifying the risk for a group is optional. If not specified, it defaults to the highest risk within the finding group.</p>"},{"location":"usage/#finding-file","title":"Finding file","text":"<p>The entry <code>generic_test_finding</code> depends on the template chosen from the TUI. In this case, it refers to a generic finding template.</p> <p>The corresponding file is created in the <code>findings</code> directory of the target. The resulting project structure may look like this: <pre><code>\u251c\u2500\u2500 config.json\n\u251c\u2500\u2500 includes\n\u251c\u2500\u2500 layouts\n\u251c\u2500\u2500 outputs\n\u251c\u2500\u2500 pictures\n\u2514\u2500\u2500 target_dast_example_target\n    \u251c\u2500\u2500 findings.toml\n    \u251c\u2500\u2500 findings\n    \u2502   \u251c\u2500\u2500 _base.md\n    \u2502   \u2514\u2500\u2500 generic_test_finding.md.j2\n    ...\n</code></pre></p> <p>The file <code>generic_test_finding.md.j2</code> is a Jinja template that will be used to generate the report section for the given nested finding.</p> <p>You can rename the finding file to better reflect the nature of the finding, e.g. <code>rce.md.j2</code>. Remember to update the corresponding entry in the findings.toml file so that it matches the new filename, e.g.:</p> <pre><code>[\"Remote code execution\"]\nrisk = \"critical\"\nfindings = [\"rce\"]\n</code></pre> <p>Individual findings may require you to fill in extra information, such as screenshots, which will be used to customize the finding in automated way. Specify these in the frontmatter of the template file, which is a section at the top of the file enclosed between <code>+++</code> lines.</p> <p>The frontmatter is written in TOML and contains the following fields:</p> <ul> <li><code>name</code> - name of the finding (only used if there are multiple findings in the group)</li> <li><code>risk</code> - risk level of the finding (<code>info</code>, <code>low</code>, <code>medium</code>, <code>high</code>, <code>critical</code>)</li> <li><code>category</code> - category of the finding (e.g. <code>generic</code>, <code>dast</code>, <code>sast</code>, etc.)</li> <li><code>template_path</code> - path to a template file that the nested finding file is based on (relative to the <code>templates_path</code> setting)</li> <li><code>locators</code> - list of locators that indicate the location of the finding within the target, e.g. URLs, IP addresses, etc. Each locator is defined by an inline table with the following fields:<ul> <li><code>type</code> - type of the locator, e.g. <code>url</code>, <code>ip</code>, etc. List of all locator types can be found in the model reference.</li> <li><code>value</code> - value of the locator</li> <li><code>description</code> (optional) - description of the locator</li> </ul> </li> </ul> <p>Lastly, the frontmatter contains a TOML table <code>variables</code>, where the variables required by the finding can be defined.</p> <p>Example frontmatter:</p> <pre><code>+++\nname = \"Remote code execution\"\nrisk = \"critical\"\ncategory = \"generic\"\ntemplate_path = \"categories/generic/findings/test_finding.md.j2\"\nlocators = [\n  {\n    type = \"url\",\n    value = \"https://example.com/vulnerable-endpoint\",\n    description = \"Vulnerable endpoint\"\n  },\n]\n\n[variables]\nimages = ['proof.png']\n+++\n</code></pre> <p>The main finding variables, such as <code>locators</code>, can be accessed in the template using the <code>f</code> object, e.g.: <pre><code>{% for loc in f.locators %}\n- {{ loc.value }}\n{% endfor %}\n</code></pre></p> <p>For getting only a specific locator type, you can use the <code>f.filter_locators</code> method, e.g.: <pre><code>{% for url in f.filter_locators(\"url\") %}\n- &lt;{{ url.value }}&gt;\n{% endfor %}\n</code></pre></p>"},{"location":"usage/#locator-precedence","title":"Locator precedence","text":"<ul> <li>Target locators are exactly what you defined in the target configuration.</li> <li>Finding group locators behave as follows (first non-empty outcome wins):<ol> <li>Explicit locators configured on the group.</li> <li>When every sub-finding carries a non-empty <code>locators</code> list, the report shows the unique union of those sub-finding locators.</li> <li>When only some sub-findings define locators, the report shows the unique union of their locators plus the target locators (so gaps inherit the target context).</li> <li>If nothing else matches, the group falls back to the target locators.</li> </ol> </li> <li>Sub-finding locators are always exactly what you define in the frontmatter (empty lists stay empty).</li> </ul> <p>The <code>variables</code> table can be accessed using <code>f.vars</code>, e.g.: <pre><code>{% for image in f.vars.images %}\n  ![Screenshot showing proof of a vulnerability]({{ image }})\n{% endfor %}\n</code></pre></p> <p>The finding should be an extension of the base template named <code>_base.md.j2</code>. The base template provides the following blocks that you can override to customize the content of the finding:</p> <ul> <li><code>description</code></li> <li><code>likelihood</code></li> <li><code>impact</code></li> <li><code>recommendation</code></li> </ul> <p>In its simplest form, the finding file may look like this:</p> <pre><code>+++\nname = \"Remote code execution\"\nrisk = \"critical\"\ncategory = \"generic\"\ntemplate_path = \"categories/generic/findings/test_finding.md.j2\"\nlocators = [\n  {\n    type = \"url\",\n    value = \"https://example.com/vulnerable-endpoint\",\n    description = \"Vulnerable endpoint\"\n  },\n]\n\n[variables]\nimages = ['proof.png']\n+++\n\n{% extends \"_base.md\" %}\n\n{% block description -%}\nA brief description of the finding.\n\nURLs:\n\n{% for url in f.filter_locators(\"url\") -%}\n- &lt;{{ url.value }}&gt;\n{% endfor %}\n\nImage proof:\n\n{% for image in f.vars.images -%}\n  ![Screenshot showing proof of a vulnerability]({{ image }})\n{% endfor %}\n\n{%- endblock description %}\n\n{% block likelihood -%}\nLikelihood of the finding being exploited.\n{%- endblock likelihood %}\n\n{% block impact -%}\nPotential impact of the finding.\n{%- endblock impact %}\n\n{% block recommendation -%}\nRecommendations or fixes for the finding.\n{%- endblock recommendation %}\n\n{% block reference -%}\nReferences and links (e.g. to documentation) related to the finding.\n{%- endblock reference %}\n</code></pre>"},{"location":"usage/#report-generation","title":"Report generation","text":"<p>To generate the report PDF, you can use the <code>pdf</code> command:</p> <pre><code>sereto pdf report\n</code></pre> <p>To open the generated report, you can use the <code>open</code> command:</p> <pre><code>sereto open report\n</code></pre> <p>In case of an error, check the <code>.build/report.log</code> file in your project's directory. It contains the output of the report generation process, including any errors that may have occurred.</p> <p>To remove auxiliary files generated during the report build, run:</p> <pre><code>sereto clean\n</code></pre> <p>Alternatively, you can manually delete the <code>.build</code> directory from your project's root.</p>"},{"location":"concepts/idea/","title":"Idea","text":"<p>In essence, you can think about SeReTo as a comprehensive specification outlining the structural framework for a penetration testing report.</p> <p>The Python package, on the other hand, is \"just\" the implementation of this specification. It provides the necessary tools to generate the report based on the specification. This setup allows for the extensibility of the entire solution.</p> <p>The tool proves particularly useful when faced with the frequent creation of such reports. Additionally, when collaborating within a team, it ensures a uniform approach to reporting. SeReTo utilizes templates that may include logic to modify content based on specified variables and incorporate images, among other elements.</p>"},{"location":"concepts/idea/#markup-language-hybrid-approach","title":"Markup Language - Hybrid Approach","text":"<p>The initial implementation solely relied on the use of TeX to compose the entire content. TeX (LaTeX/XeTeX/...) is an exceptionally robust markup language that enables the creation of visually stunning documents. It enjoys widespread popularity in academic and scientific writing.</p> <p>Later, we realized that composing the entire report in TeX was excessive. Certain sections of the report did not require the extensive expressive features of TeX and could be written in a more straightforward markup language, such as Markdown.</p> <p>We have implemented a hybrid approach where the template with the overall structure of the report is composed in TeX (this is usually done once and does not need much work afterwards). The findings, on the other hand, are written in Markdown, allowing anyone, including new team members unfamiliar with TeX, to easily create reports on their own. This hybrid approach saves time and effort, while keeping the reports visually appealing.</p>"},{"location":"concepts/idea/#templating-jinja2","title":"Templating - Jinja2","text":"<p>SeReTo uses the Jinja2 templating engine to allow for the dynamic generation of the reports content. This engine is widely used in the Python community and is known for its flexibility and ease of use.</p> <p>The environment for TeX uses the following delimiters:</p> <ul> <li><code>((( ... )))</code> for variables</li> <li><code>((* ... *))</code> for control structures</li> <li><code>((= ... =))</code> for comments</li> </ul> <p>The environment for Markdown uses the default delimiters:</p> <ul> <li><code>{{ ... }}</code> for variables</li> <li><code>{% ... %}</code> for control structures</li> <li><code>{# ... #}</code> for comments</li> </ul>"},{"location":"concepts/project_files/","title":"Project Files","text":"<p>Tip</p> <p>If you are looking for explanation of the structure from the perspective of templates, please refer to the template structure section in the documentation.</p> <pre><code>\u251c\u2500\u2500 .build/\n\u251c\u2500\u2500 includes/\n\u251c\u2500\u2500 layouts/\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 generated/\n\u251c\u2500\u2500 outputs/\n\u251c\u2500\u2500 pdf/\n\u251c\u2500\u2500 pictures/\n\u251c\u2500\u2500 target_&lt;category&gt;_&lt;name&gt;/\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 findings/\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 &lt;finding_name&gt;.md.j2\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 findings.toml\n\u251c\u2500\u2500 .sereto\n\u251c\u2500\u2500 .seretoignore\n\u2514\u2500\u2500 config.json\n</code></pre>"},{"location":"concepts/project_files/#build","title":"<code>.build</code>","text":"<p>Directory used for building the reports. It contains various intermediate files such as <code>.tex</code>, <code>.aux</code>, <code>.log</code>, <code>.toc</code>, and others generated during the report compilation process.</p>"},{"location":"concepts/project_files/#includes","title":"<code>includes</code>","text":"<p>Directory for supplementary files that are included either through Jinja2 templating or directly in the TeX files. Examples include Jinja2 macros, the TeX glossary file, and the TeX class file (<code>.cls</code>).</p>"},{"location":"concepts/project_files/#layouts","title":"<code>layouts</code>","text":"<p>Directory for layout files. These files define the structure of the document.</p>"},{"location":"concepts/project_files/#generated","title":"<code>generated</code>","text":"<p>Directory for generated layout files. These files are typically included in the final document from other layouts. This folder may contain layouts for each target and each finding group. Existing files are not overwritten, allowing for manual modifications.</p>"},{"location":"concepts/project_files/#outputs","title":"<code>outputs</code>","text":"<p>Directory for storing outputs from various tools and scripts. While SeReTo does not use this directory directly, it serves as a repository for tool outputs that are relevant to the report.</p>"},{"location":"concepts/project_files/#pdf","title":"<code>pdf</code>","text":"<p>Directory for the final PDF reports.</p>"},{"location":"concepts/project_files/#pictures","title":"<code>pictures</code>","text":"<p>Directory for images and screenshots used in the report.</p>"},{"location":"concepts/project_files/#target_category_name","title":"<code>target_&lt;category&gt;_&lt;name&gt;</code>","text":"<p>Directories for a individual targets.</p>"},{"location":"concepts/project_files/#findings","title":"<code>findings</code>","text":"<p>Directory for findings related to this target.</p>"},{"location":"concepts/project_files/#findingstoml","title":"<code>findings.toml</code>","text":"<p>TOML file containing metadata for the findings of this target. It is possible to define name, risk, and variables for each finding, but also to group several findings together to form a single finding group with multiple sub-findings.</p>"},{"location":"concepts/project_files/#sereto","title":"<code>.sereto</code>","text":"<p>Together with <code>config.json</code>, this file serves as an indicator that the current directory is a SeReTo project.</p> <p>Usually, it is an empty file.</p>"},{"location":"concepts/project_files/#seretoignore","title":"<code>.seretoignore</code>","text":"<p>SeReTo offers a convenient feature that allows the inclusion of project sources in the final report PDF. This functionality utilizes the <code>.seretoignore</code> file with the same syntax as <code>.gitignore</code>, enabling the exclusion of specific files.</p>"},{"location":"concepts/project_files/#configjson","title":"<code>config.json</code>","text":"<p>Configuration file for the project.</p>"},{"location":"concepts/report_structure/","title":"Report Structure","text":"<p>Keep in mind that almost anything in SeReTo can be customized to fit your needs. The following structure is the default one, but you can modify it to suit your specific requirements.</p> <p>The report is the final deliverable of a penetration test. It provides a comprehensive overview of the test's results, including the methodology, scope, and findings. The report is a crucial document that helps stakeholders understand the security posture of the tested system and make informed decisions based on the test results.</p> <p>The high-level overview of the report document in SeReTo is defined as follows:</p> <pre><code>\u250c\u2500\u2500\u2500layouts/_base.tex.j2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                                                                     \u2502\n\u2502 \\documentclass{sereto}                                                              \u2502\n\u2502                                                                                     \u2502\n\u2502 \\title{...}                                                                         \u2502\n\u2502 \\subtitle{...}                                                                      \u2502\n\u2502 \\author{...}                                                                        \u2502\n\u2502                                                                                     \u2502\n\u2502 \\begin{document}                                                                    \u2502\n\u2502                                                                                     \u2502\n\u2502  \u250c\u2500\u2500\u2500layouts/report.tex.j2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502                                                                               \u2502  \u2502\n\u2502  \u2502   Management Summary                                                          \u2502  \u2502\n\u2502  \u2502   ...                                                                         \u2502  \u2502\n\u2502  \u2502                                                                               \u2502  \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500layouts/generated/&lt;target_uname&gt;.tex.j2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u2502\n\u2502  \u2502  \u2502                                                                         \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502   Target 1                                                              \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502                                                                         \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u250c\u2500\u2500\u2500target_&lt;uname&gt;/scope.tex.j2\u2500\u2500\u2500\u2510                                    \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                    \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502                                                                         \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u250c\u2500\u2500\u2500target_&lt;uname&gt;/approach.tex.j2\u2500\u2500\u2500\u2510                                 \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                 \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502                                                                         \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502   Findings                                                              \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502                                                                         \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u250c\u2500\u2500\u2500layouts/generated/&lt;target_uname&gt;_&lt;finding_group_uname&gt;.tex.j2\u2500\u2500\u2500\u2510  \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u2502                                                                   \u2502  \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u2502  \u250c\u2500\u2500\u2500&lt;target_uname&gt;/findings/&lt;name&gt;.md.j2\u2500\u2500\u2500\u2510                     \u2502  \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \u2502  \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u2502                                                                   \u2502  \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u2502  \u250c\u2500\u2500\u2500&lt;target_uname&gt;/findings/&lt;name&gt;.md.j2\u2500\u2500\u2500\u2510                     \u2502  \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \u2502  \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u2502   ...                                                             \u2502  \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502                                                                         \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u250c\u2500\u2500\u2500layouts/generated/&lt;target_uname&gt;_&lt;finding_group_uname&gt;.tex.j2\u2500\u2500\u2500\u2510  \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u2502                                                                   \u2502  \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u2502  \u250c\u2500\u2500\u2500&lt;target_uname&gt;/findings/&lt;name&gt;.md.j2\u2500\u2500\u2500\u2510                     \u2502  \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \u2502  \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u2502                                                                   \u2502  \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u2502  \u250c\u2500\u2500\u2500&lt;target_uname&gt;/findings/&lt;name&gt;.md.j2\u2500\u2500\u2500\u2510                     \u2502  \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \u2502  \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u2502   ...                                                             \u2502  \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502   ...                                                                   \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502                                                                         \u2502  \u2502  \u2502\n\u2502  \u2502  \u251c\u2500\u2500\u2500layouts/generated/&lt;target_uname&gt;.tex.j2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502  \u2502\n\u2502  \u2502  \u2502                                                                         \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502   Target 2                                                              \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502   ...                                                                   \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502                                                                         \u2502  \u2502  \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2502\n\u2502  \u2502                                                                               \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                                                                     \u2502\n\u2502 \\end{document}                                                                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"concepts/settings/","title":"Settings","text":"<p><code>Settings</code> provide a way to customize SeReTo according to your needs.</p> <p>The location where the configuration file is stored is determined by using <code>click.get_app_dir</code> function, to provide the most appropriate location for the specific operating system. For example, on Linux, the configuration file is stored in <code>~/.config/sereto/settings.json</code> and on Windows, it is likely stored in <code>C:\\Users\\&lt;username&gt;\\AppData\\Local\\sereto\\settings.json</code>.</p> <p>It is possible to override settings values by using environment variables. Each setting can be mapped to an environment variable by using the following naming convention: <code>SERETO_&lt;SETTING_NAME&gt;</code>. For example:</p> <ul> <li>To override <code>projects_path</code>, set the environment variable <code>SERETO_PROJECTS_PATH</code>. For example <code>SERETO_PROJECTS_PATH=/tmp/projects</code>.</li> <li>To override <code>categories</code>, set the environment variable <code>SERETO_CATEGORIES</code>. For example <code>SERETO_CATEGORIES='[\"generic\", \"dast\"]'</code>.</li> </ul> <p>This behaviour is inherited from Pydantic Settings. Therefore check the Settings Management for more information about how to manage settings.</p> <p>Settings consist of the following fields:</p>"},{"location":"concepts/settings/#projects_path","title":"<code>projects_path</code>","text":"<p>The path to the directory where the projects are located.</p>"},{"location":"concepts/settings/#templates_path","title":"<code>templates_path</code>","text":"<p>The path to the directory where the templates are located.</p>"},{"location":"concepts/settings/#render","title":"<code>render</code>","text":"<p>Defines recipes and tools which are used when rendering the TeX files or converting between different formats (e.g. from Markdown to TeX).</p> <p>The <code>render</code> field consists of the following:</p>"},{"location":"concepts/settings/#report_recipes","title":"<code>report_recipes</code>","text":"<p>List of <code>RenderRecipe</code>s, which define the tools used to render a report.</p> <p>Example:</p> JSONPython <pre><code>{\n    \"name\": \"default-report\",\n    \"tools\": [\n        \"latexmk\"\n    ],\n    \"intermediate_format\": \"tex\"\n}\n</code></pre> <pre><code>RenderRecipe(\n    name=\"default-report\",\n    tools=[\n        \"latexmk\"\n    ],\n    intermediate_format=FileFormat.tex\n)\n</code></pre>"},{"location":"concepts/settings/#finding_recipes","title":"<code>finding_recipes</code>","text":"<p>List of <code>RenderRecipe</code>s, which define the tools used to render a finding.</p> <p>Example:</p> JSONPython <pre><code>{\n    \"name\": \"default-finding\",\n    \"tools\": [\n        \"latexmk-finding\"\n    ],\n    \"intermediate_format\": \"tex\"\n}\n</code></pre> <pre><code>RenderRecipe(\n    name=\"default-finding\",\n    tools=[\n        \"latexmk-finding\"\n    ],\n    intermediate_format=FileFormat.tex\n)\n</code></pre>"},{"location":"concepts/settings/#sow_recipes","title":"<code>sow_recipes</code>","text":"<p>List of <code>RenderRecipe</code>s, which define the tools used to render a statement-of-work.</p> <p>Example:</p> JSONPython <pre><code>{\n    \"name\": \"default-sow\",\n    \"tools\": [\n        \"latexmk\"\n    ],\n    \"intermediate_format\": \"tex\"\n}\n</code></pre> <pre><code>RenderRecipe(\n    name=\"default-sow\",\n    tools=[\n        \"latexmk\"\n    ],\n    intermediate_format=FileFormat.tex\n)\n</code></pre>"},{"location":"concepts/settings/#target_recipes","title":"<code>target_recipes</code>","text":"<p>List of <code>RenderRecipe</code>s, which define the tools used to render a target.</p> <p>Example:</p> JSONPython <pre><code>{\n    \"name\": \"default-target\",\n    \"tools\": [\n        \"latexmk-target\"\n    ],\n    \"intermediate_format\": \"tex\"\n}\n</code></pre> <pre><code>RenderRecipe(\n    name=\"default-target\",\n    tools=[\n        \"latexmk-target\"\n    ],\n    intermediate_format=FileFormat.tex\n)\n</code></pre>"},{"location":"concepts/settings/#convert_recipes","title":"<code>convert_recipes</code>","text":"<p>List of <code>ConvertRecipe</code>s, which define the tools used to convert between different formats.</p> <p>Example:</p> JSONPython <pre><code>{\n    \"name\": \"convert-md\",\n    \"input_format\": \"md\",\n    \"output_format\": \"tex\",\n    \"tools\": [\n        \"pandoc-md\"\n    ]\n}\n</code></pre> <pre><code>ConvertRecipe(\n    name=\"convert-md\",\n    input_format=FileFormat.md,\n    output_format=FileFormat.tex,\n    tools=[\n        \"pandoc-md\"\n    ]\n)\n</code></pre>"},{"location":"concepts/settings/#tools","title":"<code>tools</code>","text":"<p>List of <code>RenderTool</code>s, which are the commands with their parameters. Tools are referenced in recipes by their name.</p> <p>The following variables are always available and will be automatically substituted for their value before running the command:</p> <ul> <li><code>%DOC%</code>: path to the current file without the extension</li> <li><code>%DOC_EXT%</code>: path to the current file with the extension</li> <li><code>%DOCFILE%</code>: filename without extension</li> <li><code>%DOCFILE_EXT%</code>: filename with extensions</li> <li><code>%DIR%</code>: path to the directory, where the current file is located</li> <li><code>%TEMPLATES%</code>: path to the directory, where the templates are located</li> <li><code>%PROJECT%</code>: path to the project directory</li> </ul> <p>Example:</p> JSONPython <pre><code>{\n    \"name\": \"latexmk\",\n    \"command\": \"latexmk\",\n    \"args\": [\n        \"-xelatex\",\n        \"-interaction=batchmode\",\n        \"-halt-on-error\",\n        \"%DOC%\"\n    ]\n}\n</code></pre> <pre><code>RenderTool(\n    name=\"latexmk\",\n    command=\"latexmk\",\n    args=[\n        \"-xelatex\",\n        \"-interaction=batchmode\",\n        \"-halt-on-error\",\n        \"%DOC%\"\n    ]\n)\n</code></pre>"},{"location":"concepts/settings/#categories","title":"<code>categories</code>","text":"<p>A list of categories that can be used to group findings.</p>"},{"location":"concepts/sow_structure/","title":"Statement of Work Structure","text":"<p>Keep in mind that almost anything in SeReTo can be customized to fit your needs. The following structure is the default one, but you can modify it to suit your specific requirements.</p> <p>The Statement of Work (SoW) is a document that outlines the scope of work, deliverables, and timeline for a project. The SoW is a crucial document that helps to ensure that all parties involved in a project are on the same page regarding the project's objectives and expectations.</p> <p>The high-level overview of the SoW document in SeReTo is defined as follows:</p> <pre><code>\u250c\u2500\u2500\u2500layouts/_base.tex.j2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                                     \u2502\n\u2502 \\documentclass{sereto}                              \u2502\n\u2502                                                     \u2502\n\u2502 \\title{...}                                         \u2502\n\u2502 \\subtitle{...}                                      \u2502\n\u2502 \\author{...}                                        \u2502\n\u2502                                                     \u2502\n\u2502 \\begin{document}                                    \u2502\n\u2502                                                     \u2502\n\u2502  \u250c\u2500\u2500\u2500layouts/sow.tex.j2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502                                               \u2502  \u2502\n\u2502  \u2502   Management Summary                          \u2502  \u2502\n\u2502  \u2502   ...                                         \u2502  \u2502\n\u2502  \u2502                                               \u2502  \u2502\n|  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502\n\u2502  \u2502                                               \u2502  \u2502\n\u2502  \u2502   Target 1                                    \u2502  \u2502\n\u2502  \u2502                                               \u2502  \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500target_&lt;name&gt;/scope.tex.j2\u2500\u2500\u2500\u2510           \u2502  \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2502  \u2502\n\u2502  \u2502                                               \u2502  \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500target_&lt;name&gt;/approach.tex.j2\u2500\u2500\u2500\u2510        \u2502  \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502  \u2502\n\u2502  \u2502                                               \u2502  \u2502\n|  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502\n\u2502  \u2502                                               \u2502  \u2502\n\u2502  \u2502   Target 2                                    \u2502  \u2502\n\u2502  \u2502   ...                                         \u2502  \u2502\n\u2502  \u2502                                               \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                                     \u2502\n\u2502 \\end{document}                                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"default_templates/building_blocks/","title":"Jinja building blocks","text":"<p>This page provides an overview of the building blocks for creating your custom templates. See Templating - Jinja2 for details on how the variables can be included in the templates.</p> <p>This is so far valid for the <code>report.tex.j2</code> and <code>sow.tex.j2</code> templates.</p>"},{"location":"default_templates/building_blocks/#variables","title":"Variables","text":"<ul> <li><code>c</code>: The VersionConfig object for the current version of the project.</li> <li><code>config</code>: The full Config object (most of the time, you should use <code>c</code> instead).</li> <li><code>version</code>: The version of the project.</li> <li><code>project_path</code>: Path object to the project directory.</li> </ul>"},{"location":"default_templates/building_blocks/#useful-methods-and-properties-of-the-versionconfig","title":"Useful methods and properties of the VersionConfig","text":"<p>The following methods can be invoked from the <code>c</code> object.</p> <p>Example usage:</p> <pre><code>c.filter_targets(category=[\"dast\", \"sast\"], name=\"^foo\")]\nc.filter_dates(type=\"pentest_ongoing\", start=\"01-Jan-2024\", end=\"31-Jan-2024\")\nc.filter_people(type=\"author\", email=\"@foo.bar$\")\n</code></pre> <p>There are also the following properties:</p>"},{"location":"default_templates/building_blocks/#sereto.config.VersionConfig.filter_targets","title":"<code>sereto.config.VersionConfig.filter_targets(category=None, name=None, inverse=False)</code>","text":"<p>Filter targets based on specified criteria.</p> <p>The regular expressions support the syntax of Python's <code>re</code> module.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str | Iterable[str] | None</code> <p>The category of the target. Can be a single category, a list of categories, or None.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Regular expression to match the name of the target.</p> <code>None</code> <code>inverse</code> <code>bool</code> <p>If True, return the inverse of the usual results.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[Target]</code> <p>A list of targets matching the criteria.</p> Source code in <code>sereto/config.py</code> <pre><code>@validate_call\ndef filter_targets(\n    self,\n    category: str | Iterable[str] | None = None,\n    name: str | None = None,\n    inverse: bool = False,\n) -&gt; list[Target]:\n    \"\"\"Filter targets based on specified criteria.\n\n    The regular expressions support the syntax of Python's `re` module.\n\n    Args:\n        category: The category of the target. Can be a single category, a list of categories, or None.\n        name: Regular expression to match the name of the target.\n        inverse: If True, return the inverse of the usual results.\n\n    Returns:\n        A list of targets matching the criteria.\n    \"\"\"\n    # Prepare categories for filtering\n    match category:\n        case str():\n            categories: list[str] | None = [category]\n        case Iterable():\n            categories = list(category)\n        case None:\n            categories = None\n\n    filtered_targets = [\n        t\n        for t in self.targets\n        if (categories is None or t.data.category in categories) and (name is None or re.search(name, t.data.name))\n    ]\n\n    if inverse:\n        return [t for t in self.targets if t not in filtered_targets]\n    return filtered_targets\n</code></pre>"},{"location":"default_templates/building_blocks/#sereto.config.VersionConfig.filter_dates","title":"<code>sereto.config.VersionConfig.filter_dates(type=None, start=None, end=None, *, first_date=False, last_date=False, inverse=False)</code>","text":"<pre><code>filter_dates(type: str | DateType | Iterable[str] | Iterable[DateType] | None = ..., start: str | SeretoDate | None = ..., end: str | SeretoDate | None = ..., *, first_date: Literal[True], last_date: Literal[False] = False, inverse: bool = False) -&gt; SeretoDate | None\n</code></pre><pre><code>filter_dates(type: str | DateType | Iterable[str] | Iterable[DateType] | None = ..., start: str | SeretoDate | None = ..., end: str | SeretoDate | None = ..., *, first_date: Literal[False] = False, last_date: Literal[True], inverse: bool = False) -&gt; SeretoDate | None\n</code></pre><pre><code>filter_dates(type: str | DateType | Iterable[str] | Iterable[DateType] | None = ..., start: str | SeretoDate | None = ..., end: str | SeretoDate | None = ..., *, first_date: Literal[False], last_date: Literal[False], inverse: bool = False) -&gt; list[Date]\n</code></pre> <p>Filter dates based on specified criteria.</p> <p>The start and end dates are inclusive. For date ranges, a date is considered matching if it completely overlaps with the specified range.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str | DateType | Iterable[str] | Iterable[DateType] | None</code> <p>The type of the date. Can be <code>DateType</code>, a list of <code>DateType</code>s, or None.</p> <code>None</code> <code>start</code> <code>str | SeretoDate | None</code> <p>Only dates on or after this date will be included.</p> <code>None</code> <code>end</code> <code>str | SeretoDate | None</code> <p>Only dates on or before this date will be included.</p> <code>None</code> <code>first_date</code> <code>bool</code> <p>If True, return the earliest date matching the criteria. Even for date ranges, only the start date  is considered. The type returned is <code>SeretoDate</code> or None.</p> <code>False</code> <code>last_date</code> <code>bool</code> <p>If True, return the latest date matching the criteria. Even for date ranges, only the end date is considered. The type returned is <code>SeretoDate</code> or None.</p> <code>False</code> <code>inverse</code> <code>bool</code> <p>If True, return the inverse of the usual results.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[Date] | SeretoDate | None</code> <p>For first_date or last_date = True, returns SeretoDate or None. Otherwise, returns a list[Date].</p> Source code in <code>sereto/config.py</code> <pre><code>def filter_dates(\n    self,\n    type: str | DateType | Iterable[str] | Iterable[DateType] | None = None,\n    start: str | SeretoDate | None = None,\n    end: str | SeretoDate | None = None,\n    *,\n    first_date: bool = False,\n    last_date: bool = False,\n    inverse: bool = False,\n) -&gt; list[Date] | SeretoDate | None:\n    \"\"\"Filter dates based on specified criteria.\n\n    The start and end dates are inclusive. For date ranges, a date is considered matching if it completely overlaps\n    with the specified range.\n\n    Args:\n        type: The type of the date. Can be `DateType`, a list of `DateType`s, or None.\n        start: Only dates on or after this date will be included.\n        end: Only dates on or before this date will be included.\n        first_date: If True, return the earliest date matching the criteria. Even for date ranges, only the start\n            date  is considered. The type returned is `SeretoDate` or None.\n        last_date: If True, return the latest date matching the criteria. Even for date ranges, only the end date\n            is considered. The type returned is `SeretoDate` or None.\n        inverse: If True, return the inverse of the usual results.\n\n    Returns:\n        For first_date or last_date = True, returns SeretoDate or None. Otherwise, returns a list[Date].\n    \"\"\"\n    # Check for invalid parameter combinations\n    if first_date and last_date:\n        raise SeretoValueError(\"cannot specify both first_date and last_date\")\n    if (first_date or last_date) and inverse:\n        raise SeretoValueError(\"cannot specify inverse with first_date or last_date\")\n\n    match type:\n        case str():\n            type = [DateType(type)]\n        case Iterable():\n            type = [DateType(t) for t in type]\n        case None:\n            pass\n\n    if isinstance(start, str):\n        start = SeretoDate.from_str(start)\n    if isinstance(end, str):\n        end = SeretoDate.from_str(end)\n\n    filtered_dates = [\n        d\n        for d in self.dates\n        if (type is None or d.type in type)\n        and (\n            start is None\n            or (isinstance(d.date, SeretoDate) and d.date &gt;= start)\n            or (isinstance(d.date, DateRange) and d.date.start &gt;= start)\n        )\n        and (\n            end is None\n            or (isinstance(d.date, SeretoDate) and d.date &lt;= end)\n            or (isinstance(d.date, DateRange) and d.date.end &lt;= end)\n        )\n    ]\n\n    if first_date:\n        single_dates = [d.date.start if isinstance(d.date, DateRange) else d.date for d in filtered_dates]\n        return min(single_dates, default=None)\n\n    if last_date:\n        single_dates = [d.date.end if isinstance(d.date, DateRange) else d.date for d in filtered_dates]\n        return max(single_dates, default=None)\n\n    if inverse:\n        return [d for d in self.dates if d not in filtered_dates]\n    return filtered_dates\n</code></pre>"},{"location":"default_templates/building_blocks/#sereto.config.VersionConfig.filter_people","title":"<code>sereto.config.VersionConfig.filter_people(type=None, name=None, business_unit=None, email=None, role=None, inverse=False)</code>","text":"<p>Filter people based on specified criteria.</p> <p>The regular expressions support the syntax of Python's <code>re</code> module.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str | PersonType | Iterable[str] | Iterable[PersonType] | None</code> <p>The type of the person. Can be a single type, a list of types, or None.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Regular expression to match the name of the person.</p> <code>None</code> <code>business_unit</code> <code>str | None</code> <p>Regular expression to match the business unit of the person.</p> <code>None</code> <code>email</code> <code>str | None</code> <p>Regular expression to match the email of the person.</p> <code>None</code> <code>role</code> <code>str | None</code> <p>Regular expression to match the role of the person.</p> <code>None</code> <code>inverse</code> <code>bool</code> <p>If True, return the inverse of the usual results.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[Person]</code> <p>A list of people matching the criteria.</p> Source code in <code>sereto/config.py</code> <pre><code>@validate_call\ndef filter_people(\n    self,\n    type: str | PersonType | Iterable[str] | Iterable[PersonType] | None = None,\n    name: str | None = None,\n    business_unit: str | None = None,\n    email: str | None = None,\n    role: str | None = None,\n    inverse: bool = False,\n) -&gt; list[Person]:\n    \"\"\"Filter people based on specified criteria.\n\n    The regular expressions support the syntax of Python's `re` module.\n\n    Args:\n        type: The type of the person. Can be a single type, a list of types, or None.\n        name: Regular expression to match the name of the person.\n        business_unit: Regular expression to match the business unit of the person.\n        email: Regular expression to match the email of the person.\n        role: Regular expression to match the role of the person.\n        inverse: If True, return the inverse of the usual results.\n\n    Returns:\n        A list of people matching the criteria.\n    \"\"\"\n    match type:\n        case str():\n            type = [PersonType(type)]\n        case Iterable():\n            type = [PersonType(t) for t in type]\n        case None:\n            pass\n\n    filtered_people = [\n        p\n        for p in self.people\n        if (type is None or p.type in type)\n        and (name is None or (p.name is not None and re.search(name, p.name)))\n        and (business_unit is None or (p.business_unit is not None and re.search(business_unit, p.business_unit)))\n        and (email is None or (p.email is not None and re.search(email, p.email)))\n        and (role is None or (p.role is not None and re.search(role, p.role)))\n    ]\n\n    if inverse:\n        return [p for p in self.people if p not in filtered_people]\n    return filtered_people\n</code></pre>"},{"location":"default_templates/building_blocks/#sereto.config.VersionConfig.select_target","title":"<code>sereto.config.VersionConfig.select_target(categories, selector=None)</code>","text":"Source code in <code>sereto/config.py</code> <pre><code>@validate_call\ndef select_target(\n    self,\n    categories: Iterable[str],\n    selector: int | str | None = None,\n) -&gt; Target:\n    # only single target present\n    if selector is None:\n        if len(self.targets) != 1:\n            raise SeretoValueError(\n                f\"cannot select target; no selector provided and there are {len(self.targets)} targets present\"\n            )\n        return self.targets[0]\n\n    # by index\n    if isinstance(selector, int) or selector.isnumeric():\n        ix = selector - 1 if isinstance(selector, int) else int(selector) - 1\n        if not (0 &lt;= ix &lt;= len(self.targets) - 1):\n            raise SeretoValueError(\"target index out of range\")\n\n        return self.targets[ix]\n\n    # by unique category\n    if selector in categories:\n        filtered_targets = [t for t in self.targets if t.data.category == selector]\n        match len(filtered_targets):\n            case 0:\n                raise SeretoValueError(f\"category {selector!r} does not contain any target\")\n            case 1:\n                return filtered_targets[0]\n            case _:\n                raise SeretoValueError(\n                    f\"category {selector!r} contains multiple targets, use unique name when querying\"\n                )\n\n    # by uname\n    filtered_targets = [t for t in self.targets if t.uname == selector]\n    if len(filtered_targets) != 1:\n        raise SeretoValueError(f\"target with uname {selector!r} not found\")\n    return filtered_targets[0]\n</code></pre>"},{"location":"default_templates/building_blocks/#sereto.config.VersionConfig.report_sent_date","title":"<code>sereto.config.VersionConfig.report_sent_date</code>  <code>property</code>","text":"<p>Get the report sent date</p> <p>It has fallback to the review date and last date of the pentest ongoing.</p>"},{"location":"default_templates/building_blocks/#sereto.config.VersionConfig.total_open_risks","title":"<code>sereto.config.VersionConfig.total_open_risks</code>  <code>property</code>","text":"<p>Get the total number of open risks across all risk levels.</p>"},{"location":"default_templates/building_blocks/#sereto.config.VersionConfig.sum_risks","title":"<code>sereto.config.VersionConfig.sum_risks</code>  <code>property</code>","text":"<p>Get the sum of risks across all targets.</p>"},{"location":"default_templates/debugging/","title":"Debugging templates","text":"<p>Jinja templates can be complex, and debugging them can be challenging. This guide provides tips and techniques to help you debug your templates effectively.</p> <p>Jinja contains two built-in functions that can be useful for debugging:</p> <ul> <li><code>{{ debug() }}</code>: This function prints the current context, including all variables and their values.</li> <li><code>{{ pprint(variable) }}</code>: This function pretty-prints a variable, making it easier to read complex data structures.</li> </ul> <p>Tip</p> <p>The public templates include a <code>debug</code> template. This template prints all configured variables and their values. Invoke it as an alternative to the report template: <code>sereto pdf report --template debug</code>.</p>"},{"location":"default_templates/markdown_building_blocks/","title":"Markdown building blocks","text":"<p>This page provides an overview of the building blocks for writing your own findings. It covers the nuances of the markdown syntax available for the default templates.</p> <p>For more details about the markdown language, we recommend checking the Markdown Guide and Pandoc Flavoured Markdown.</p> <p>Tip</p> <p>The public templates include a <code>generic/test_finding</code> example. You can use it as a reference and inspiration for creating your own findings.</p>"},{"location":"default_templates/markdown_building_blocks/#text-highlighting","title":"Text highlighting","text":"<p>The template supports various text highlighting options:</p> <ul> <li>Emphasis: Use <code>*</code> or <code>_</code> to emphasize text.</li> <li>Strong emphasis: Use <code>**</code> or <code>__</code> to make text bold.</li> <li>Strike-through: Use <code>~~</code> to strike through text.</li> <li>Subscripts: Use <code>H~2~O</code> to create subscripts.</li> <li>Superscripts: Use <code>x^2^</code> to create superscripts.</li> <li>Underlining: Use <code>[Underline this.]{.underline}</code> to underline text.</li> <li>Small caps: Use <code>[Small caps]{.smallcaps}</code> to create small caps text.</li> </ul>"},{"location":"default_templates/markdown_building_blocks/#acronyms","title":"Acronyms","text":"<p>Another feature of the template is the ability to define acronyms using the <code>[!acr]</code> syntax, implemented via the pandoc filter.</p> <p>This feature supports both capitalization and pluralization:</p> <ul> <li>Capitalization: Use the <code>^</code> prefix, e.g., <code>[!^acr]</code>.</li> <li>Pluralization: Use the <code>+</code> prefix, e.g., <code>[!+acr]</code>.</li> </ul> <p>By default, the acronym appears as <code>acronym (acr)</code> on the first occurrence and <code>acr</code> thereafter. You can explicitly set the form using the following suffixes:</p> <ul> <li><code>&lt;</code> for the short form</li> <li><code>&gt;</code> for the long form</li> <li><code>!</code> for the full form.</li> </ul> Check this reference for all possible combinations. Form Tag Display Default <code>[!acr]</code> acronym (acr) Short <code>[!acr&lt;]</code> acr Long <code>[!acr&gt;]</code> acronym Full <code>[!acr!]</code> acronym (acr) Default plural <code>[!+acr]</code> acrs Short plural <code>[!+acr&lt;]</code> acrs Long plural <code>[!+acr&gt;]</code> acronyms Full plural <code>[!+acr!]</code> acronyms (acrs) Default capitalized <code>[!^acr]</code> Acr Short capitalized <code>[!^acr&lt;]</code> Acr Long capitalized <code>[!^acr&gt;]</code> Acronym Full capitalized <code>[!^acr!]</code> Acronym (acr) Default capitalized plural <code>[!+^acr]</code> Acrs Short capitalized plural <code>[!+^acr&lt;]</code> Acrs Long capitalized plural <code>[!+^acr&gt;]</code> Acronyms Full capitalized plural <code>[!+^acr!]</code> Acronyms (acrs)"},{"location":"default_templates/markdown_building_blocks/#code","title":"Code","text":"<p>Another feature implemented via the pandoc filter is code typesetting. Code segments are highlighted using the pygments library and typeset using the fvetxra package. Both inline and block code segments are supported.</p> <p>The language can be specified directly after the backticks (<code>`</code>).</p> <pre><code>```py\nrandom.seed(42)\nprint(random.random)\n```\n</code></pre> <p>Alternatively, you can use the full syntax with the language specified as a dot parameter.</p> <pre><code>```{.py}\nrandom.seed(42)\nprint(random.random)\n```\n</code></pre>"},{"location":"default_templates/markdown_building_blocks/#other-features","title":"Other features","text":"<p>The public template is configured to support all the default pandoc markdown features. This includes:</p> <ul> <li>Text emphasizing</li> <li>Lists</li> <li>Unordered</li> <li>Ordered</li> <li>Task</li> <li>Definition</li> <li>Tables</li> <li>Math</li> <li>Links</li> <li>Footnotes</li> <li>Images</li> </ul>"},{"location":"default_templates/structure/","title":"Structure","text":"<p>Tip</p> <p>If you are looking for explanation of the structure from the perspective of a project, please refer to the project structure section in the documentation.</p> <pre><code>\u251c\u2500\u2500 categories/\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 &lt;category&gt;/\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 findings/\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 &lt;name&gt;.md.j2\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 skel/\n\u2502\u00a0\u00a0     \u2502   \u251c\u2500\u2500 findings/\n\u2502\u00a0\u00a0     \u2502   \u2502\u00a0\u00a0 \u2514\u2500\u2500 _base.md\n\u2502\u00a0\u00a0     \u2502   \u251c\u2500\u2500 approach.tex.j2\n\u2502\u00a0\u00a0     \u2502   \u2514\u2500\u2500 scope.tex.j2\n|       \u251c\u2500\u2500 finding_group.tex.j2\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 target.tex.j2\n\u251c\u2500\u2500 pandocfilters/\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 acronyms.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 graphics.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 verbatim.py\n\u251c\u2500\u2500 plugins/\n\u2514\u2500\u2500 skel/\n    \u251c\u2500\u2500 includes/\n    |   \u251c\u2500\u2500 glossary.tex\n    |   \u251c\u2500\u2500 macros.tex.j2\n    |   \u251c\u2500\u2500 pygments.sty\n    |   \u2514\u2500\u2500 sereto.cls\n    \u251c\u2500\u2500 layouts/\n    |   \u251c\u2500\u2500 _base.md\n    |   \u251c\u2500\u2500 debug.tex.j2\n    |   \u251c\u2500\u2500 finding_group.tex.j2\n    |   \u251c\u2500\u2500 report.tex.j2\n    |   \u251c\u2500\u2500 sow.tex.j2\n    |   \u2514\u2500\u2500 target.tex.j2\n    \u251c\u2500\u2500 outputs/\n    \u251c\u2500\u2500 pictures/\n    \u251c\u2500\u2500 .sereto\n    \u2514\u2500\u2500 .seretoignore\n</code></pre>"},{"location":"default_templates/structure/#categories","title":"<code>categories</code>","text":"<p>This directory encompasses a collection of templates for all categories of findings, such as dast (Dynamic Application Security Testing) and sast (Static Application Security Testing). Each category is represented by a dedicated directory bearing the corresponding name.</p>"},{"location":"default_templates/structure/#findings","title":"<code>findings</code>","text":"<p>This directory houses the finding templates specific to the corresponding category.</p>"},{"location":"default_templates/structure/#skel","title":"<code>skel</code>","text":"<p>This directory contains the skeleton files for a specific category. The contents of this directory are utilized to populate a new target directory.</p> <ul> <li><code>findings</code>: This directory stores the finding files. Each finding is documented separately within this directory.</li> <li><code>approach.tex.j2</code>: This file represents the approach that was used during the penetration test. It provides a detailed description of the methodology employed.</li> <li><code>scope.tex.j2</code>: This file defines the exact scope of the penetration test for a specific target. It outlines the boundaries and limitations of the assessment.</li> <li>Some categories may utilize other more specific templates, such as <code>scenarios.tex.j2</code> for providing detailed scenarios in <code>scenario</code> category.</li> </ul>"},{"location":"default_templates/structure/#finding_grouptexj2","title":"<code>finding_group.tex.j2</code>","text":"<p>This file contains the template for the finding group. It is used to group individual findings together.</p>"},{"location":"default_templates/structure/#targettexj2","title":"<code>target.tex.j2</code>","text":"<p>This file includes information such as approach, scope, and all findings associated with specific target.</p>"},{"location":"default_templates/structure/#pandocfilters","title":"<code>pandocfilters</code>","text":"<p>This directory houses the pandoc filters utilized for processing the markdown files. By default, the filters <code>acronyms.py</code>, <code>graphics.py</code>, and <code>verbatim.py</code> are employed to process the markdown files. These filters play a crucial role in enhancing the functionality and formatting of the markdown content.</p>"},{"location":"default_templates/structure/#plugins","title":"<code>plugins</code>","text":"<p>This directory contains an example how to define custom plugins. Plugins are used to extend the functionality of SeReTo and can be customized to suit the specific requirements of the user.</p>"},{"location":"default_templates/structure/#skel_1","title":"<code>skel</code>","text":"<p>This directory serves as a skeleton for new projects. When creating a new project, contents of this directory are used to populate it.</p> <p>Tip</p> <p>For a detailed explanation of each file in the <code>skel</code> folder, please refer to the project files section in the documentation.</p>"},{"location":"development/code/","title":"Code","text":""},{"location":"development/code/#development","title":"Development","text":"<p>It is recommended to create a persistent <code>.venv</code> directory for development (<code>uv</code> can handle also ephemeral envs):</p> <pre><code>uv venv .venv\nsource .venv/bin/activate\n\n# install SeReTo in editable mode\nuv pip install -e \".[dev]\"\n\n# install template dependencies\nuv pip install -r &lt;path&gt;/templates/requirements.txt\n</code></pre>"},{"location":"development/code/#format","title":"Format","text":"<p>We are using <code>ruff</code> to automatically format the code. The command is defined as an environment in Tox:</p> <pre><code>tox -e format\n</code></pre>"},{"location":"development/documentation/","title":"Documentation","text":""},{"location":"development/documentation/#serving-the-documentation-locally","title":"Serving the documentation locally","text":"<p>Install dependencies and start the live preview server:</p> <pre><code>uv run --with '.[docs]' mkdocs serve\n</code></pre> <p>Then open the URL shown in the terminal output (typically http://127.0.0.1:8000).</p> <p>The server auto-reloads when you edit Markdown or configuration files.</p> <p>Optional:</p> <ul> <li>Change host/port: <code>uv run --with '.[docs]' mkdocs serve -a 0.0.0.0:8001</code></li> <li>Only build without starting the server: <code>uv run --with '.[docs]' mkdocs build</code> (outputs to the <code>site/</code> directory)</li> <li>Clean previous build: remove the <code>site/</code> directory before building if needed</li> </ul>"},{"location":"development/documentation/#writing-documentation","title":"Writing documentation","text":""},{"location":"development/documentation/#generating-gifs","title":"Generating GIFs","text":"<p>We use VHS to record GIFs for the documentation. A <code>Dockerfile</code> is provided in the <code>docs/assets/gifs/</code> directory to simplify the process of recording and generating GIFs.</p> <p>To build the Docker image, run: <pre><code>cd docs/assets/gifs/\ndocker build -t vhs -f vhs.Dockerfile .\n</code></pre></p> <p>With the following command, the GIF can be recorded based on the provided <code>.tape</code> file: <pre><code>docker run --rm -v \"$PWD:/vhs\" vhs new-project.tape\n</code></pre></p> <p>Since the docker is running with a low-privileged user, <code>vhs</code> may have problems writing to the specified volume. On Linux, this can be fixed by adding extended permissions to the directory for user with UID 1001, e.g.: <pre><code>setfacl -m u:1001:rwx .\n</code></pre></p>"},{"location":"development/release/","title":"Release","text":"<ol> <li>Update the version in <code>pyproject.toml</code></li> <li>Update the changelog in <code>CHANGELOG.md</code><ul> <li>Add a new section for the new version below the \"Unreleased\" section</li> <li>At the bottom of the changelog, update the comparison link for the \"Unreleased\" and new versions</li> </ul> </li> <li>Generate new <code>uv.lock</code> file with <code>uv lock</code></li> <li>With the changes, create commit with message \"Bump SeReTo version to x.y.z\"</li> <li>Create a new tag with <code>git tag vx.y.z</code></li> </ol>"},{"location":"development/tests/","title":"Tests","text":"<p>We are using Tox to run all the tests with a single command:</p> <pre><code>tox\n</code></pre> <p>This will:</p> <ul> <li>lint the code with <code>ruff</code></li> <li>perform type checking with <code>mypy</code></li> <li>run tests for several supported Python versions using <code>pytest</code></li> </ul>"},{"location":"getting_started/installation/","title":"Installation","text":""},{"location":"getting_started/installation/#system-requirements","title":"System Requirements","text":"<ul> <li>Python 3.12+</li> </ul>"},{"location":"getting_started/installation/#install-dependencies","title":"Install dependencies","text":""},{"location":"getting_started/installation/#common","title":"Common","text":""},{"location":"getting_started/installation/#uv","title":"<code>uv</code>","text":"<p>You might skip this step if you know what you are doing and prefer other methods of installation for Python packages (e.g. <code>pip</code>).</p> <p>For installation instructions visit: https://docs.astral.sh/uv/getting-started/installation/</p>"},{"location":"getting_started/installation/#pandoc","title":"Pandoc","text":"<p>Pandoc is used as a default command for transformation of markdown files to TeX.</p> <p>For installation instructions visit: https://pandoc.org/installing.html</p> <p>E.g.:</p> UbuntuFedoraWindows <pre><code>sudo apt install pandoc\n</code></pre> <pre><code>sudo dnf install pandoc\n</code></pre> <pre><code>winget install --source winget --exact --id JohnMacFarlane.Pandoc\n</code></pre> <p>For certain installations (e.g., using <code>uv</code>), it is recommended to install the <code>pandocfilters</code> package system-wide. This is because the Pandoc tool is executed in a new process, which will not have access to SeReTo dependencies.</p> <pre><code>pip install pandocfilters\n</code></pre>"},{"location":"getting_started/installation/#linux","title":"Linux","text":"<p>First see Common section.</p>"},{"location":"getting_started/installation/#tex-live","title":"TeX Live","text":"<p>TeX Live is a distribution of the TeX/LaTeX typesetting system.</p> UbuntuFedora <pre><code>sudo apt install texlive-full\n</code></pre> <pre><code>sudo dnf install texlive-scheme-full\n</code></pre>"},{"location":"getting_started/installation/#windows","title":"Windows","text":"<p>First see Common section.</p>"},{"location":"getting_started/installation/#miktex","title":"MikTeX","text":"<p>MikTeX is a distribution of the TeX/LaTeX typesetting system for Microsoft Windows.</p> <p>For installation instructions visit: https://miktex.org/download</p>"},{"location":"getting_started/installation/#perl","title":"Perl","text":"<p>Perl is a programming language that is commonly used for text manipulation.</p> <p>Install e.g. Strawberry Perl from: https://strawberryperl.com/</p>"},{"location":"getting_started/installation/#install-sereto","title":"Install SeReTo","text":"PyPIGitHub <pre><code>uv tool install sereto\n</code></pre> <pre><code>uv tool install git+https://github.com/s3r3t0/sereto\n</code></pre>"},{"location":"getting_started/installation/#docker","title":"Docker","text":"<p>Alternatively you can use SeReTo in a Docker container. You will need to mount the directories with projects and templates to the container.</p> DockerHubBuild <pre><code>docker run -it --rm -v \"&lt;path_to_projects&gt;:/projects\" -v \"&lt;path_to_templates&gt;:/templates\" sereto/sereto\n</code></pre> <pre><code>docker build . -t sereto\ndocker run -it --rm -v \"&lt;path_to_projects&gt;:/projects\" -v \"&lt;path_to_templates&gt;:/templates\" sereto\n</code></pre>"},{"location":"getting_started/security_considerations/","title":"Security Considerations","text":"<p>Before you start using this tool, please consider the following:</p>"},{"location":"getting_started/security_considerations/#write-access-to-settings-file","title":"Write access to settings file","text":"<p>The global settings file contains the commands that are executed during the rendering process. It is important to note that if an attacker gains write access to this file, they can execute arbitrary commands on your machine, potentially compromising its security.</p> <p>For standard installations, this should not be a concern.</p> <p>Please let us know if you have any further questions or concerns.</p>"},{"location":"getting_started/settings/","title":"Settings","text":"<p>To view the current settings, including defaults, use the command <code>sereto settings show</code>. To edit the settings in <code>EDITOR</code>, run <code>sereto settings edit</code>.</p>"},{"location":"getting_started/settings/#minimal-settings","title":"Minimal settings","text":"<p>As a bare minimum, you need to specify a <code>projects_path</code> and a <code>templates_path</code>.</p> <p>If you don't have the variables configured, you will be prompted to enter them when you run any command:</p> <pre><code>sereto new TEST\nIt seems like this is the first time you're running the tool. Let's set it up!\n\n\ud83d\udcc2 Enter the path to the projects directory: /home/demo/sereto_projects\n\ud83d\udcc2 Enter the path to the templates directory: /home/demo/sereto_templates\n</code></pre>"},{"location":"getting_started/settings/#projects_path","title":"<code>projects_path</code>","text":"<p>The path to the directory where the projects are located.</p>"},{"location":"getting_started/settings/#templates_path","title":"<code>templates_path</code>","text":"<p>The path to the directory where the templates are located.</p>"},{"location":"getting_started/settings/#common-settings","title":"Common settings","text":""},{"location":"getting_started/settings/#default_people","title":"<code>default_people</code>","text":"<p>Default list of people to use in new projects. Each person object may include:</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>PersonType</code> <p>Type of the person in relation to the assessment.</p> <code>name</code> <code>str | None</code> <p>Full name of the person.</p> <code>business_unit</code> <code>str | None</code> <p>Business unit the person belongs to.</p> <code>email</code> <code>EmailStr | None</code> <p>Email address of the person.</p> <code>role</code> <code>str | None</code> <p>Role of the person within the organization.</p> <p>The <code>type</code> attribute of a person can have the following values:</p> <p>Attributes:</p> <ul> <li> <code>author</code>           \u2013            <p>Author of the report.</p> </li> <li> <code>requestor</code>           \u2013            <p>Person who requested the assessment.</p> </li> <li> <code>asset_owner</code>           \u2013            <p>Owner of the asset being tested.</p> </li> <li> <code>security_officer</code>           \u2013            <p>Security officer responsible for the asset.</p> </li> <li> <code>technical_contact</code>           \u2013            <p>Person who can answer technical questions about the asset.</p> </li> <li> <code>reviewer</code>           \u2013            <p>Reviewer of the report.</p> </li> </ul>"},{"location":"getting_started/settings/#plugins","title":"<code>plugins</code>","text":"<p>Plugins settings.</p> <p>Attributes:</p> Name Type Description <code>enabled</code> <code>bool</code> <p>whether plugins are enabled</p> <code>directory</code> <code>str</code> <p>path to the directory containing plugins (<code>%TEMPLATES%</code> will be replaced with the templates path`)</p>"},{"location":"getting_started/settings/#rendering-settings","title":"Rendering settings","text":"<p>For rendering the documents, external commands, such as <code>latexmk</code>, are used. The sequence of commands to be used is specified in recipes.</p>"},{"location":"getting_started/settings/#render","title":"<code>render</code>","text":"<p>Rendering settings.</p> <p>Attributes:</p> Name Type Description <code>report_recipes</code> <code>Annotated[list[RenderRecipe], MinLen(1)]</code> <p>list of <code>RenderRecipe</code>s for rendering reports</p> <code>finding_group_recipes</code> <code>Annotated[list[RenderRecipe], MinLen(1)]</code> <p>list of <code>RenderRecipe</code>s for rendering finding groups</p> <code>sow_recipes</code> <code>Annotated[list[RenderRecipe], MinLen(1)]</code> <p>list of <code>RenderRecipe</code>s for rendering SoWs</p> <code>target_recipes</code> <code>Annotated[list[RenderRecipe], MinLen(1)]</code> <p>list of <code>RenderRecipe</code>s for rendering targets</p> <code>convert_recipes</code> <code>Annotated[list[ConvertRecipe], MinLen(1)]</code> <p>list of <code>ConvertRecipe</code>s for converting between file formats</p> <code>tools</code> <code>Annotated[list[RenderTool], MinLen(1)]</code> <p>list of <code>RenderTool</code>s used in recipes</p>"},{"location":"getting_started/settings/#tools","title":"<code>tools</code>","text":"<p>List of rendering tools to be used in recipes. Each tool has the following attributes.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>name of the tool</p> <code>command</code> <code>str</code> <p>command to run</p> <code>args</code> <code>list[str]</code> <p>list of arguments to pass to the command</p>"},{"location":"getting_started/settings/#report_recipes-finding_group_recipes-sow_recipes-target_recipes","title":"<code>report_recipes</code>, <code>finding_group_recipes</code>, <code>sow_recipes</code>, <code>target_recipes</code>","text":"<p>Lists of recipes to be used for reports, finding groups, SoWs and targets, respectively. Each recipe has the following attributes.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>name of the recipe</p> <code>tools</code> <code>Annotated[list[str], MinLen(1)]</code> <p>list of <code>RenderTool</code> names to run</p> <code>intermediate_format</code> <code>FileFormat</code> <p>supported <code>FileFormat</code></p>"},{"location":"getting_started/settings/#convert_recipes","title":"<code>convert_recipes</code>","text":"<p>List of recipes to be used for converting between file formats. Each recipe has the following attributes.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>name of the recipe</p> <code>tools</code> <code>Annotated[list[str], MinLen(1)]</code> <p>list of <code>RenderTool</code> names to run</p> <code>input_format</code> <code>FileFormat</code> <p>input file format</p> <code>output_format</code> <code>FileFormat</code> <p>output file format</p>"},{"location":"getting_started/settings/#other-settings","title":"Other settings","text":""},{"location":"getting_started/settings/#categories","title":"<code>categories</code>","text":"<p>List of categories, such as DAST, SAST, infrastructure, etc.</p>"},{"location":"getting_started/settings/#risk_due_dates","title":"<code>risk_due_dates</code>","text":"<p>A dictionary of risk levels and time periods in which findings with given risk levels should be addressed. These values are used to set the recommended due dates for findings in the report. The values follow the ISO 8601 format for durations (e.g., <code>P7D</code> for 7 days).</p>"},{"location":"getting_started/settings/#full-configuration-example","title":"Full configuration example","text":"<pre><code>{\n  \"projects_path\": \"/home/demo/sereto/projects\",\n  \"templates_path\": \"/home/demo/sereto/templates\",\n  \"default_people\": [\n    {\n      \"type\": \"author\",\n      \"name\": \"John Doe\",\n      \"business_unit\": \"Pentest Unit\",\n      \"email\": \"john.doe@example.com\",\n      \"role\": \"Penetration Tester\"\n    },\n    {\n      \"type\": \"technical_contact\",\n      \"name\": \"Jane Doe\",\n      \"business_unit\": \"Pentest Unit\",\n      \"email\": \"jane.doe@example.com\",\n      \"role\": \"Pentest Manager\"\n    }\n  ],\n  \"plugins\": {\n    \"enabled\": true,\n    \"directory\": \"/home/demo/sereto/plugins\"\n  }\n  \"render\": {\n    \"report_recipes\": [\n      {\n        \"name\": \"default-report\",\n        \"tools\": [\n          \"latexmk\"\n        ],\n        \"intermediate_format\": \"tex\"\n      }\n    ],\n    \"finding_group_recipes\": [\n      {\n        \"name\": \"default-finding\",\n        \"tools\": [\n          \"latexmk-finding\"\n        ],\n        \"intermediate_format\": \"tex\"\n      }\n    ],\n    \"sow_recipes\": [\n      {\n        \"name\": \"default-sow\",\n        \"tools\": [\n          \"latexmk\"\n        ],\n        \"intermediate_format\": \"tex\"\n      }\n    ],\n    \"target_recipes\": [\n      {\n        \"name\": \"default-target\",\n        \"tools\": [\n          \"latexmk-target\"\n        ],\n        \"intermediate_format\": \"tex\"\n      }\n    ],\n    \"convert_recipes\": [\n      {\n        \"name\": \"convert-md-to-tex\",\n        \"tools\": [\n          \"pandoc-md\"\n        ],\n        \"input_format\": \"md\",\n        \"output_format\": \"tex\"\n      }\n    ],\n    \"tools\": [\n      {\n        \"name\": \"pandoc-md\",\n        \"command\": \"pandoc\",\n        \"args\": [\n          \"--from=markdown-implicit_figures+lists_without_preceding_blankline\",\n          \"--to=latex\",\n          \"--sandbox\",\n          \"--filter=%TEMPLATES%/pandocfilters/acronyms.py\",\n          \"--filter=%TEMPLATES%/pandocfilters/graphics.py\",\n          \"--filter=%TEMPLATES%/pandocfilters/verbatim.py\",\n        ]\n      },\n      {\n        \"name\": \"latexmk\",\n        \"command\": \"latexmk\",\n        \"args\": [\n          \"-xelatex\",\n          \"-interaction=batchmode\",\n          \"-halt-on-error\",\n          \"%DOC%\"\n        ]\n      },\n      {\n        \"name\": \"latexmk-target\",\n        \"command\": \"latexmk\",\n        \"args\": [\n          \"-xelatex\",\n          \"-interaction=batchmode\",\n          \"-halt-on-error\",\n          \"%DOC%\"\n        ]\n      },\n      {\n        \"name\": \"latexmk-finding\",\n        \"command\": \"latexmk\",\n        \"args\": [\n          \"-xelatex\",\n          \"-interaction=batchmode\",\n          \"-halt-on-error\",\n          \"%DOC%\"\n        ]\n      }\n    ]\n  },\n  \"categories\": [\n    \"scenario\",\n    \"mobile\",\n    \"cicd\",\n    \"sast\",\n    \"rd\",\n    \"infrastructure\",\n    \"dast\",\n    \"portal\",\n    \"generic\",\n    \"kubernetes\"\n  ],\n  \"risk_due_dates\": {\n    \"critical\": \"P7D\",\n    \"high\": \"P14D\",\n    \"medium\": \"P30D\",\n    \"low\": \"P90D\"\n  }\n}\n</code></pre>"},{"location":"reference/build/","title":"Build","text":""},{"location":"reference/build/#sereto.build","title":"<code>sereto.build</code>","text":""},{"location":"reference/build/#sereto.build.build_subfinding","title":"<code>build_subfinding(project, target, sub_finding, version, intermediate_format, converter=None)</code>","text":"<p>Process a sub-finding into the specified format and write it to the \".build\" directory.</p> <p>The sub-finding is first rendered as a Jinja2 template, then converted to the desired format. If the output file already exists and has the same content, it is not overwritten (to preserve timestamps).</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>Project</code> <p>Project's representation.</p> required <code>target</code> <code>Target</code> <p>The target containing the sub-finding.</p> required <code>sub_finding</code> <code>SubFinding</code> <p>The sub-finding to process.</p> required <code>version</code> <code>ProjectVersion</code> <p>The project version to use for rendering.</p> required <code>intermediate_format</code> <code>FileFormat</code> <p>The desired output format (e.g., FileFormat.tex).</p> required <code>converter</code> <code>str | None</code> <p>The convert recipe used for file format transformations. If None, the first recipe is used.</p> <code>None</code> Source code in <code>sereto/build.py</code> <pre><code>@validate_call\ndef build_subfinding(\n    project: Project,\n    target: Target,\n    sub_finding: SubFinding,\n    version: ProjectVersion,\n    intermediate_format: FileFormat,\n    converter: str | None = None,\n) -&gt; None:\n    \"\"\"Process a sub-finding into the specified format and write it to the \".build\" directory.\n\n    The sub-finding is first rendered as a Jinja2 template, then converted to the desired format.\n    If the output file already exists and has the same content, it is not overwritten (to preserve timestamps).\n\n    Args:\n        project: Project's representation.\n        target: The target containing the sub-finding.\n        sub_finding: The sub-finding to process.\n        version: The project version to use for rendering.\n        intermediate_format: The desired output format (e.g., FileFormat.tex).\n        converter: The convert recipe used for file format transformations. If None, the first recipe is used.\n    \"\"\"\n    # Initialize the build directory\n    init_build_dir(project=project, target=target)\n\n    version_config = project.config.at_version(version=version)\n\n    # Render Jinja2 template\n    finding_content = render_jinja2(\n        templates=[sub_finding.path.parent],\n        file=sub_finding.path,\n        vars={\n            \"f\": sub_finding,\n            \"c\": version_config,\n            \"config\": project.config,\n            \"version\": version,\n        },\n    )\n\n    # Convert to desired format\n    content = apply_convertor(\n        input=finding_content,\n        input_format=sub_finding.format,\n        output_format=intermediate_format,\n        render=project.settings.render,\n        recipe=converter,\n        replacements={\n            \"%TEMPLATES%\": str(project.settings.templates_path),\n        },\n    )\n\n    # Write the finding to the \".build\" directory; do not overwrite the same content (preserve timestamps)\n    write_if_different(\n        file=project.path\n        / \".build\"\n        / target.uname\n        / f\"{sub_finding.path.name.removesuffix(f'.{sub_finding.format.value}.j2')}.{intermediate_format.value}\",\n        content=content,\n    )\n</code></pre>"},{"location":"reference/config/","title":"Config","text":""},{"location":"reference/config/#sereto.config","title":"<code>sereto.config</code>","text":""},{"location":"reference/config/#sereto.config.Config","title":"<code>Config</code>  <code>dataclass</code>","text":"Source code in <code>sereto/config.py</code> <pre><code>@dataclass\nclass Config:\n    sereto_version: SeretoVersion\n    version_configs: dict[ProjectVersion, VersionConfig]\n    path: FilePath\n    risk_due_dates: dict[Risk, timedelta]\n\n    @classmethod\n    @validate_call\n    def load_from(cls, path: FilePath, templates: DirectoryPath, risk_due_dates: dict[Risk, timedelta]) -&gt; Self:\n        config = ConfigModel.load_from(path)\n\n        return cls(\n            sereto_version=config.sereto_version,\n            version_configs={\n                version: VersionConfig.from_model(\n                    model=version_config,\n                    version=version,\n                    project_path=path.parent,\n                    templates=templates,\n                    risk_due_dates=risk_due_dates,\n                )\n                for version, version_config in config.version_configs.items()\n            },\n            path=path,\n            risk_due_dates=risk_due_dates,\n        )\n\n    def to_model(self) -&gt; ConfigModel:\n        return ConfigModel(\n            sereto_version=self.sereto_version,\n            version_configs={version: config.to_model() for version, config in self.version_configs.items()},\n        )\n\n    def save(self) -&gt; None:\n        self.path.write_text(self.to_model().model_dump_json(indent=2) + \"\\n\", encoding=\"utf-8\")\n\n    @property\n    def versions(self) -&gt; list[ProjectVersion]:\n        \"\"\"Get a sorted list of project versions in ascending order.\"\"\"\n        return sorted(list(self.version_configs.keys()))\n\n    @validate_call\n    def at_version(self, version: str | ProjectVersion) -&gt; VersionConfig:\n        \"\"\"Return the configuration at a specific version.\n\n        Args:\n            version: Selects which version of the configuration should be returned.\n\n        Returns:\n            Configuration for the project at the specified version.\n\n        Raises:\n            SeretoValueError: If the specified version is unknown.\n        \"\"\"\n        if isinstance(version, str):\n            version = ProjectVersion.from_str(version)\n\n        if version not in self.versions:\n            raise SeretoValueError(f\"version '{version}' not found\")\n\n        return self.version_configs[version]\n\n    @property\n    def first_version(self) -&gt; ProjectVersion:\n        \"\"\"Get the first version present in the configuration.\"\"\"\n        return self.versions[0]\n\n    @property\n    def last_version(self) -&gt; ProjectVersion:\n        \"\"\"Get the last version present in the configuration.\"\"\"\n        return self.versions[-1]\n\n    @property\n    def first_config(self) -&gt; VersionConfig:\n        \"\"\"Get the configuration for the first project version.\"\"\"\n        return self.at_version(self.first_version)\n\n    @property\n    def last_config(self) -&gt; VersionConfig:\n        \"\"\"Get the configuration for the last project version.\"\"\"\n        return self.at_version(self.last_version)\n\n    def due_date(self, risk: Risk, reported_on: SeretoDate | None = None) -&gt; SeretoDate | None:\n        \"\"\"Get the due date for a specific risk level.\n\n        For findings discovered during a retest, the `reported_on` date can be specified.\n        \"\"\"\n        if risk not in self.risk_due_dates:\n            return None\n\n        report_sent_date = (\n            self.first_config.filter_dates(\n                type=[DateType.report_sent, DateType.review, DateType.pentest_ongoing], last_date=True\n            )\n            if reported_on is None\n            else reported_on\n        )\n        if report_sent_date is None:\n            return None\n\n        # Calculate the due date by adding the risk's due timedelta to the report sent date\n        return report_sent_date + self.risk_due_dates[risk]\n\n    @validate_call\n    def add_version_config(\n        self, version: ProjectVersion, config: VersionConfigModel, templates: DirectoryPath\n    ) -&gt; Self:\n        \"\"\"Add a new version configuration to the project.\n\n        Args:\n            version: The version of the new configuration.\n            config: The configuration to add.\n\n        Returns:\n            The updated configuration.\n\n        Raises:\n            SeretoValueError: If the specified version already exists.\n        \"\"\"\n        if version in self.versions:\n            raise SeretoValueError(f\"version '{version}' already exists\")\n\n        self.version_configs[version] = VersionConfig.from_model(\n            model=config,\n            version=version,\n            project_path=self.path.parent,\n            templates=templates,\n            risk_due_dates=self.risk_due_dates,\n        )\n\n        return self\n\n    @validate_call\n    def replace_version_config(\n        self, version: ProjectVersion, config: VersionConfigModel, templates: DirectoryPath\n    ) -&gt; Self:\n        \"\"\"Replace an existing version configuration.\n\n        Args:\n            version: The version of the configuration to replace.\n            config: The new configuration.\n            templates: The path to the templates directory.\n\n        Returns:\n            The updated configuration.\n\n        Raises:\n            SeretoValueError: If the specified version does not exist.\n        \"\"\"\n        if version not in self.versions:\n            raise SeretoValueError(f\"version '{version}' does not exist\")\n\n        self.version_configs[version] = VersionConfig.from_model(\n            model=config,\n            version=version,\n            project_path=self.path.parent,\n            templates=templates,\n            risk_due_dates=self.risk_due_dates,\n        )\n\n        return self\n</code></pre>"},{"location":"reference/config/#sereto.config.Config.first_config","title":"<code>first_config</code>  <code>property</code>","text":"<p>Get the configuration for the first project version.</p>"},{"location":"reference/config/#sereto.config.Config.first_version","title":"<code>first_version</code>  <code>property</code>","text":"<p>Get the first version present in the configuration.</p>"},{"location":"reference/config/#sereto.config.Config.last_config","title":"<code>last_config</code>  <code>property</code>","text":"<p>Get the configuration for the last project version.</p>"},{"location":"reference/config/#sereto.config.Config.last_version","title":"<code>last_version</code>  <code>property</code>","text":"<p>Get the last version present in the configuration.</p>"},{"location":"reference/config/#sereto.config.Config.versions","title":"<code>versions</code>  <code>property</code>","text":"<p>Get a sorted list of project versions in ascending order.</p>"},{"location":"reference/config/#sereto.config.Config.add_version_config","title":"<code>add_version_config(version, config, templates)</code>","text":"<p>Add a new version configuration to the project.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>ProjectVersion</code> <p>The version of the new configuration.</p> required <code>config</code> <code>VersionConfigModel</code> <p>The configuration to add.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The updated configuration.</p> <p>Raises:</p> Type Description <code>SeretoValueError</code> <p>If the specified version already exists.</p> Source code in <code>sereto/config.py</code> <pre><code>@validate_call\ndef add_version_config(\n    self, version: ProjectVersion, config: VersionConfigModel, templates: DirectoryPath\n) -&gt; Self:\n    \"\"\"Add a new version configuration to the project.\n\n    Args:\n        version: The version of the new configuration.\n        config: The configuration to add.\n\n    Returns:\n        The updated configuration.\n\n    Raises:\n        SeretoValueError: If the specified version already exists.\n    \"\"\"\n    if version in self.versions:\n        raise SeretoValueError(f\"version '{version}' already exists\")\n\n    self.version_configs[version] = VersionConfig.from_model(\n        model=config,\n        version=version,\n        project_path=self.path.parent,\n        templates=templates,\n        risk_due_dates=self.risk_due_dates,\n    )\n\n    return self\n</code></pre>"},{"location":"reference/config/#sereto.config.Config.at_version","title":"<code>at_version(version)</code>","text":"<p>Return the configuration at a specific version.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str | ProjectVersion</code> <p>Selects which version of the configuration should be returned.</p> required <p>Returns:</p> Type Description <code>VersionConfig</code> <p>Configuration for the project at the specified version.</p> <p>Raises:</p> Type Description <code>SeretoValueError</code> <p>If the specified version is unknown.</p> Source code in <code>sereto/config.py</code> <pre><code>@validate_call\ndef at_version(self, version: str | ProjectVersion) -&gt; VersionConfig:\n    \"\"\"Return the configuration at a specific version.\n\n    Args:\n        version: Selects which version of the configuration should be returned.\n\n    Returns:\n        Configuration for the project at the specified version.\n\n    Raises:\n        SeretoValueError: If the specified version is unknown.\n    \"\"\"\n    if isinstance(version, str):\n        version = ProjectVersion.from_str(version)\n\n    if version not in self.versions:\n        raise SeretoValueError(f\"version '{version}' not found\")\n\n    return self.version_configs[version]\n</code></pre>"},{"location":"reference/config/#sereto.config.Config.due_date","title":"<code>due_date(risk, reported_on=None)</code>","text":"<p>Get the due date for a specific risk level.</p> <p>For findings discovered during a retest, the <code>reported_on</code> date can be specified.</p> Source code in <code>sereto/config.py</code> <pre><code>def due_date(self, risk: Risk, reported_on: SeretoDate | None = None) -&gt; SeretoDate | None:\n    \"\"\"Get the due date for a specific risk level.\n\n    For findings discovered during a retest, the `reported_on` date can be specified.\n    \"\"\"\n    if risk not in self.risk_due_dates:\n        return None\n\n    report_sent_date = (\n        self.first_config.filter_dates(\n            type=[DateType.report_sent, DateType.review, DateType.pentest_ongoing], last_date=True\n        )\n        if reported_on is None\n        else reported_on\n    )\n    if report_sent_date is None:\n        return None\n\n    # Calculate the due date by adding the risk's due timedelta to the report sent date\n    return report_sent_date + self.risk_due_dates[risk]\n</code></pre>"},{"location":"reference/config/#sereto.config.Config.replace_version_config","title":"<code>replace_version_config(version, config, templates)</code>","text":"<p>Replace an existing version configuration.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>ProjectVersion</code> <p>The version of the configuration to replace.</p> required <code>config</code> <code>VersionConfigModel</code> <p>The new configuration.</p> required <code>templates</code> <code>DirectoryPath</code> <p>The path to the templates directory.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The updated configuration.</p> <p>Raises:</p> Type Description <code>SeretoValueError</code> <p>If the specified version does not exist.</p> Source code in <code>sereto/config.py</code> <pre><code>@validate_call\ndef replace_version_config(\n    self, version: ProjectVersion, config: VersionConfigModel, templates: DirectoryPath\n) -&gt; Self:\n    \"\"\"Replace an existing version configuration.\n\n    Args:\n        version: The version of the configuration to replace.\n        config: The new configuration.\n        templates: The path to the templates directory.\n\n    Returns:\n        The updated configuration.\n\n    Raises:\n        SeretoValueError: If the specified version does not exist.\n    \"\"\"\n    if version not in self.versions:\n        raise SeretoValueError(f\"version '{version}' does not exist\")\n\n    self.version_configs[version] = VersionConfig.from_model(\n        model=config,\n        version=version,\n        project_path=self.path.parent,\n        templates=templates,\n        risk_due_dates=self.risk_due_dates,\n    )\n\n    return self\n</code></pre>"},{"location":"reference/config/#sereto.config.VersionConfig","title":"<code>VersionConfig</code>  <code>dataclass</code>","text":"Source code in <code>sereto/config.py</code> <pre><code>@dataclass\nclass VersionConfig:\n    version: ProjectVersion\n    id: str\n    name: str\n    version_description: str\n    risk_due_dates: dict[Risk, timedelta]\n    targets: list[Target] = field(default_factory=list)\n    dates: list[Date] = field(default_factory=list)\n    people: list[Person] = field(default_factory=list)\n\n    @validate_call\n    def to_model(self) -&gt; VersionConfigModel:\n        return VersionConfigModel(\n            id=self.id,\n            name=self.name,\n            version_description=self.version_description,\n            targets=[target.to_model() for target in self.targets],\n            dates=self.dates,\n            people=self.people,\n        )\n\n    @classmethod\n    @validate_call\n    def from_model(\n        cls,\n        model: VersionConfigModel,\n        version: ProjectVersion,\n        project_path: DirectoryPath,\n        templates: DirectoryPath,\n        risk_due_dates: dict[Risk, timedelta],\n    ) -&gt; Self:\n        return cls(\n            version=version,\n            id=model.id,\n            name=model.name,\n            version_description=model.version_description,\n            targets=[\n                Target.load(\n                    data=target,\n                    path=project_path / (target.uname + version.path_suffix),\n                    version=version,\n                    templates=templates,\n                )\n                for target in model.targets\n            ],\n            dates=model.dates,\n            people=model.people,\n            risk_due_dates=risk_due_dates,\n        )\n\n    def due_date_for(self, risk: Risk) -&gt; SeretoDate | None:\n        \"\"\"Get the due date for a specific risk level.\"\"\"\n        if risk not in self.risk_due_dates:\n            return None\n\n        report_sent_date = self.filter_dates(\n            type=[DateType.report_sent, DateType.review, DateType.pentest_ongoing], last_date=True\n        )\n        if report_sent_date is None:\n            return None\n\n        # Calculate the due date by adding the risk's due timedelta to the report sent date\n        return report_sent_date + self.risk_due_dates[risk]\n\n    @validate_call\n    def filter_targets(\n        self,\n        category: str | Iterable[str] | None = None,\n        name: str | None = None,\n        inverse: bool = False,\n    ) -&gt; list[Target]:\n        \"\"\"Filter targets based on specified criteria.\n\n        The regular expressions support the syntax of Python's `re` module.\n\n        Args:\n            category: The category of the target. Can be a single category, a list of categories, or None.\n            name: Regular expression to match the name of the target.\n            inverse: If True, return the inverse of the usual results.\n\n        Returns:\n            A list of targets matching the criteria.\n        \"\"\"\n        # Prepare categories for filtering\n        match category:\n            case str():\n                categories: list[str] | None = [category]\n            case Iterable():\n                categories = list(category)\n            case None:\n                categories = None\n\n        filtered_targets = [\n            t\n            for t in self.targets\n            if (categories is None or t.data.category in categories) and (name is None or re.search(name, t.data.name))\n        ]\n\n        if inverse:\n            return [t for t in self.targets if t not in filtered_targets]\n        return filtered_targets\n\n    @validate_call\n    def select_target(\n        self,\n        categories: Iterable[str],\n        selector: int | str | None = None,\n    ) -&gt; Target:\n        # only single target present\n        if selector is None:\n            if len(self.targets) != 1:\n                raise SeretoValueError(\n                    f\"cannot select target; no selector provided and there are {len(self.targets)} targets present\"\n                )\n            return self.targets[0]\n\n        # by index\n        if isinstance(selector, int) or selector.isnumeric():\n            ix = selector - 1 if isinstance(selector, int) else int(selector) - 1\n            if not (0 &lt;= ix &lt;= len(self.targets) - 1):\n                raise SeretoValueError(\"target index out of range\")\n\n            return self.targets[ix]\n\n        # by unique category\n        if selector in categories:\n            filtered_targets = [t for t in self.targets if t.data.category == selector]\n            match len(filtered_targets):\n                case 0:\n                    raise SeretoValueError(f\"category {selector!r} does not contain any target\")\n                case 1:\n                    return filtered_targets[0]\n                case _:\n                    raise SeretoValueError(\n                        f\"category {selector!r} contains multiple targets, use unique name when querying\"\n                    )\n\n        # by uname\n        filtered_targets = [t for t in self.targets if t.uname == selector]\n        if len(filtered_targets) != 1:\n            raise SeretoValueError(f\"target with uname {selector!r} not found\")\n        return filtered_targets[0]\n\n    @validate_call\n    @overload\n    def filter_dates(\n        self,\n        type: str | DateType | Iterable[str] | Iterable[DateType] | None = ...,\n        start: str | SeretoDate | None = ...,\n        end: str | SeretoDate | None = ...,\n        *,\n        first_date: Literal[True],\n        last_date: Literal[False] = False,\n        inverse: bool = False,\n    ) -&gt; SeretoDate | None: ...\n\n    @overload\n    def filter_dates(\n        self,\n        type: str | DateType | Iterable[str] | Iterable[DateType] | None = ...,\n        start: str | SeretoDate | None = ...,\n        end: str | SeretoDate | None = ...,\n        *,\n        first_date: Literal[False] = False,\n        last_date: Literal[True],\n        inverse: bool = False,\n    ) -&gt; SeretoDate | None: ...\n\n    @overload\n    def filter_dates(\n        self,\n        type: str | DateType | Iterable[str] | Iterable[DateType] | None = ...,\n        start: str | SeretoDate | None = ...,\n        end: str | SeretoDate | None = ...,\n        *,\n        first_date: Literal[False],\n        last_date: Literal[False],\n        inverse: bool = False,\n    ) -&gt; list[Date]: ...\n\n    def filter_dates(\n        self,\n        type: str | DateType | Iterable[str] | Iterable[DateType] | None = None,\n        start: str | SeretoDate | None = None,\n        end: str | SeretoDate | None = None,\n        *,\n        first_date: bool = False,\n        last_date: bool = False,\n        inverse: bool = False,\n    ) -&gt; list[Date] | SeretoDate | None:\n        \"\"\"Filter dates based on specified criteria.\n\n        The start and end dates are inclusive. For date ranges, a date is considered matching if it completely overlaps\n        with the specified range.\n\n        Args:\n            type: The type of the date. Can be `DateType`, a list of `DateType`s, or None.\n            start: Only dates on or after this date will be included.\n            end: Only dates on or before this date will be included.\n            first_date: If True, return the earliest date matching the criteria. Even for date ranges, only the start\n                date  is considered. The type returned is `SeretoDate` or None.\n            last_date: If True, return the latest date matching the criteria. Even for date ranges, only the end date\n                is considered. The type returned is `SeretoDate` or None.\n            inverse: If True, return the inverse of the usual results.\n\n        Returns:\n            For first_date or last_date = True, returns SeretoDate or None. Otherwise, returns a list[Date].\n        \"\"\"\n        # Check for invalid parameter combinations\n        if first_date and last_date:\n            raise SeretoValueError(\"cannot specify both first_date and last_date\")\n        if (first_date or last_date) and inverse:\n            raise SeretoValueError(\"cannot specify inverse with first_date or last_date\")\n\n        match type:\n            case str():\n                type = [DateType(type)]\n            case Iterable():\n                type = [DateType(t) for t in type]\n            case None:\n                pass\n\n        if isinstance(start, str):\n            start = SeretoDate.from_str(start)\n        if isinstance(end, str):\n            end = SeretoDate.from_str(end)\n\n        filtered_dates = [\n            d\n            for d in self.dates\n            if (type is None or d.type in type)\n            and (\n                start is None\n                or (isinstance(d.date, SeretoDate) and d.date &gt;= start)\n                or (isinstance(d.date, DateRange) and d.date.start &gt;= start)\n            )\n            and (\n                end is None\n                or (isinstance(d.date, SeretoDate) and d.date &lt;= end)\n                or (isinstance(d.date, DateRange) and d.date.end &lt;= end)\n            )\n        ]\n\n        if first_date:\n            single_dates = [d.date.start if isinstance(d.date, DateRange) else d.date for d in filtered_dates]\n            return min(single_dates, default=None)\n\n        if last_date:\n            single_dates = [d.date.end if isinstance(d.date, DateRange) else d.date for d in filtered_dates]\n            return max(single_dates, default=None)\n\n        if inverse:\n            return [d for d in self.dates if d not in filtered_dates]\n        return filtered_dates\n\n    @validate_call\n    def filter_people(\n        self,\n        type: str | PersonType | Iterable[str] | Iterable[PersonType] | None = None,\n        name: str | None = None,\n        business_unit: str | None = None,\n        email: str | None = None,\n        role: str | None = None,\n        inverse: bool = False,\n    ) -&gt; list[Person]:\n        \"\"\"Filter people based on specified criteria.\n\n        The regular expressions support the syntax of Python's `re` module.\n\n        Args:\n            type: The type of the person. Can be a single type, a list of types, or None.\n            name: Regular expression to match the name of the person.\n            business_unit: Regular expression to match the business unit of the person.\n            email: Regular expression to match the email of the person.\n            role: Regular expression to match the role of the person.\n            inverse: If True, return the inverse of the usual results.\n\n        Returns:\n            A list of people matching the criteria.\n        \"\"\"\n        match type:\n            case str():\n                type = [PersonType(type)]\n            case Iterable():\n                type = [PersonType(t) for t in type]\n            case None:\n                pass\n\n        filtered_people = [\n            p\n            for p in self.people\n            if (type is None or p.type in type)\n            and (name is None or (p.name is not None and re.search(name, p.name)))\n            and (business_unit is None or (p.business_unit is not None and re.search(business_unit, p.business_unit)))\n            and (email is None or (p.email is not None and re.search(email, p.email)))\n            and (role is None or (p.role is not None and re.search(role, p.role)))\n        ]\n\n        if inverse:\n            return [p for p in self.people if p not in filtered_people]\n        return filtered_people\n\n    @validate_call\n    def add_target(self, target: Target) -&gt; Self:\n        \"\"\"Add a target to the configuration.\n\n        Args:\n            target: The target to add.\n\n        Returns:\n            The configuration with the added target.\n        \"\"\"\n        self.targets.append(target)\n        return self\n\n    @validate_call\n    def delete_target(self, index: int) -&gt; Self:\n        \"\"\"Delete a target from the configuration.\n\n        Args:\n            index: The index of the target to delete. First item is 1.\n\n        Returns:\n            The configuration with the target deleted.\n        \"\"\"\n        # Convert to 0-based index\n        index -= 1\n\n        # Check if the index is in the allowed range\n        if not 0 &lt;= index &lt;= len(self.targets) - 1:\n            raise SeretoValueError(\"index out of range\")\n\n        # Delete the target\n        del self.targets[index]\n\n        return self\n\n    @validate_call\n    def add_date(self, date: Date) -&gt; Self:\n        \"\"\"Add a date to the configuration.\n\n        Args:\n            date: The date to add.\n\n        Returns:\n            The configuration with the added date.\n        \"\"\"\n        self.dates.append(date)\n        return self\n\n    @validate_call\n    def delete_date(self, index: int) -&gt; Self:\n        \"\"\"Delete a date from the configuration.\n\n        Args:\n            index: The index of the date to delete. First item is 1.\n\n        Returns:\n            The configuration with the date deleted.\n        \"\"\"\n        # Convert to 0-based index\n        index -= 1\n\n        # Check if the index is in the allowed range\n        if not 0 &lt;= index &lt;= len(self.dates) - 1:\n            raise SeretoValueError(\"index out of range\")\n\n        # Delete the date\n        del self.dates[index]\n\n        return self\n\n    @validate_call\n    def add_person(self, person: Person) -&gt; Self:\n        \"\"\"Add a person to the configuration.\n\n        Args:\n            person: The person to add.\n\n        Returns:\n            The configuration with the added person.\n        \"\"\"\n        self.people.append(person)\n        return self\n\n    @validate_call\n    def delete_person(self, index: int) -&gt; Self:\n        \"\"\"Delete a person from the configuration.\n\n        Args:\n            index: The index of the person to delete. First item is 1.\n\n        Returns:\n            The configuration with the person deleted.\n        \"\"\"\n        # Convert to 0-based index\n        index -= 1\n\n        # Check if the index is in the allowed range\n        if not 0 &lt;= index &lt;= len(self.people) - 1:\n            raise SeretoValueError(\"index out of range\")\n\n        # Delete the person\n        del self.people[index]\n\n        return self\n\n    @property\n    def report_sent_date(self) -&gt; SeretoDate | None:\n        \"\"\"Get the report sent date\n\n        It has fallback to the review date and last date of the pentest ongoing.\n        \"\"\"\n        if (report_sent := self.filter_dates(type=DateType.report_sent, last_date=True)) is not None:\n            return report_sent\n        else:\n            return self.filter_dates(type=[DateType.review, DateType.pentest_ongoing], last_date=True)\n\n    @property\n    def total_open_risks(self) -&gt; NonNegativeInt:\n        \"\"\"Get the total number of open risks across all risk levels.\"\"\"\n        return sum(t.findings.risks.sum_open for t in self.targets)\n\n    @property\n    def sum_risks(self) -&gt; Risks:\n        \"\"\"Get the sum of risks across all targets.\"\"\"\n        if not self.targets:\n            return Risks()\n        return reduce(operator.add, (t.findings.risks for t in self.targets))\n\n    @property\n    def report_name(self) -&gt; str:\n        \"\"\"Get the report file name based on the project ID and version.\"\"\"\n        version = f\" {self.version}\" if self.version &gt; ProjectVersion.from_str(\"v1.0\") else \"\"\n        return f\"{self.id} - Report{version}.pdf\"\n\n    @property\n    def sow_name(self) -&gt; str:\n        \"\"\"Get the SoW file name based on the project ID and version.\"\"\"\n        version = f\" {self.version}\" if self.version &gt; ProjectVersion.from_str(\"v1.0\") else \"\"\n        return f\"{self.id} - Statement of Work{version}.pdf\"\n</code></pre>"},{"location":"reference/config/#sereto.config.VersionConfig.report_name","title":"<code>report_name</code>  <code>property</code>","text":"<p>Get the report file name based on the project ID and version.</p>"},{"location":"reference/config/#sereto.config.VersionConfig.report_sent_date","title":"<code>report_sent_date</code>  <code>property</code>","text":"<p>Get the report sent date</p> <p>It has fallback to the review date and last date of the pentest ongoing.</p>"},{"location":"reference/config/#sereto.config.VersionConfig.sow_name","title":"<code>sow_name</code>  <code>property</code>","text":"<p>Get the SoW file name based on the project ID and version.</p>"},{"location":"reference/config/#sereto.config.VersionConfig.sum_risks","title":"<code>sum_risks</code>  <code>property</code>","text":"<p>Get the sum of risks across all targets.</p>"},{"location":"reference/config/#sereto.config.VersionConfig.total_open_risks","title":"<code>total_open_risks</code>  <code>property</code>","text":"<p>Get the total number of open risks across all risk levels.</p>"},{"location":"reference/config/#sereto.config.VersionConfig.add_date","title":"<code>add_date(date)</code>","text":"<p>Add a date to the configuration.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>Date</code> <p>The date to add.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The configuration with the added date.</p> Source code in <code>sereto/config.py</code> <pre><code>@validate_call\ndef add_date(self, date: Date) -&gt; Self:\n    \"\"\"Add a date to the configuration.\n\n    Args:\n        date: The date to add.\n\n    Returns:\n        The configuration with the added date.\n    \"\"\"\n    self.dates.append(date)\n    return self\n</code></pre>"},{"location":"reference/config/#sereto.config.VersionConfig.add_person","title":"<code>add_person(person)</code>","text":"<p>Add a person to the configuration.</p> <p>Parameters:</p> Name Type Description Default <code>person</code> <code>Person</code> <p>The person to add.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The configuration with the added person.</p> Source code in <code>sereto/config.py</code> <pre><code>@validate_call\ndef add_person(self, person: Person) -&gt; Self:\n    \"\"\"Add a person to the configuration.\n\n    Args:\n        person: The person to add.\n\n    Returns:\n        The configuration with the added person.\n    \"\"\"\n    self.people.append(person)\n    return self\n</code></pre>"},{"location":"reference/config/#sereto.config.VersionConfig.add_target","title":"<code>add_target(target)</code>","text":"<p>Add a target to the configuration.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Target</code> <p>The target to add.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The configuration with the added target.</p> Source code in <code>sereto/config.py</code> <pre><code>@validate_call\ndef add_target(self, target: Target) -&gt; Self:\n    \"\"\"Add a target to the configuration.\n\n    Args:\n        target: The target to add.\n\n    Returns:\n        The configuration with the added target.\n    \"\"\"\n    self.targets.append(target)\n    return self\n</code></pre>"},{"location":"reference/config/#sereto.config.VersionConfig.delete_date","title":"<code>delete_date(index)</code>","text":"<p>Delete a date from the configuration.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the date to delete. First item is 1.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The configuration with the date deleted.</p> Source code in <code>sereto/config.py</code> <pre><code>@validate_call\ndef delete_date(self, index: int) -&gt; Self:\n    \"\"\"Delete a date from the configuration.\n\n    Args:\n        index: The index of the date to delete. First item is 1.\n\n    Returns:\n        The configuration with the date deleted.\n    \"\"\"\n    # Convert to 0-based index\n    index -= 1\n\n    # Check if the index is in the allowed range\n    if not 0 &lt;= index &lt;= len(self.dates) - 1:\n        raise SeretoValueError(\"index out of range\")\n\n    # Delete the date\n    del self.dates[index]\n\n    return self\n</code></pre>"},{"location":"reference/config/#sereto.config.VersionConfig.delete_person","title":"<code>delete_person(index)</code>","text":"<p>Delete a person from the configuration.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the person to delete. First item is 1.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The configuration with the person deleted.</p> Source code in <code>sereto/config.py</code> <pre><code>@validate_call\ndef delete_person(self, index: int) -&gt; Self:\n    \"\"\"Delete a person from the configuration.\n\n    Args:\n        index: The index of the person to delete. First item is 1.\n\n    Returns:\n        The configuration with the person deleted.\n    \"\"\"\n    # Convert to 0-based index\n    index -= 1\n\n    # Check if the index is in the allowed range\n    if not 0 &lt;= index &lt;= len(self.people) - 1:\n        raise SeretoValueError(\"index out of range\")\n\n    # Delete the person\n    del self.people[index]\n\n    return self\n</code></pre>"},{"location":"reference/config/#sereto.config.VersionConfig.delete_target","title":"<code>delete_target(index)</code>","text":"<p>Delete a target from the configuration.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the target to delete. First item is 1.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The configuration with the target deleted.</p> Source code in <code>sereto/config.py</code> <pre><code>@validate_call\ndef delete_target(self, index: int) -&gt; Self:\n    \"\"\"Delete a target from the configuration.\n\n    Args:\n        index: The index of the target to delete. First item is 1.\n\n    Returns:\n        The configuration with the target deleted.\n    \"\"\"\n    # Convert to 0-based index\n    index -= 1\n\n    # Check if the index is in the allowed range\n    if not 0 &lt;= index &lt;= len(self.targets) - 1:\n        raise SeretoValueError(\"index out of range\")\n\n    # Delete the target\n    del self.targets[index]\n\n    return self\n</code></pre>"},{"location":"reference/config/#sereto.config.VersionConfig.due_date_for","title":"<code>due_date_for(risk)</code>","text":"<p>Get the due date for a specific risk level.</p> Source code in <code>sereto/config.py</code> <pre><code>def due_date_for(self, risk: Risk) -&gt; SeretoDate | None:\n    \"\"\"Get the due date for a specific risk level.\"\"\"\n    if risk not in self.risk_due_dates:\n        return None\n\n    report_sent_date = self.filter_dates(\n        type=[DateType.report_sent, DateType.review, DateType.pentest_ongoing], last_date=True\n    )\n    if report_sent_date is None:\n        return None\n\n    # Calculate the due date by adding the risk's due timedelta to the report sent date\n    return report_sent_date + self.risk_due_dates[risk]\n</code></pre>"},{"location":"reference/config/#sereto.config.VersionConfig.filter_dates","title":"<code>filter_dates(type=None, start=None, end=None, *, first_date=False, last_date=False, inverse=False)</code>","text":"<pre><code>filter_dates(type: str | DateType | Iterable[str] | Iterable[DateType] | None = ..., start: str | SeretoDate | None = ..., end: str | SeretoDate | None = ..., *, first_date: Literal[True], last_date: Literal[False] = False, inverse: bool = False) -&gt; SeretoDate | None\n</code></pre><pre><code>filter_dates(type: str | DateType | Iterable[str] | Iterable[DateType] | None = ..., start: str | SeretoDate | None = ..., end: str | SeretoDate | None = ..., *, first_date: Literal[False] = False, last_date: Literal[True], inverse: bool = False) -&gt; SeretoDate | None\n</code></pre><pre><code>filter_dates(type: str | DateType | Iterable[str] | Iterable[DateType] | None = ..., start: str | SeretoDate | None = ..., end: str | SeretoDate | None = ..., *, first_date: Literal[False], last_date: Literal[False], inverse: bool = False) -&gt; list[Date]\n</code></pre> <p>Filter dates based on specified criteria.</p> <p>The start and end dates are inclusive. For date ranges, a date is considered matching if it completely overlaps with the specified range.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str | DateType | Iterable[str] | Iterable[DateType] | None</code> <p>The type of the date. Can be <code>DateType</code>, a list of <code>DateType</code>s, or None.</p> <code>None</code> <code>start</code> <code>str | SeretoDate | None</code> <p>Only dates on or after this date will be included.</p> <code>None</code> <code>end</code> <code>str | SeretoDate | None</code> <p>Only dates on or before this date will be included.</p> <code>None</code> <code>first_date</code> <code>bool</code> <p>If True, return the earliest date matching the criteria. Even for date ranges, only the start date  is considered. The type returned is <code>SeretoDate</code> or None.</p> <code>False</code> <code>last_date</code> <code>bool</code> <p>If True, return the latest date matching the criteria. Even for date ranges, only the end date is considered. The type returned is <code>SeretoDate</code> or None.</p> <code>False</code> <code>inverse</code> <code>bool</code> <p>If True, return the inverse of the usual results.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[Date] | SeretoDate | None</code> <p>For first_date or last_date = True, returns SeretoDate or None. Otherwise, returns a list[Date].</p> Source code in <code>sereto/config.py</code> <pre><code>def filter_dates(\n    self,\n    type: str | DateType | Iterable[str] | Iterable[DateType] | None = None,\n    start: str | SeretoDate | None = None,\n    end: str | SeretoDate | None = None,\n    *,\n    first_date: bool = False,\n    last_date: bool = False,\n    inverse: bool = False,\n) -&gt; list[Date] | SeretoDate | None:\n    \"\"\"Filter dates based on specified criteria.\n\n    The start and end dates are inclusive. For date ranges, a date is considered matching if it completely overlaps\n    with the specified range.\n\n    Args:\n        type: The type of the date. Can be `DateType`, a list of `DateType`s, or None.\n        start: Only dates on or after this date will be included.\n        end: Only dates on or before this date will be included.\n        first_date: If True, return the earliest date matching the criteria. Even for date ranges, only the start\n            date  is considered. The type returned is `SeretoDate` or None.\n        last_date: If True, return the latest date matching the criteria. Even for date ranges, only the end date\n            is considered. The type returned is `SeretoDate` or None.\n        inverse: If True, return the inverse of the usual results.\n\n    Returns:\n        For first_date or last_date = True, returns SeretoDate or None. Otherwise, returns a list[Date].\n    \"\"\"\n    # Check for invalid parameter combinations\n    if first_date and last_date:\n        raise SeretoValueError(\"cannot specify both first_date and last_date\")\n    if (first_date or last_date) and inverse:\n        raise SeretoValueError(\"cannot specify inverse with first_date or last_date\")\n\n    match type:\n        case str():\n            type = [DateType(type)]\n        case Iterable():\n            type = [DateType(t) for t in type]\n        case None:\n            pass\n\n    if isinstance(start, str):\n        start = SeretoDate.from_str(start)\n    if isinstance(end, str):\n        end = SeretoDate.from_str(end)\n\n    filtered_dates = [\n        d\n        for d in self.dates\n        if (type is None or d.type in type)\n        and (\n            start is None\n            or (isinstance(d.date, SeretoDate) and d.date &gt;= start)\n            or (isinstance(d.date, DateRange) and d.date.start &gt;= start)\n        )\n        and (\n            end is None\n            or (isinstance(d.date, SeretoDate) and d.date &lt;= end)\n            or (isinstance(d.date, DateRange) and d.date.end &lt;= end)\n        )\n    ]\n\n    if first_date:\n        single_dates = [d.date.start if isinstance(d.date, DateRange) else d.date for d in filtered_dates]\n        return min(single_dates, default=None)\n\n    if last_date:\n        single_dates = [d.date.end if isinstance(d.date, DateRange) else d.date for d in filtered_dates]\n        return max(single_dates, default=None)\n\n    if inverse:\n        return [d for d in self.dates if d not in filtered_dates]\n    return filtered_dates\n</code></pre>"},{"location":"reference/config/#sereto.config.VersionConfig.filter_people","title":"<code>filter_people(type=None, name=None, business_unit=None, email=None, role=None, inverse=False)</code>","text":"<p>Filter people based on specified criteria.</p> <p>The regular expressions support the syntax of Python's <code>re</code> module.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str | PersonType | Iterable[str] | Iterable[PersonType] | None</code> <p>The type of the person. Can be a single type, a list of types, or None.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Regular expression to match the name of the person.</p> <code>None</code> <code>business_unit</code> <code>str | None</code> <p>Regular expression to match the business unit of the person.</p> <code>None</code> <code>email</code> <code>str | None</code> <p>Regular expression to match the email of the person.</p> <code>None</code> <code>role</code> <code>str | None</code> <p>Regular expression to match the role of the person.</p> <code>None</code> <code>inverse</code> <code>bool</code> <p>If True, return the inverse of the usual results.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[Person]</code> <p>A list of people matching the criteria.</p> Source code in <code>sereto/config.py</code> <pre><code>@validate_call\ndef filter_people(\n    self,\n    type: str | PersonType | Iterable[str] | Iterable[PersonType] | None = None,\n    name: str | None = None,\n    business_unit: str | None = None,\n    email: str | None = None,\n    role: str | None = None,\n    inverse: bool = False,\n) -&gt; list[Person]:\n    \"\"\"Filter people based on specified criteria.\n\n    The regular expressions support the syntax of Python's `re` module.\n\n    Args:\n        type: The type of the person. Can be a single type, a list of types, or None.\n        name: Regular expression to match the name of the person.\n        business_unit: Regular expression to match the business unit of the person.\n        email: Regular expression to match the email of the person.\n        role: Regular expression to match the role of the person.\n        inverse: If True, return the inverse of the usual results.\n\n    Returns:\n        A list of people matching the criteria.\n    \"\"\"\n    match type:\n        case str():\n            type = [PersonType(type)]\n        case Iterable():\n            type = [PersonType(t) for t in type]\n        case None:\n            pass\n\n    filtered_people = [\n        p\n        for p in self.people\n        if (type is None or p.type in type)\n        and (name is None or (p.name is not None and re.search(name, p.name)))\n        and (business_unit is None or (p.business_unit is not None and re.search(business_unit, p.business_unit)))\n        and (email is None or (p.email is not None and re.search(email, p.email)))\n        and (role is None or (p.role is not None and re.search(role, p.role)))\n    ]\n\n    if inverse:\n        return [p for p in self.people if p not in filtered_people]\n    return filtered_people\n</code></pre>"},{"location":"reference/config/#sereto.config.VersionConfig.filter_targets","title":"<code>filter_targets(category=None, name=None, inverse=False)</code>","text":"<p>Filter targets based on specified criteria.</p> <p>The regular expressions support the syntax of Python's <code>re</code> module.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str | Iterable[str] | None</code> <p>The category of the target. Can be a single category, a list of categories, or None.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Regular expression to match the name of the target.</p> <code>None</code> <code>inverse</code> <code>bool</code> <p>If True, return the inverse of the usual results.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[Target]</code> <p>A list of targets matching the criteria.</p> Source code in <code>sereto/config.py</code> <pre><code>@validate_call\ndef filter_targets(\n    self,\n    category: str | Iterable[str] | None = None,\n    name: str | None = None,\n    inverse: bool = False,\n) -&gt; list[Target]:\n    \"\"\"Filter targets based on specified criteria.\n\n    The regular expressions support the syntax of Python's `re` module.\n\n    Args:\n        category: The category of the target. Can be a single category, a list of categories, or None.\n        name: Regular expression to match the name of the target.\n        inverse: If True, return the inverse of the usual results.\n\n    Returns:\n        A list of targets matching the criteria.\n    \"\"\"\n    # Prepare categories for filtering\n    match category:\n        case str():\n            categories: list[str] | None = [category]\n        case Iterable():\n            categories = list(category)\n        case None:\n            categories = None\n\n    filtered_targets = [\n        t\n        for t in self.targets\n        if (categories is None or t.data.category in categories) and (name is None or re.search(name, t.data.name))\n    ]\n\n    if inverse:\n        return [t for t in self.targets if t not in filtered_targets]\n    return filtered_targets\n</code></pre>"},{"location":"reference/convert/","title":"Convert","text":""},{"location":"reference/convert/#sereto.convert","title":"<code>sereto.convert</code>","text":""},{"location":"reference/crypto/","title":"Crypto","text":""},{"location":"reference/crypto/#sereto.crypto","title":"<code>sereto.crypto</code>","text":""},{"location":"reference/crypto/#sereto.crypto.DerivedKeyResult","title":"<code>DerivedKeyResult</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Result of the Argon2 key derivation function.</p> Source code in <code>sereto/crypto.py</code> <pre><code>class DerivedKeyResult(NamedTuple):\n    \"\"\"Result of the Argon2 key derivation function.\"\"\"\n\n    key: SecretBytes\n    salt: TypeSalt16B\n</code></pre>"},{"location":"reference/crypto/#sereto.crypto.decrypt_file","title":"<code>decrypt_file(file, keep_original=True)</code>","text":"<p>Decrypts a .sereto file using AES-GCM encryption and saves it with a .tgz suffix.</p> <p>This function retrieves a password from the system keyring, derives an encryption key using Argon2, parses the header (contains nonce and seed), and decrypts the file content. The decrypted data is then saved with a .tgz suffix and the original file is deleted (use <code>keep_original=True</code> to overwrite deletion).</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>FilePath</code> <p>The path to the encrypted .sereto file.</p> required <code>keep_original</code> <code>bool</code> <p>If True, the original encrypted file is kept. Defaults to False.</p> <code>True</code> <p>Raises:</p> Type Description <code>Abort</code> <p>If the file size exceeds 1 GiB and the user chooses not to continue.</p> <code>SeretoValueError</code> <p>If the file is corrupted or not encrypted with SeReTo.</p> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the decrypted file.</p> Source code in <code>sereto/crypto.py</code> <pre><code>@validate_call\ndef decrypt_file(file: FilePath, keep_original: bool = True) -&gt; Path:\n    \"\"\"Decrypts a .sereto file using AES-GCM encryption and saves it with a .tgz suffix.\n\n    This function retrieves a password from the system keyring, derives an encryption key using Argon2, parses the\n    header (contains nonce and seed), and decrypts the file content. The decrypted data is then saved with a .tgz\n    suffix and the original file is deleted (use `keep_original=True` to overwrite deletion).\n\n    Args:\n        file: The path to the encrypted .sereto file.\n        keep_original: If True, the original encrypted file is kept. Defaults to False.\n\n    Raises:\n        click.Abort: If the file size exceeds 1 GiB and the user chooses not to continue.\n        SeretoValueError: If the file is corrupted or not encrypted with SeReTo.\n\n    Returns:\n        Path to the decrypted file.\n    \"\"\"\n    if not file.is_file():\n        raise SeretoPathError(f\"File '{file}' does not exist\")\n\n    if file.suffix != \".sereto\":\n        raise SeretoValueError(\"Unsupported file format for decryption (not a .sereto)\")\n\n    # Retrieve the password from the system keyring\n    try:\n        ta_password: TypeAdapter[TypePassword] = TypeAdapter(TypePassword)  # hack for mypy\n        password = ta_password.validate_python(get_password(\"sereto\", \"encrypt_attached_archive\"))\n    except ValidationError as e:\n        logger.warning(\"Invalid password for archive encryption: {}\", e.errors()[0][\"msg\"])\n        raise SeretoEncryptionError(f\"encryption password is invalid: {e.errors()[0]['msg']}\") from e\n\n    logger.success(\":locked: Found password for archive decryption. Decrypting archive...\", markup=True)\n\n    assert_file_size_within_range(file=file, min_bytes=65, max_bytes=1_073_741_824, interactive=True)\n\n    # Read the encrypted archive content\n    data = file.read_bytes()\n\n    # Extract the header\n    if not data[:6] == b\"SeReTo\":\n        raise SeretoValueError(\"Encrypted file is corrupted or not encrypted with SeReTo\")\n\n    # - nonce\n    ta_nonce: TypeAdapter[TypeNonce12B] = TypeAdapter(TypeNonce12B)  # hack for mypy\n    nonce = ta_nonce.validate_python(data[6:18])\n\n    # - salt\n    ta_salt: TypeAdapter[TypeSalt16B] = TypeAdapter(TypeSalt16B)  # hack for mypy\n    salt = ta_salt.validate_python(data[18:34])\n\n    # - encrypted data\n    encrypted_data = data[64:]\n\n    # Derive the key using Argon2id\n    derived = derive_key_argon2(password=password, salt=salt)\n\n    # Decrypt the data\n    decrypted_data = AESGCM(derived.key.get_secret_value()).decrypt(\n        nonce=nonce.get_secret_value(), data=encrypted_data, associated_data=None\n    )\n\n    # Write the decrypted data\n    with NamedTemporaryFile(suffix=\".tgz\", delete=False) as tmp:\n        (output := Path(tmp.name)).write_bytes(decrypted_data)\n\n    logger.info(\"Decrypted archive to '{}'\", output)\n\n    if not keep_original:\n        file.unlink()\n        logger.debug(\"Deleted encrypted archive: '{}'\", file)\n\n    return output\n</code></pre>"},{"location":"reference/crypto/#sereto.crypto.derive_key_argon2","title":"<code>derive_key_argon2(password, salt=None, memory_cost=1048576, time_cost=4, parallelism=8)</code>","text":"<p>Derive a key using Argon2id from a password.</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>TypePassword</code> <p>Password to derive the key from.</p> required <code>salt</code> <code>TypeSalt16B | None</code> <p>16 bytes long salt. If None, a random salt is generated.</p> <code>None</code> <code>memory_cost</code> <code>int</code> <p>Memory cost in KiB. Defaults to 1 GiB.</p> <code>1048576</code> <code>time_cost</code> <code>int</code> <p>Time cost (number of iterations). Defaults to 4.</p> <code>4</code> <code>parallelism</code> <code>int</code> <p>Parallelism factor. Defaults to 8.</p> <code>8</code> <p>Returns:</p> Type Description <code>DerivedKeyResult</code> <p>Derived key and salt.</p> Source code in <code>sereto/crypto.py</code> <pre><code>@validate_call\ndef derive_key_argon2(\n    password: TypePassword,\n    salt: TypeSalt16B | None = None,\n    memory_cost: int = 1_048_576,\n    time_cost: int = 4,\n    parallelism: int = 8,\n) -&gt; DerivedKeyResult:\n    \"\"\"Derive a key using Argon2id from a password.\n\n    Args:\n        password: Password to derive the key from.\n        salt: 16 bytes long salt. If None, a random salt is generated.\n        memory_cost: Memory cost in KiB. Defaults to 1 GiB.\n        time_cost: Time cost (number of iterations). Defaults to 4.\n        parallelism: Parallelism factor. Defaults to 8.\n\n    Returns:\n        Derived key and salt.\n    \"\"\"\n    # Generate a salt if not provided (16 bytes)\n    if salt is None:\n        ta_salt: TypeAdapter[TypeSalt16B] = TypeAdapter(TypeSalt16B)  # hack for mypy\n        salt = ta_salt.validate_python(os.urandom(16))\n\n    # Prepare the Argon2id key derivation function\n    kdf = Argon2id(\n        salt=salt.get_secret_value(),\n        length=32,  # Desired key length in bytes (32 bytes = 256 bits for AES-256)\n        iterations=time_cost,\n        lanes=parallelism,\n        memory_cost=memory_cost,\n    )\n\n    # Derive a key using Argon2id\n    ta_key: TypeAdapter[SecretBytes] = TypeAdapter(SecretBytes)  # hack for mypy\n    key = ta_key.validate_python(kdf.derive(password.get_secret_value().encode(encoding=\"utf-8\")))\n\n    return DerivedKeyResult(key=key, salt=salt)\n</code></pre>"},{"location":"reference/crypto/#sereto.crypto.encrypt_file","title":"<code>encrypt_file(file, keep_original=False)</code>","text":"<p>Encrypts a given file using AES-GCM encryption and saves it with a .sereto suffix.</p> <p>This function retrieves a password from the system keyring, derives an encryption key using Argon2, and encrypts the file content. The encrypted data is then saved with a specific header and the original file is deleted (use <code>keep_original=True</code> to overwrite deletion).</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>FilePath</code> <p>The path to the file to be encrypted.</p> required <code>keep_original</code> <code>bool</code> <p>If True, the original encrypted file is kept. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the encrypted file with suffix <code>.sereto</code>.</p> <p>Raises:</p> Type Description <code>SeretoEncryptionError</code> <p>If the password is not found in the system keyring.</p> <code>SeretoPathError</code> <p>If the provided file does not exist.</p> <code>SeretoValueError</code> <p>If the file size exceeds 1 GiB and the user chooses not to continue.</p> Source code in <code>sereto/crypto.py</code> <pre><code>@validate_call\ndef encrypt_file(file: FilePath, keep_original: bool = False) -&gt; Path:\n    \"\"\"Encrypts a given file using AES-GCM encryption and saves it with a .sereto suffix.\n\n    This function retrieves a password from the system keyring, derives an encryption key using Argon2, and encrypts\n    the file content. The encrypted data is then saved with a specific header and the original file is deleted (use\n    `keep_original=True` to overwrite deletion).\n\n    Args:\n        file: The path to the file to be encrypted.\n        keep_original: If True, the original encrypted file is kept. Defaults to False.\n\n    Returns:\n        Path to the encrypted file with suffix `.sereto`.\n\n    Raises:\n        SeretoEncryptionError: If the password is not found in the system keyring.\n        SeretoPathError: If the provided file does not exist.\n        SeretoValueError: If the file size exceeds 1 GiB and the user chooses not to continue.\n    \"\"\"\n    if not file.is_file():\n        raise SeretoPathError(f\"file '{file}' does not exist\")\n\n    # Retrieve the password from the system keyring\n    try:\n        ta_password: TypeAdapter[TypePassword] = TypeAdapter(TypePassword)  # hack for mypy\n        password = ta_password.validate_python(get_password(\"sereto\", \"encrypt_attached_archive\"))\n    except ValidationError as e:\n        logger.warning(\"Invalid password for archive encryption: {}\", e.errors()[0][\"msg\"])\n        raise SeretoEncryptionError(f\"encryption password is invalid: {e.errors()[0]['msg']}\") from e\n\n    assert_file_size_within_range(file=file, max_bytes=1_073_741_824, interactive=True)\n\n    logger.info(\":locked: Found password for archive encryption. Encrypting archive...\", markup=True)\n\n    # Read the file content\n    data = file.read_bytes()\n\n    # Derive the key using Argon2id\n    derived = derive_key_argon2(password=password)\n\n    # Generate a 12-byte random nonce - IV for AES\n    # - NIST recommends a 96-bit IV length for best performance - https://csrc.nist.gov/pubs/sp/800/38/d/final\n    ta_nonce: TypeAdapter[TypeNonce12B] = TypeAdapter(TypeNonce12B)  # hack for mypy\n    nonce = ta_nonce.validate_python(os.urandom(12))\n\n    # Encrypt the data\n    encrypted_data = AESGCM(derived.key.get_secret_value()).encrypt(\n        nonce=nonce.get_secret_value(), data=data, associated_data=None\n    )\n\n    # Prepare the header (64 bytes long)\n    header = b\"SeReTo\" + nonce.get_secret_value() + derived.salt.get_secret_value()\n    header = header.ljust(64, b\"\\x00\")\n\n    # Write the encrypted data into a new file\n    with NamedTemporaryFile(suffix=\".sereto\", delete=False) as tmp:\n        (encrypted_path := Path(tmp.name)).write_bytes(header + encrypted_data)\n\n    # Delete the original file if `keep_file=False`\n    if not keep_original:\n        file.unlink()\n\n    logger.success(\"Archive successfully encrypted\")\n\n    # Return the path to the encrypted file\n    return encrypted_path\n</code></pre>"},{"location":"reference/enums/","title":"Enums","text":""},{"location":"reference/enums/#sereto.enums","title":"<code>sereto.enums</code>","text":""},{"location":"reference/enums/#sereto.enums.Environment","title":"<code>Environment</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum representing the environment of a Target.</p> Source code in <code>sereto/enums.py</code> <pre><code>class Environment(StrEnum):\n    \"\"\"Enum representing the environment of a Target.\"\"\"\n\n    acceptance = \"acceptance\"\n    development = \"development\"\n    production = \"production\"\n    testing = \"testing\"\n</code></pre>"},{"location":"reference/enums/#sereto.enums.FileFormat","title":"<code>FileFormat</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum representing the file format.</p> <p>Attributes:</p> Name Type Description <code>md</code> <p>Markdown file format ('.md')</p> <code>tex</code> <p>TeX file format ('.tex')</p> <code>typ</code> <p>Typst file format ('.typ')</p> Source code in <code>sereto/enums.py</code> <pre><code>class FileFormat(StrEnum):\n    \"\"\"Enum representing the file format.\n\n    Attributes:\n        md: Markdown file format ('.md')\n        tex: TeX file format ('.tex')\n        typ: Typst file format ('.typ')\n    \"\"\"\n\n    md = \"md\"\n    tex = \"tex\"\n    typ = \"typ\"\n</code></pre>"},{"location":"reference/enums/#sereto.enums.OutputFormat","title":"<code>OutputFormat</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum representing the output format.</p> Source code in <code>sereto/enums.py</code> <pre><code>class OutputFormat(StrEnum):\n    \"\"\"Enum representing the output format.\"\"\"\n\n    table = \"table\"\n    json = \"json\"\n</code></pre>"},{"location":"reference/enums/#sereto.enums.Risk","title":"<code>Risk</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum representing the risk level of a finding.</p> Source code in <code>sereto/enums.py</code> <pre><code>class Risk(StrEnum):\n    \"\"\"Enum representing the risk level of a finding.\"\"\"\n\n    critical = \"critical\"\n    high = \"high\"\n    medium = \"medium\"\n    low = \"low\"\n    info = \"info\"\n    closed = \"closed\"\n\n    def to_int(self) -&gt; int:\n        \"\"\"Convert risks to a number.\n\n        Usefull for comparison - e.g. `max(risks, key=lambda r: r.to_int())`\n        \"\"\"\n        match self:\n            case Risk.closed:\n                return 0\n            case Risk.info:\n                return 1\n            case Risk.low:\n                return 2\n            case Risk.medium:\n                return 3\n            case Risk.high:\n                return 4\n            case Risk.critical:\n                return 5\n            case _:\n                raise SeretoValueError(\"unexpected risk value\")\n</code></pre>"},{"location":"reference/enums/#sereto.enums.Risk.to_int","title":"<code>to_int()</code>","text":"<p>Convert risks to a number.</p> <p>Usefull for comparison - e.g. <code>max(risks, key=lambda r: r.to_int())</code></p> Source code in <code>sereto/enums.py</code> <pre><code>def to_int(self) -&gt; int:\n    \"\"\"Convert risks to a number.\n\n    Usefull for comparison - e.g. `max(risks, key=lambda r: r.to_int())`\n    \"\"\"\n    match self:\n        case Risk.closed:\n            return 0\n        case Risk.info:\n            return 1\n        case Risk.low:\n            return 2\n        case Risk.medium:\n            return 3\n        case Risk.high:\n            return 4\n        case Risk.critical:\n            return 5\n        case _:\n            raise SeretoValueError(\"unexpected risk value\")\n</code></pre>"},{"location":"reference/exceptions/","title":"Exceptions","text":""},{"location":"reference/exceptions/#sereto.exceptions","title":"<code>sereto.exceptions</code>","text":""},{"location":"reference/exceptions/#sereto.exceptions.SeretoCalledProcessError","title":"<code>SeretoCalledProcessError</code>","text":"<p>               Bases: <code>SeretoException</code></p> <p>Called process error.</p> Source code in <code>sereto/exceptions.py</code> <pre><code>class SeretoCalledProcessError(SeretoException):\n    \"\"\"Called process error.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#sereto.exceptions.SeretoEncryptionError","title":"<code>SeretoEncryptionError</code>","text":"<p>               Bases: <code>SeretoException</code></p> <p>Encryption error.</p> Source code in <code>sereto/exceptions.py</code> <pre><code>class SeretoEncryptionError(SeretoException):\n    \"\"\"Encryption error.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#sereto.exceptions.SeretoException","title":"<code>SeretoException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>There was an ambiguous exception.</p> Source code in <code>sereto/exceptions.py</code> <pre><code>class SeretoException(Exception):\n    \"\"\"There was an ambiguous exception.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#sereto.exceptions.SeretoPathError","title":"<code>SeretoPathError</code>","text":"<p>               Bases: <code>SeretoException</code></p> <p>Path error.</p> Source code in <code>sereto/exceptions.py</code> <pre><code>class SeretoPathError(SeretoException):\n    \"\"\"Path error.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#sereto.exceptions.SeretoRuntimeError","title":"<code>SeretoRuntimeError</code>","text":"<p>               Bases: <code>SeretoException</code></p> <p>Runtime error.</p> Source code in <code>sereto/exceptions.py</code> <pre><code>class SeretoRuntimeError(SeretoException):\n    \"\"\"Runtime error.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#sereto.exceptions.SeretoTypeError","title":"<code>SeretoTypeError</code>","text":"<p>               Bases: <code>SeretoException</code></p> <p>Type error.</p> Source code in <code>sereto/exceptions.py</code> <pre><code>class SeretoTypeError(SeretoException):\n    \"\"\"Type error.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#sereto.exceptions.SeretoValueError","title":"<code>SeretoValueError</code>","text":"<p>               Bases: <code>SeretoException</code>, <code>ValueError</code></p> <p>Value error.</p> Source code in <code>sereto/exceptions.py</code> <pre><code>class SeretoValueError(SeretoException, ValueError):\n    \"\"\"Value error.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#sereto.exceptions.handle_exceptions","title":"<code>handle_exceptions(func)</code>","text":"<p>Decorator for pretty printing SeReTo exceptions in debug mode</p> <p>If the exception is a subclass of SeretoException and DEBUG environment variable is set to '1', the full exception traceback will be printed with local variables shown.</p> Source code in <code>sereto/exceptions.py</code> <pre><code>def handle_exceptions[**P, R](func: Callable[P, R]) -&gt; Callable[P, R]:\n    \"\"\"Decorator for pretty printing SeReTo exceptions in debug mode\n\n    If the exception is a subclass of SeretoException and DEBUG environment variable is set to '1', the full exception\n    traceback will be printed with local variables shown.\n    \"\"\"\n\n    @functools.wraps(func)\n    def outer_function(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            if isinstance(e, SeretoException | ValidationError):\n                logger.error(str(e))\n            else:\n                logger.error(\"Unexpected error occurred\")\n\n            if os.environ.get(\"DEBUG\", \"0\") == \"1\":\n                logger.opt(exception=e).exception(\"Debug traceback\")\n            else:\n                logger.info(\"Set environment variable [blue]DEBUG=1[/] for more details.\", markup=True)\n            sys.exit(1)\n\n    return outer_function\n</code></pre>"},{"location":"reference/extract/","title":"Extract","text":""},{"location":"reference/extract/#sereto.extract","title":"<code>sereto.extract</code>","text":""},{"location":"reference/extract/#sereto.extract.extract_block_from_jinja","title":"<code>extract_block_from_jinja(content, name)</code>","text":"<p>Extracts the full content of a Jinja block by name, including the tags.</p> <p>Returns:</p> Type Description <code>tuple[str, int, int]</code> <p>The full block content, start index and end index.</p> Source code in <code>sereto/extract.py</code> <pre><code>def extract_block_from_jinja(content: str, name: str) -&gt; tuple[str, int, int]:\n    \"\"\"Extracts the full content of a Jinja block by name, including the tags.\n\n    Returns:\n        The full block content, start index and end index.\n    \"\"\"\n    pattern = re.compile(\n        r\"\"\"\n        \\{%-?\\s*block\\s+(\\w+)\\s*-?%\\}\n        (.*?)                            # content\n        \\{%-?\\s*endblock\\s*(\\w+)?\\s*-?%\\}\n    \"\"\",\n        re.DOTALL | re.VERBOSE,\n    )\n\n    match = pattern.search(content)\n    if match and match.group(1) == name:\n        return match.group(2), match.start(2), match.end(2)\n\n    return \"\", 0, 0\n</code></pre>"},{"location":"reference/extract/#sereto.extract.extract_blocks","title":"<code>extract_blocks(node_list)</code>","text":"<p>Extracts static text from a list of nodes inside a block.</p> Source code in <code>sereto/extract.py</code> <pre><code>def extract_blocks(node_list: list[Node]) -&gt; str:\n    \"\"\"Extracts static text from a list of nodes inside a block.\"\"\"\n    result = []\n    for node in node_list:\n        if isinstance(node, Output):\n            for subnode in node.nodes:\n                if isinstance(subnode, TemplateData):\n                    result.append(subnode.data)\n    return \" \".join(result).strip().replace(\"\\n\", \"\")\n</code></pre>"},{"location":"reference/extract/#sereto.extract.extract_text_from_jinja","title":"<code>extract_text_from_jinja(ast)</code>","text":"<p>Extracts static text content from all blocks in a Jinja2 template.</p> Source code in <code>sereto/extract.py</code> <pre><code>def extract_text_from_jinja(ast: Template) -&gt; dict[str, str]:\n    \"\"\"Extracts static text content from all blocks in a Jinja2 template.\"\"\"\n    blocks_text = {}\n\n    for node in ast.body:\n        if isinstance(node, Block):\n            block_name = node.name\n            block_text = extract_blocks(node.body)\n            if block_text:\n                blocks_text[block_name] = block_text\n    return blocks_text\n</code></pre>"},{"location":"reference/finding/","title":"Finding","text":""},{"location":"reference/finding/#sereto.finding","title":"<code>sereto.finding</code>","text":""},{"location":"reference/finding/#sereto.finding.FindingGroup","title":"<code>FindingGroup</code>  <code>dataclass</code>","text":"<p>Represents a finding group.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the finding group.</p> <code>explicit_risk</code> <code>Risk | None</code> <p>Risk to be used for the group. Overrides the calculated risks from sub-findings.</p> <code>sub_findings</code> <code>list[SubFinding]</code> <p>A list of sub-findings in the group.</p> <code>_target_locators</code> <code>list[LocatorModel]</code> <p>A list of locators used to find the target.</p> <code>_finding_group_locators</code> <code>list[LocatorModel]</code> <p>A list of locators defined on the finding group.</p> <code>_show_locator_types</code> <code>list[str]</code> <p>A list of locator types to return from the locators() property.</p> Source code in <code>sereto/finding.py</code> <pre><code>@dataclass\nclass FindingGroup:\n    \"\"\"Represents a finding group.\n\n    Attributes:\n        name: The name of the finding group.\n        explicit_risk: Risk to be used for the group. Overrides the calculated risks from sub-findings.\n        sub_findings: A list of sub-findings in the group.\n        _target_locators: A list of locators used to find the target.\n        _finding_group_locators: A list of locators defined on the finding group.\n        _show_locator_types: A list of locator types to return from the locators() property.\n    \"\"\"\n\n    name: str\n    explicit_risk: Risk | None\n    sub_findings: list[SubFinding]\n    _target_locators: list[LocatorModel]\n    _finding_group_locators: list[LocatorModel]\n    _show_locator_types: list[str]\n\n    @classmethod\n    @validate_call\n    def load(\n        cls,\n        name: str,\n        group_desc: FindingGroupModel,\n        findings_dir: DirectoryPath,\n        target_locators: list[LocatorModel],\n        templates: DirectoryPath,\n    ) -&gt; Self:\n        \"\"\"Load a finding group.\n\n        Args:\n            name: The name of the finding group.\n            group_desc: The description of the finding group.\n            findings_dir: The path to the findings directory.\n            target_locators: The locators used to find the target.\n            templates: The path to the templates directory.\n\n        Returns:\n            The loaded finding group object.\n        \"\"\"\n        sub_findings = [\n            SubFinding.load_from(path=findings_dir / f\"{name}.md.j2\", templates=templates)\n            for name in group_desc.findings\n        ]\n\n        return cls(\n            name=name,\n            explicit_risk=group_desc.risk,\n            sub_findings=sub_findings,\n            _target_locators=target_locators,\n            _finding_group_locators=group_desc.locators,\n            _show_locator_types=group_desc.show_locator_types,\n        )\n\n    def dumps_toml(self) -&gt; str:\n        \"\"\"Dump the finding group to a TOML string.\"\"\"\n        doc = tomlkit.document()\n        table = tomlkit.table()\n\n        if self.explicit_risk is not None:\n            table.add(\"risk\", self.explicit_risk.value)\n\n        # show_locator_types (force inline)\n        slt_array = tomlkit.array()\n        slt_array.extend(self._show_locator_types)\n        table.add(\"show_locator_types\", slt_array.multiline(False))\n\n        # findings (preserve order)\n        findings_array = tomlkit.array()\n        if len(self.sub_findings) &gt; 1:\n            findings_array.multiline(True)\n        for sf in self.sub_findings:\n            findings_array.append(sf.uname)\n        table.add(\"findings\", findings_array)\n\n        doc.add(self.name, table)\n        return tomlkit.dumps(doc).strip()\n\n    @property\n    def risk(self) -&gt; Risk:\n        \"\"\"Get the finding group risk.\n\n        Returns:\n            The explicit risk if set, otherwise the highest risk from the sub-findings.\n        \"\"\"\n        if self.explicit_risk is not None:\n            return self.explicit_risk\n        return max([sf.risk for sf in self.sub_findings], key=lambda r: r.to_int())\n\n    @property\n    def locators(self) -&gt; list[LocatorModel]:\n        \"\"\"Return a de-duplicated list of locators for the finding group.\n\n        Applies filtering from the `show_locator_types` attribute.\n\n        Precedence (first non-empty wins):\n        1. Explicit locators defined on the finding group\n        2. If every sub-finding has at least one locator, return the unique union of all\n           sub-finding locators (permitted types only)\n        3. If only some sub-findings define locators, merge their locators with the target\n           locators and return the unique union\n        4. Locators inherited from the target\n        \"\"\"\n\n        # 1. Explicit locators on the group\n        finding_group_locators = _filter_locators_by_type(self._finding_group_locators, self._show_locator_types)\n        if len(finding_group_locators) &gt; 0:\n            return _unique_locators(finding_group_locators)\n\n        has_sub_findings = len(self.sub_findings) &gt; 0\n        all_sub_have_locators = has_sub_findings and all(len(sf.locators) &gt; 0 for sf in self.sub_findings)\n        any_sub_has_locators = has_sub_findings and any(len(sf.locators) &gt; 0 for sf in self.sub_findings)\n\n        sub_finding_locators = _filter_locators_by_type(\n            (loc for sf in self.sub_findings for loc in sf.locators),\n            self._show_locator_types,\n        )\n        filtered_target_locators = _filter_locators_by_type(self._target_locators, self._show_locator_types)\n\n        # 2. All sub-findings define locators -&gt; report only their union\n        if all_sub_have_locators and len(sub_finding_locators) &gt; 0:\n            return _unique_locators(sub_finding_locators)\n\n        # 3. Mixed coverage -&gt; append target locators after sub-finding ones\n        if any_sub_has_locators and len(sub_finding_locators) &gt; 0:\n            return _unique_locators(sub_finding_locators + filtered_target_locators)\n\n        # 4. Fallback to target locators\n        return _unique_locators(filtered_target_locators)\n\n    @validate_call\n    def subfinding_locators(self, sub_finding: SubFinding) -&gt; list[LocatorModel]:\n        \"\"\"Return locators that add information beyond what the group already surfaces.\n\n        Resolution order:\n            1. Sub-finding locators when they introduce new locators.\n            2. Explicit group locators if they differ from the effective group view.\n            3. Fall back to target locators (already filtered by show_locator_types).\n\n        Returns:\n            A list of locators relevant for the given sub-finding, possibly empty.\n        \"\"\"\n        sub_locators = _unique_locators(_filter_locators_by_type(sub_finding.locators, self._show_locator_types))\n        group_locators = self.locators\n\n        # Group exposes nothing \u2192 pass through whatever the sub-finding provides.\n        if not group_locators:\n            return sub_locators\n\n        # Sub-finding adds no new locators.\n        if _locators_equal(sub_locators, group_locators):\n            return []\n\n        # Sub-finding introduces additional context \u2192 return it.\n        if sub_locators:\n            return sub_locators\n\n        # Sub-finding empty: check if explicit group locators differ from the derived view.\n        explicit_group_locators = _unique_locators(\n            _filter_locators_by_type(self._finding_group_locators, self._show_locator_types)\n        )\n        if _locators_equal(explicit_group_locators, group_locators):\n            return []\n\n        if explicit_group_locators:\n            return explicit_group_locators\n\n        # Nothing explicit either \u2192 fall back to filtered target locators.\n        return _filter_locators_by_type(self._target_locators, self._show_locator_types)\n\n    @property\n    def reported_on(self) -&gt; SeretoDate | None:\n        \"\"\"Get the reported_on date from sub-findings, if available.\n\n        Returns:\n            The reported_on date if any sub-finding has it set, otherwise None.\n        \"\"\"\n        reported_dates = [sf.reported_on for sf in self.sub_findings if sf.reported_on is not None]\n        return min(reported_dates) if len(reported_dates) &gt; 0 else None\n\n    @validate_call\n    def filter_locators(self, type: str | Iterable[str]) -&gt; list[LocatorModel]:\n        \"\"\"Filter locators by type.\n\n        Args:\n            type: The type of locators to filter by. Can be a single type or an iterable of types.\n\n        Returns:\n            A list of locators of the specified type.\n        \"\"\"\n        type = [type] if isinstance(type, str) else list(type)\n        return [loc for loc in self.locators if loc.type in type]\n\n    @property\n    @validate_call\n    def uname(self) -&gt; str:\n        \"\"\"Unique name of the finding group.\"\"\"\n        return lower_alphanum(f\"finding_group_{self.name}\")\n</code></pre>"},{"location":"reference/finding/#sereto.finding.FindingGroup.locators","title":"<code>locators</code>  <code>property</code>","text":"<p>Return a de-duplicated list of locators for the finding group.</p> <p>Applies filtering from the <code>show_locator_types</code> attribute.</p> <p>Precedence (first non-empty wins): 1. Explicit locators defined on the finding group 2. If every sub-finding has at least one locator, return the unique union of all    sub-finding locators (permitted types only) 3. If only some sub-findings define locators, merge their locators with the target    locators and return the unique union 4. Locators inherited from the target</p>"},{"location":"reference/finding/#sereto.finding.FindingGroup.reported_on","title":"<code>reported_on</code>  <code>property</code>","text":"<p>Get the reported_on date from sub-findings, if available.</p> <p>Returns:</p> Type Description <code>SeretoDate | None</code> <p>The reported_on date if any sub-finding has it set, otherwise None.</p>"},{"location":"reference/finding/#sereto.finding.FindingGroup.risk","title":"<code>risk</code>  <code>property</code>","text":"<p>Get the finding group risk.</p> <p>Returns:</p> Type Description <code>Risk</code> <p>The explicit risk if set, otherwise the highest risk from the sub-findings.</p>"},{"location":"reference/finding/#sereto.finding.FindingGroup.uname","title":"<code>uname</code>  <code>property</code>","text":"<p>Unique name of the finding group.</p>"},{"location":"reference/finding/#sereto.finding.FindingGroup.dumps_toml","title":"<code>dumps_toml()</code>","text":"<p>Dump the finding group to a TOML string.</p> Source code in <code>sereto/finding.py</code> <pre><code>def dumps_toml(self) -&gt; str:\n    \"\"\"Dump the finding group to a TOML string.\"\"\"\n    doc = tomlkit.document()\n    table = tomlkit.table()\n\n    if self.explicit_risk is not None:\n        table.add(\"risk\", self.explicit_risk.value)\n\n    # show_locator_types (force inline)\n    slt_array = tomlkit.array()\n    slt_array.extend(self._show_locator_types)\n    table.add(\"show_locator_types\", slt_array.multiline(False))\n\n    # findings (preserve order)\n    findings_array = tomlkit.array()\n    if len(self.sub_findings) &gt; 1:\n        findings_array.multiline(True)\n    for sf in self.sub_findings:\n        findings_array.append(sf.uname)\n    table.add(\"findings\", findings_array)\n\n    doc.add(self.name, table)\n    return tomlkit.dumps(doc).strip()\n</code></pre>"},{"location":"reference/finding/#sereto.finding.FindingGroup.filter_locators","title":"<code>filter_locators(type)</code>","text":"<p>Filter locators by type.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str | Iterable[str]</code> <p>The type of locators to filter by. Can be a single type or an iterable of types.</p> required <p>Returns:</p> Type Description <code>list[LocatorModel]</code> <p>A list of locators of the specified type.</p> Source code in <code>sereto/finding.py</code> <pre><code>@validate_call\ndef filter_locators(self, type: str | Iterable[str]) -&gt; list[LocatorModel]:\n    \"\"\"Filter locators by type.\n\n    Args:\n        type: The type of locators to filter by. Can be a single type or an iterable of types.\n\n    Returns:\n        A list of locators of the specified type.\n    \"\"\"\n    type = [type] if isinstance(type, str) else list(type)\n    return [loc for loc in self.locators if loc.type in type]\n</code></pre>"},{"location":"reference/finding/#sereto.finding.FindingGroup.load","title":"<code>load(name, group_desc, findings_dir, target_locators, templates)</code>  <code>classmethod</code>","text":"<p>Load a finding group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the finding group.</p> required <code>group_desc</code> <code>FindingGroupModel</code> <p>The description of the finding group.</p> required <code>findings_dir</code> <code>DirectoryPath</code> <p>The path to the findings directory.</p> required <code>target_locators</code> <code>list[LocatorModel]</code> <p>The locators used to find the target.</p> required <code>templates</code> <code>DirectoryPath</code> <p>The path to the templates directory.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The loaded finding group object.</p> Source code in <code>sereto/finding.py</code> <pre><code>@classmethod\n@validate_call\ndef load(\n    cls,\n    name: str,\n    group_desc: FindingGroupModel,\n    findings_dir: DirectoryPath,\n    target_locators: list[LocatorModel],\n    templates: DirectoryPath,\n) -&gt; Self:\n    \"\"\"Load a finding group.\n\n    Args:\n        name: The name of the finding group.\n        group_desc: The description of the finding group.\n        findings_dir: The path to the findings directory.\n        target_locators: The locators used to find the target.\n        templates: The path to the templates directory.\n\n    Returns:\n        The loaded finding group object.\n    \"\"\"\n    sub_findings = [\n        SubFinding.load_from(path=findings_dir / f\"{name}.md.j2\", templates=templates)\n        for name in group_desc.findings\n    ]\n\n    return cls(\n        name=name,\n        explicit_risk=group_desc.risk,\n        sub_findings=sub_findings,\n        _target_locators=target_locators,\n        _finding_group_locators=group_desc.locators,\n        _show_locator_types=group_desc.show_locator_types,\n    )\n</code></pre>"},{"location":"reference/finding/#sereto.finding.FindingGroup.subfinding_locators","title":"<code>subfinding_locators(sub_finding)</code>","text":"<p>Return locators that add information beyond what the group already surfaces.</p> Resolution order <ol> <li>Sub-finding locators when they introduce new locators.</li> <li>Explicit group locators if they differ from the effective group view.</li> <li>Fall back to target locators (already filtered by show_locator_types).</li> </ol> <p>Returns:</p> Type Description <code>list[LocatorModel]</code> <p>A list of locators relevant for the given sub-finding, possibly empty.</p> Source code in <code>sereto/finding.py</code> <pre><code>@validate_call\ndef subfinding_locators(self, sub_finding: SubFinding) -&gt; list[LocatorModel]:\n    \"\"\"Return locators that add information beyond what the group already surfaces.\n\n    Resolution order:\n        1. Sub-finding locators when they introduce new locators.\n        2. Explicit group locators if they differ from the effective group view.\n        3. Fall back to target locators (already filtered by show_locator_types).\n\n    Returns:\n        A list of locators relevant for the given sub-finding, possibly empty.\n    \"\"\"\n    sub_locators = _unique_locators(_filter_locators_by_type(sub_finding.locators, self._show_locator_types))\n    group_locators = self.locators\n\n    # Group exposes nothing \u2192 pass through whatever the sub-finding provides.\n    if not group_locators:\n        return sub_locators\n\n    # Sub-finding adds no new locators.\n    if _locators_equal(sub_locators, group_locators):\n        return []\n\n    # Sub-finding introduces additional context \u2192 return it.\n    if sub_locators:\n        return sub_locators\n\n    # Sub-finding empty: check if explicit group locators differ from the derived view.\n    explicit_group_locators = _unique_locators(\n        _filter_locators_by_type(self._finding_group_locators, self._show_locator_types)\n    )\n    if _locators_equal(explicit_group_locators, group_locators):\n        return []\n\n    if explicit_group_locators:\n        return explicit_group_locators\n\n    # Nothing explicit either \u2192 fall back to filtered target locators.\n    return _filter_locators_by_type(self._target_locators, self._show_locator_types)\n</code></pre>"},{"location":"reference/finding/#sereto.finding.Findings","title":"<code>Findings</code>  <code>dataclass</code>","text":"<p>Represents a collection of all finding groups inside a target.</p> <p>Attributes:</p> Name Type Description <code>groups</code> <code>list[FindingGroup]</code> <p>A list of finding groups.</p> <code>target_dir</code> <code>FilePath</code> <p>The path to the target directory containing the findings.</p> <code>target_locators</code> <code>list[LocatorModel]</code> <p>A list of locators used to find the target.</p> Source code in <code>sereto/finding.py</code> <pre><code>@dataclass\nclass Findings:\n    \"\"\"Represents a collection of all finding groups inside a target.\n\n    Attributes:\n        groups: A list of finding groups.\n        target_dir: The path to the target directory containing the findings.\n        target_locators: A list of locators used to find the target.\n    \"\"\"\n\n    groups: list[FindingGroup]\n    target_dir: FilePath\n    target_locators: list[LocatorModel]\n\n    @classmethod\n    @validate_call\n    def load_from(\n        cls, target_dir: DirectoryPath, target_locators: list[LocatorModel], templates: DirectoryPath\n    ) -&gt; Self:\n        \"\"\"Load findings belonging to the same target.\n\n        Args:\n            target_dir: The path to the target directory.\n            target_locators: The locators used to find the target.\n            templates: The path to the templates directory.\n\n        Returns:\n            The loaded findings object.\n        \"\"\"\n        config = FindingsConfigModel.load_from(target_dir / \"findings.toml\")\n\n        groups = [\n            FindingGroup.load(\n                name=name,\n                group_desc=group,\n                findings_dir=target_dir / \"findings\",\n                target_locators=target_locators,\n                templates=templates,\n            )\n            for name, group in config.items()\n        ]\n\n        # ensure group names are unique\n        unique_names = [g.uname for g in groups]\n        if len(unique_names) != len(set(unique_names)):\n            raise SeretoValueError(\"finding group unique names must be unique\")\n\n        return cls(groups=groups, target_dir=target_dir, target_locators=target_locators)\n\n    def get_path(self, category: str, name: str) -&gt; FilePath:\n        \"\"\"Get the path to a sub-finding by category and name.\n\n        Args:\n            category: The category of the sub-finding.\n            name: The name of the sub-finding.\n\n        Returns:\n            The path to the sub-finding file.\n        \"\"\"\n        return self.findings_dir / f\"{category.lower()}_{name}.md.j2\"\n\n    @validate_call\n    def add_from_template(\n        self,\n        templates: DirectoryPath,\n        template_path: FilePath,\n        category: str,\n        name: str | None = None,\n        risk: Risk | None = None,\n        variables: dict[str, Any] | None = None,\n        overwrite: bool = False,\n    ) -&gt; None:\n        \"\"\"Add a sub-finding from a template, creating a new finding group.\n\n        Args:\n            templates: Path to the templates directory.\n            template_path: Path to the sub-finding template.\n            category: Category of the sub-finding.\n            name: Name of the sub-finding group. Defaults to template name.\n            risk: Risk of the sub-finding. Defaults to template risk.\n            variables: Variables for the sub-finding template.\n            overwrite: If True, overwrite existing sub-finding; otherwise, create with random suffix.\n        \"\"\"\n        variables = variables or {}\n\n        # Load template metadata and content\n        template_metadata = FindingTemplateFrontmatterModel.load_from(template_path)\n        template_name = template_path.name.removesuffix(\".md.j2\")\n        _, content = frontmatter.parse(template_path.read_text(encoding=\"utf-8\"), encoding=\"utf-8\")\n\n        # Determine sub-finding path\n        sub_finding_path = self.get_path(category=category, name=template_name)\n        suffix = None\n\n        if sub_finding_path.is_file():\n            if overwrite:\n                sub_finding_path.unlink()\n            else:\n                # Try to generate a unique filename with random suffix\n                for _ in range(5):\n                    suffix = \"\".join(random.choices(string.ascii_lowercase + string.digits, k=5))\n                    sub_finding_path = self.get_path(category=category, name=f\"{template_name}_{suffix}\")\n                    if not sub_finding_path.is_file():\n                        break\n                else:\n                    raise SeretoPathError(\n                        f\"sub-finding already exists and could not generate a unique filename: {sub_finding_path}\"\n                    )\n\n        # Prepare sub-finding frontmatter\n        sub_finding_metadata = SubFindingFrontmatterModel(\n            name=template_metadata.name,\n            risk=template_metadata.risk,\n            category=category,\n            variables=variables,\n            template_path=str(template_path.relative_to(templates)),\n        )\n\n        # Write sub-finding file\n        sub_finding_path.write_text(f\"+++\\n{sub_finding_metadata.dumps_toml()}+++\\n\\n{content}\", encoding=\"utf-8\")\n\n        # If overwriting, nothing else to do\n        if overwrite:\n            return\n\n        # Load the created sub-finding\n        sub_finding = SubFinding.load_from(path=sub_finding_path, templates=templates)\n\n        # Determine group name\n        group_name = name or sub_finding.name\n        if suffix:\n            group_name = f\"{group_name} {suffix}\"\n\n        # Create finding group\n        group = FindingGroup(\n            name=group_name,\n            explicit_risk=risk,\n            sub_findings=[sub_finding],\n            _target_locators=self.target_locators,\n            _finding_group_locators=[],\n            _show_locator_types=get_locator_types(),\n        )\n\n        # Append to findings.toml\n        with self.config_file.open(\"a\", encoding=\"utf-8\") as f:\n            f.write(f\"\\n{group.dumps_toml()}\\n\")\n\n        # Add to loaded groups\n        self.groups.append(group)\n\n    @validate_call\n    def select_group(self, selector: int | str | None = None) -&gt; FindingGroup:\n        \"\"\"Select a finding group by index or name.\n\n        Args:\n            selector: The index or name of the finding group to select.\n\n        Returns:\n            The selected finding group.\n        \"\"\"\n        # only single finding group present\n        if selector is None:\n            if len(self.groups) != 1:\n                raise SeretoValueError(\n                    f\"cannot select finding group; no selector provided and there are {len(self.groups)} finding \"\n                    \"groups present\"\n                )\n            return self.groups[0]\n\n        # by index\n        if isinstance(selector, int) or selector.isnumeric():\n            ix = selector - 1 if isinstance(selector, int) else int(selector) - 1\n            if not (0 &lt;= ix &lt;= len(self.groups) - 1):\n                raise SeretoValueError(\"finding group index out of range\")\n            return self.groups[ix]\n\n        # by unique name\n        matching_groups = [g for g in self.groups if g.uname == selector]\n        if len(matching_groups) != 1:\n            raise SeretoValueError(f\"finding group with uname {selector!r} not found\")\n        return matching_groups[0]\n\n    @property\n    def config_file(self) -&gt; Path:\n        \"\"\"Get the path to the findings.toml configuration file\"\"\"\n        return self.target_dir / \"findings.toml\"\n\n    @property\n    def findings_dir(self) -&gt; Path:\n        \"\"\"Get the path to the directory containing the findings\"\"\"\n        return self.target_dir / \"findings\"\n\n    @property\n    def risks(self) -&gt; Risks:\n        \"\"\"Get the summary of risks for the specified version.\"\"\"\n        return Risks(\n            critical=len([g for g in self.groups if g.risk == Risk.critical]),\n            high=len([g for g in self.groups if g.risk == Risk.high]),\n            medium=len([g for g in self.groups if g.risk == Risk.medium]),\n            low=len([g for g in self.groups if g.risk == Risk.low]),\n            info=len([g for g in self.groups if g.risk == Risk.info]),\n            closed=len([g for g in self.groups if g.risk == Risk.closed]),\n        )\n</code></pre>"},{"location":"reference/finding/#sereto.finding.Findings.config_file","title":"<code>config_file</code>  <code>property</code>","text":"<p>Get the path to the findings.toml configuration file</p>"},{"location":"reference/finding/#sereto.finding.Findings.findings_dir","title":"<code>findings_dir</code>  <code>property</code>","text":"<p>Get the path to the directory containing the findings</p>"},{"location":"reference/finding/#sereto.finding.Findings.risks","title":"<code>risks</code>  <code>property</code>","text":"<p>Get the summary of risks for the specified version.</p>"},{"location":"reference/finding/#sereto.finding.Findings.add_from_template","title":"<code>add_from_template(templates, template_path, category, name=None, risk=None, variables=None, overwrite=False)</code>","text":"<p>Add a sub-finding from a template, creating a new finding group.</p> <p>Parameters:</p> Name Type Description Default <code>templates</code> <code>DirectoryPath</code> <p>Path to the templates directory.</p> required <code>template_path</code> <code>FilePath</code> <p>Path to the sub-finding template.</p> required <code>category</code> <code>str</code> <p>Category of the sub-finding.</p> required <code>name</code> <code>str | None</code> <p>Name of the sub-finding group. Defaults to template name.</p> <code>None</code> <code>risk</code> <code>Risk | None</code> <p>Risk of the sub-finding. Defaults to template risk.</p> <code>None</code> <code>variables</code> <code>dict[str, Any] | None</code> <p>Variables for the sub-finding template.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing sub-finding; otherwise, create with random suffix.</p> <code>False</code> Source code in <code>sereto/finding.py</code> <pre><code>@validate_call\ndef add_from_template(\n    self,\n    templates: DirectoryPath,\n    template_path: FilePath,\n    category: str,\n    name: str | None = None,\n    risk: Risk | None = None,\n    variables: dict[str, Any] | None = None,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"Add a sub-finding from a template, creating a new finding group.\n\n    Args:\n        templates: Path to the templates directory.\n        template_path: Path to the sub-finding template.\n        category: Category of the sub-finding.\n        name: Name of the sub-finding group. Defaults to template name.\n        risk: Risk of the sub-finding. Defaults to template risk.\n        variables: Variables for the sub-finding template.\n        overwrite: If True, overwrite existing sub-finding; otherwise, create with random suffix.\n    \"\"\"\n    variables = variables or {}\n\n    # Load template metadata and content\n    template_metadata = FindingTemplateFrontmatterModel.load_from(template_path)\n    template_name = template_path.name.removesuffix(\".md.j2\")\n    _, content = frontmatter.parse(template_path.read_text(encoding=\"utf-8\"), encoding=\"utf-8\")\n\n    # Determine sub-finding path\n    sub_finding_path = self.get_path(category=category, name=template_name)\n    suffix = None\n\n    if sub_finding_path.is_file():\n        if overwrite:\n            sub_finding_path.unlink()\n        else:\n            # Try to generate a unique filename with random suffix\n            for _ in range(5):\n                suffix = \"\".join(random.choices(string.ascii_lowercase + string.digits, k=5))\n                sub_finding_path = self.get_path(category=category, name=f\"{template_name}_{suffix}\")\n                if not sub_finding_path.is_file():\n                    break\n            else:\n                raise SeretoPathError(\n                    f\"sub-finding already exists and could not generate a unique filename: {sub_finding_path}\"\n                )\n\n    # Prepare sub-finding frontmatter\n    sub_finding_metadata = SubFindingFrontmatterModel(\n        name=template_metadata.name,\n        risk=template_metadata.risk,\n        category=category,\n        variables=variables,\n        template_path=str(template_path.relative_to(templates)),\n    )\n\n    # Write sub-finding file\n    sub_finding_path.write_text(f\"+++\\n{sub_finding_metadata.dumps_toml()}+++\\n\\n{content}\", encoding=\"utf-8\")\n\n    # If overwriting, nothing else to do\n    if overwrite:\n        return\n\n    # Load the created sub-finding\n    sub_finding = SubFinding.load_from(path=sub_finding_path, templates=templates)\n\n    # Determine group name\n    group_name = name or sub_finding.name\n    if suffix:\n        group_name = f\"{group_name} {suffix}\"\n\n    # Create finding group\n    group = FindingGroup(\n        name=group_name,\n        explicit_risk=risk,\n        sub_findings=[sub_finding],\n        _target_locators=self.target_locators,\n        _finding_group_locators=[],\n        _show_locator_types=get_locator_types(),\n    )\n\n    # Append to findings.toml\n    with self.config_file.open(\"a\", encoding=\"utf-8\") as f:\n        f.write(f\"\\n{group.dumps_toml()}\\n\")\n\n    # Add to loaded groups\n    self.groups.append(group)\n</code></pre>"},{"location":"reference/finding/#sereto.finding.Findings.get_path","title":"<code>get_path(category, name)</code>","text":"<p>Get the path to a sub-finding by category and name.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>The category of the sub-finding.</p> required <code>name</code> <code>str</code> <p>The name of the sub-finding.</p> required <p>Returns:</p> Type Description <code>FilePath</code> <p>The path to the sub-finding file.</p> Source code in <code>sereto/finding.py</code> <pre><code>def get_path(self, category: str, name: str) -&gt; FilePath:\n    \"\"\"Get the path to a sub-finding by category and name.\n\n    Args:\n        category: The category of the sub-finding.\n        name: The name of the sub-finding.\n\n    Returns:\n        The path to the sub-finding file.\n    \"\"\"\n    return self.findings_dir / f\"{category.lower()}_{name}.md.j2\"\n</code></pre>"},{"location":"reference/finding/#sereto.finding.Findings.load_from","title":"<code>load_from(target_dir, target_locators, templates)</code>  <code>classmethod</code>","text":"<p>Load findings belonging to the same target.</p> <p>Parameters:</p> Name Type Description Default <code>target_dir</code> <code>DirectoryPath</code> <p>The path to the target directory.</p> required <code>target_locators</code> <code>list[LocatorModel]</code> <p>The locators used to find the target.</p> required <code>templates</code> <code>DirectoryPath</code> <p>The path to the templates directory.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The loaded findings object.</p> Source code in <code>sereto/finding.py</code> <pre><code>@classmethod\n@validate_call\ndef load_from(\n    cls, target_dir: DirectoryPath, target_locators: list[LocatorModel], templates: DirectoryPath\n) -&gt; Self:\n    \"\"\"Load findings belonging to the same target.\n\n    Args:\n        target_dir: The path to the target directory.\n        target_locators: The locators used to find the target.\n        templates: The path to the templates directory.\n\n    Returns:\n        The loaded findings object.\n    \"\"\"\n    config = FindingsConfigModel.load_from(target_dir / \"findings.toml\")\n\n    groups = [\n        FindingGroup.load(\n            name=name,\n            group_desc=group,\n            findings_dir=target_dir / \"findings\",\n            target_locators=target_locators,\n            templates=templates,\n        )\n        for name, group in config.items()\n    ]\n\n    # ensure group names are unique\n    unique_names = [g.uname for g in groups]\n    if len(unique_names) != len(set(unique_names)):\n        raise SeretoValueError(\"finding group unique names must be unique\")\n\n    return cls(groups=groups, target_dir=target_dir, target_locators=target_locators)\n</code></pre>"},{"location":"reference/finding/#sereto.finding.Findings.select_group","title":"<code>select_group(selector=None)</code>","text":"<p>Select a finding group by index or name.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>int | str | None</code> <p>The index or name of the finding group to select.</p> <code>None</code> <p>Returns:</p> Type Description <code>FindingGroup</code> <p>The selected finding group.</p> Source code in <code>sereto/finding.py</code> <pre><code>@validate_call\ndef select_group(self, selector: int | str | None = None) -&gt; FindingGroup:\n    \"\"\"Select a finding group by index or name.\n\n    Args:\n        selector: The index or name of the finding group to select.\n\n    Returns:\n        The selected finding group.\n    \"\"\"\n    # only single finding group present\n    if selector is None:\n        if len(self.groups) != 1:\n            raise SeretoValueError(\n                f\"cannot select finding group; no selector provided and there are {len(self.groups)} finding \"\n                \"groups present\"\n            )\n        return self.groups[0]\n\n    # by index\n    if isinstance(selector, int) or selector.isnumeric():\n        ix = selector - 1 if isinstance(selector, int) else int(selector) - 1\n        if not (0 &lt;= ix &lt;= len(self.groups) - 1):\n            raise SeretoValueError(\"finding group index out of range\")\n        return self.groups[ix]\n\n    # by unique name\n    matching_groups = [g for g in self.groups if g.uname == selector]\n    if len(matching_groups) != 1:\n        raise SeretoValueError(f\"finding group with uname {selector!r} not found\")\n    return matching_groups[0]\n</code></pre>"},{"location":"reference/finding/#sereto.finding.SubFinding","title":"<code>SubFinding</code>  <code>dataclass</code>","text":"Source code in <code>sereto/finding.py</code> <pre><code>@dataclass\nclass SubFinding:\n    name: str\n    risk: Risk\n    vars: dict[str, Any]\n    path: FilePath\n    template: FilePath | None = None\n    locators: list[LocatorModel] = field(default_factory=list)\n    format: FileFormat = FileFormat.md\n    reported_on: SeretoDate | None = None\n\n    @classmethod\n    @validate_call\n    def load_from(cls, path: FilePath, templates: DirectoryPath) -&gt; Self:\n        \"\"\"Load a sub-finding from a file.\n\n        Args:\n            path: The path to the sub-finding file.\n            templates: The path to the templates directory.\n\n        Returns:\n            The loaded sub-finding object.\n        \"\"\"\n        frontmatter = SubFindingFrontmatterModel.load_from(path)\n\n        return cls(\n            name=frontmatter.name,\n            risk=frontmatter.risk,\n            vars=frontmatter.variables,\n            path=path,\n            template=(templates / frontmatter.template_path) if frontmatter.template_path else None,\n            locators=frontmatter.locators,\n            format=frontmatter.format,\n            reported_on=frontmatter.reported_on,\n        )\n\n    @property\n    def uname(self) -&gt; str:\n        \"\"\"Unique name of the finding.\"\"\"\n        return self.path.name.removesuffix(\".md.j2\")\n\n    @validate_call\n    def filter_locators(self, type: str | Iterable[str]) -&gt; list[LocatorModel]:\n        \"\"\"Filter locators by type.\n\n        Args:\n            type: The type of locators to filter by. Can be a single type or an iterable of types.\n\n        Returns:\n            A list of locators of the specified type.\n        \"\"\"\n        type = [type] if isinstance(type, str) else list(type)\n        return [loc for loc in self.locators if loc.type in type]\n\n    @validate_call\n    def validate_vars(self) -&gt; None:\n        \"\"\"Validate the variables of the sub-finding against definition in the template.\n\n        Works only if there is a template path defined, otherwise no validation is done.\n\n        Raises:\n            SeretoValueError: If the variables are not valid.\n        \"\"\"\n        if self.template is None:\n            # no template path, no validation\n            return\n\n        # read template frontmatter\n        template_frontmatter = FindingTemplateFrontmatterModel.load_from(self.template)\n\n        # report all errors at once\n        error = \"\"\n\n        for var in template_frontmatter.variables:\n            # check if variable is defined\n            if var.name not in self.vars:\n                if var.required:\n                    error += f\"{var.name}: {var.type_annotation} = {var.description}\\n\"\n                    error += f\"  - missing required variable in finding '{self.name}'\\n\"\n                else:\n                    # TODO: logger\n                    print(\n                        f\"{var.name}: {var.type_annotation} = {var.description}\\n\"\n                        f\"  - optional variable is not defined in finding '{self.name}'\\n\"\n                    )\n                continue\n\n            # variable should be a list and is not\n            if var.is_list and not isinstance(self.vars[var.name], list):\n                error += f\"{var.name}: {var.type_annotation} = {var.description}\\n\"\n                error += f\"  - variable must be a list in finding '{self.name}'\\n\"\n                continue\n\n            # variable should not be a list and is\n            if not var.is_list and isinstance(self.vars[var.name], list):\n                error += f\"{var.name}: {var.type_annotation} = {var.description}\\n\"\n                error += f\"  - variable must not be a list in finding '{self.name}'\\n\"\n                continue\n\n        # report all errors at once\n        if len(error) &gt; 0:\n            raise SeretoValueError(f\"invalid variables in finding '{self.name}'\\n{error}\")\n</code></pre>"},{"location":"reference/finding/#sereto.finding.SubFinding.uname","title":"<code>uname</code>  <code>property</code>","text":"<p>Unique name of the finding.</p>"},{"location":"reference/finding/#sereto.finding.SubFinding.filter_locators","title":"<code>filter_locators(type)</code>","text":"<p>Filter locators by type.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str | Iterable[str]</code> <p>The type of locators to filter by. Can be a single type or an iterable of types.</p> required <p>Returns:</p> Type Description <code>list[LocatorModel]</code> <p>A list of locators of the specified type.</p> Source code in <code>sereto/finding.py</code> <pre><code>@validate_call\ndef filter_locators(self, type: str | Iterable[str]) -&gt; list[LocatorModel]:\n    \"\"\"Filter locators by type.\n\n    Args:\n        type: The type of locators to filter by. Can be a single type or an iterable of types.\n\n    Returns:\n        A list of locators of the specified type.\n    \"\"\"\n    type = [type] if isinstance(type, str) else list(type)\n    return [loc for loc in self.locators if loc.type in type]\n</code></pre>"},{"location":"reference/finding/#sereto.finding.SubFinding.load_from","title":"<code>load_from(path, templates)</code>  <code>classmethod</code>","text":"<p>Load a sub-finding from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>FilePath</code> <p>The path to the sub-finding file.</p> required <code>templates</code> <code>DirectoryPath</code> <p>The path to the templates directory.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The loaded sub-finding object.</p> Source code in <code>sereto/finding.py</code> <pre><code>@classmethod\n@validate_call\ndef load_from(cls, path: FilePath, templates: DirectoryPath) -&gt; Self:\n    \"\"\"Load a sub-finding from a file.\n\n    Args:\n        path: The path to the sub-finding file.\n        templates: The path to the templates directory.\n\n    Returns:\n        The loaded sub-finding object.\n    \"\"\"\n    frontmatter = SubFindingFrontmatterModel.load_from(path)\n\n    return cls(\n        name=frontmatter.name,\n        risk=frontmatter.risk,\n        vars=frontmatter.variables,\n        path=path,\n        template=(templates / frontmatter.template_path) if frontmatter.template_path else None,\n        locators=frontmatter.locators,\n        format=frontmatter.format,\n        reported_on=frontmatter.reported_on,\n    )\n</code></pre>"},{"location":"reference/finding/#sereto.finding.SubFinding.validate_vars","title":"<code>validate_vars()</code>","text":"<p>Validate the variables of the sub-finding against definition in the template.</p> <p>Works only if there is a template path defined, otherwise no validation is done.</p> <p>Raises:</p> Type Description <code>SeretoValueError</code> <p>If the variables are not valid.</p> Source code in <code>sereto/finding.py</code> <pre><code>@validate_call\ndef validate_vars(self) -&gt; None:\n    \"\"\"Validate the variables of the sub-finding against definition in the template.\n\n    Works only if there is a template path defined, otherwise no validation is done.\n\n    Raises:\n        SeretoValueError: If the variables are not valid.\n    \"\"\"\n    if self.template is None:\n        # no template path, no validation\n        return\n\n    # read template frontmatter\n    template_frontmatter = FindingTemplateFrontmatterModel.load_from(self.template)\n\n    # report all errors at once\n    error = \"\"\n\n    for var in template_frontmatter.variables:\n        # check if variable is defined\n        if var.name not in self.vars:\n            if var.required:\n                error += f\"{var.name}: {var.type_annotation} = {var.description}\\n\"\n                error += f\"  - missing required variable in finding '{self.name}'\\n\"\n            else:\n                # TODO: logger\n                print(\n                    f\"{var.name}: {var.type_annotation} = {var.description}\\n\"\n                    f\"  - optional variable is not defined in finding '{self.name}'\\n\"\n                )\n            continue\n\n        # variable should be a list and is not\n        if var.is_list and not isinstance(self.vars[var.name], list):\n            error += f\"{var.name}: {var.type_annotation} = {var.description}\\n\"\n            error += f\"  - variable must be a list in finding '{self.name}'\\n\"\n            continue\n\n        # variable should not be a list and is\n        if not var.is_list and isinstance(self.vars[var.name], list):\n            error += f\"{var.name}: {var.type_annotation} = {var.description}\\n\"\n            error += f\"  - variable must not be a list in finding '{self.name}'\\n\"\n            continue\n\n    # report all errors at once\n    if len(error) &gt; 0:\n        raise SeretoValueError(f\"invalid variables in finding '{self.name}'\\n{error}\")\n</code></pre>"},{"location":"reference/jinja/","title":"Jinja","text":""},{"location":"reference/jinja/#sereto.jinja","title":"<code>sereto.jinja</code>","text":""},{"location":"reference/jinja/#sereto.jinja.FrontMatterStrippingLoader","title":"<code>FrontMatterStrippingLoader</code>","text":"<p>               Bases: <code>FileSystemLoader</code></p> <p>A Jinja2 template loader that strips frontmatter from templates.</p> Source code in <code>sereto/jinja.py</code> <pre><code>class FrontMatterStrippingLoader(FileSystemLoader):\n    \"\"\"A Jinja2 template loader that strips frontmatter from templates.\"\"\"\n\n    def get_source(\n        self,\n        environment: Environment,\n        template: str,\n    ) -&gt; tuple[str, str, Callable[[], bool]]:\n        source, filename, uptodate = super().get_source(environment, template)\n        content: str = frontmatter.loads(source).content\n        return content, filename, uptodate\n</code></pre>"},{"location":"reference/jinja/#sereto.jinja.get_generic_jinja_env","title":"<code>get_generic_jinja_env(templates)</code>","text":"<p>Creates a generic Jinja2 environment object.</p> <p>Parameters:</p> Name Type Description Default <code>templates</code> <code>DirectoryPath | Sequence[DirectoryPath]</code> <p>The directory/directories containing template files.</p> required <p>Returns:</p> Type Description <code>Environment</code> <p>A Jinja2 environment object.</p> Source code in <code>sereto/jinja.py</code> <pre><code>@validate_call\ndef get_generic_jinja_env(templates: DirectoryPath | Sequence[DirectoryPath]) -&gt; Environment:\n    \"\"\"Creates a generic Jinja2 environment object.\n\n    Args:\n        templates: The directory/directories containing template files.\n\n    Returns:\n        A Jinja2 environment object.\n    \"\"\"\n    env: Environment = Environment(\n        autoescape=False, loader=FrontMatterStrippingLoader(templates), undefined=StrictUndefined\n    )\n    env.globals[\"MANUAL_EDIT_WARNING\"] = MANUAL_EDIT_WARNING\n    env.add_extension(\"jinja2.ext.debug\")\n    return env\n</code></pre>"},{"location":"reference/jinja/#sereto.jinja.get_tex_jinja_env","title":"<code>get_tex_jinja_env(templates)</code>","text":"<p>Creates a Jinja2 environment object for rendering TeX templates.</p> <p>Parameters:</p> Name Type Description Default <code>templates</code> <code>DirectoryPath | Sequence[DirectoryPath]</code> <p>The directory/directories containing the TeX template files.</p> required <p>Returns:</p> Type Description <code>Environment</code> <p>A Jinja2 environment object that is configured for rendering TeX templates.</p> Source code in <code>sereto/jinja.py</code> <pre><code>@validate_call\ndef get_tex_jinja_env(templates: DirectoryPath | Sequence[DirectoryPath]) -&gt; Environment:\n    \"\"\"Creates a Jinja2 environment object for rendering TeX templates.\n\n    Args:\n        templates: The directory/directories containing the TeX template files.\n\n    Returns:\n        A Jinja2 environment object that is configured for rendering TeX templates.\n    \"\"\"\n    env: Environment = Environment(\n        block_start_string=\"((*\",\n        block_end_string=\"*))\",\n        variable_start_string=\"(((\",\n        variable_end_string=\")))\",\n        comment_start_string=\"((=\",\n        comment_end_string=\"=))\",\n        autoescape=False,\n        loader=FrontMatterStrippingLoader(templates),\n        undefined=StrictUndefined,\n    )\n\n    # TODO: Once Jinja2 allows custom escape functions, we might use autoescape of special TeX characters.\n    env.filters[\"tex\"] = tex_escape_filter\n    env.filters[\"yesno\"] = yesno_filter\n    env.globals[\"MANUAL_EDIT_WARNING\"] = MANUAL_EDIT_WARNING\n    env.add_extension(\"jinja2.ext.debug\")\n\n    return env\n</code></pre>"},{"location":"reference/jinja/#sereto.jinja.get_typst_jinja_env","title":"<code>get_typst_jinja_env(templates)</code>","text":"<p>Creates a Jinja2 environment object for rendering Typst templates.</p> <p>Parameters:</p> Name Type Description Default <code>templates</code> <code>DirectoryPath | Sequence[DirectoryPath]</code> <p>The directory/directories containing the Typst template files.</p> required <p>Returns:</p> Type Description <code>Environment</code> <p>A Jinja2 environment object that is configured for rendering Typst templates.</p> Source code in <code>sereto/jinja.py</code> <pre><code>@validate_call\ndef get_typst_jinja_env(templates: DirectoryPath | Sequence[DirectoryPath]) -&gt; Environment:\n    \"\"\"Creates a Jinja2 environment object for rendering Typst templates.\n\n    Args:\n        templates: The directory/directories containing the Typst template files.\n\n    Returns:\n        A Jinja2 environment object that is configured for rendering Typst templates.\n    \"\"\"\n    env: Environment = Environment(\n        block_start_string=\"((*\",\n        block_end_string=\"*))\",\n        variable_start_string=\"(((\",\n        variable_end_string=\")))\",\n        comment_start_string=\"((=\",\n        comment_end_string=\"=))\",\n        autoescape=False,\n        loader=FrontMatterStrippingLoader(templates),\n        undefined=StrictUndefined,\n    )\n\n    env.filters[\"yesno\"] = yesno_filter\n    env.globals[\"MANUAL_EDIT_WARNING\"] = MANUAL_EDIT_WARNING\n    env.add_extension(\"jinja2.ext.debug\")\n    return env\n</code></pre>"},{"location":"reference/jinja/#sereto.jinja.render_jinja2","title":"<code>render_jinja2(file, templates, vars)</code>","text":"<p>Renders a Jinja2 template.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>FilePath</code> <p>The path to the template file to be rendered.</p> required <code>templates</code> <code>DirectoryPath | Sequence[DirectoryPath]</code> <p>The directory/directories containing the template files.</p> required <code>vars</code> <code>dict[str, Any]</code> <p>A dictionary of variables to be passed to the Jinja2 template engine.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Rendered template as a string.</p> Source code in <code>sereto/jinja.py</code> <pre><code>@validate_call\ndef render_jinja2(file: FilePath, templates: DirectoryPath | Sequence[DirectoryPath], vars: dict[str, Any]) -&gt; str:\n    \"\"\"Renders a Jinja2 template.\n\n    Args:\n        file: The path to the template file to be rendered.\n        templates: The directory/directories containing the template files.\n        vars: A dictionary of variables to be passed to the Jinja2 template engine.\n\n    Returns:\n        Rendered template as a string.\n    \"\"\"\n    if file.name.endswith(\".tex.j2\"):\n        env: Environment = get_tex_jinja_env(templates=templates)\n    elif file.name.endswith(\".typ.j2\"):\n        env = get_typst_jinja_env(templates=templates)\n    elif file.name.endswith(\".j2\"):\n        env = get_generic_jinja_env(templates=templates)\n    else:\n        raise SeretoValueError(\"unsupported file type\")\n\n    template: Template = env.get_template(name=file.name)\n\n    content = strip_toml_frontmatter(file.read_text(encoding=\"utf-8\"))\n    template = env.from_string(content)\n\n    try:\n        return template.render(vars)\n    except UndefinedError as e:\n        raise SeretoValueError(f\"Undefined variable or attribute in template '{file.name}': {e}\") from e\n</code></pre>"},{"location":"reference/jinja/#sereto.jinja.tex_escape_filter","title":"<code>tex_escape_filter(text, default='n/a')</code>","text":"<p>Escape special characters in text for use in TeX.</p> <p>This function serves as a Jinja2 filter to escape special characters in <code>text</code> for use in TeX. It replaces each special character with its corresponding TeX escape sequence. The <code>default</code> argument can be used to specify a default value to return if <code>text</code> is undefined or empty.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>Any</code> <p>The text to be escaped.</p> required <code>default</code> <code>str</code> <p>The default value to return if <code>text</code> is undefined or empty. Defaults to 'n/a'.</p> <code>'n/a'</code> <p>Returns:</p> Type Description <code>str</code> <p>The escaped text.</p> Source code in <code>sereto/jinja.py</code> <pre><code>def tex_escape_filter(text: Any, default: str = \"n/a\") -&gt; str:\n    \"\"\"Escape special characters in text for use in TeX.\n\n    This function serves as a Jinja2 filter to escape special characters in `text` for use in TeX. It replaces each\n    special character with its corresponding TeX escape sequence. The `default` argument can be used to specify a\n    default value to return if `text` is undefined or empty.\n\n    Args:\n        text: The text to be escaped.\n        default: The default value to return if `text` is undefined or empty. Defaults to 'n/a'.\n\n    Returns:\n        The escaped text.\n    \"\"\"\n    if is_undefined(text) or not text:\n        text = default\n\n    replacements = {\n        \"&amp;\": r\"\\&amp;\",\n        \"%\": r\"\\%\",\n        \"$\": r\"\\$\",\n        \"#\": r\"\\#\",\n        \"_\": r\"\\_\",\n        \"{\": r\"\\{\",\n        \"}\": r\"\\}\",\n        \"~\": r\"\\textasciitilde{}\",\n        \"^\": r\"\\^{}\",\n        \"\\\\\": r\"\\textbackslash{}\",\n        \"&lt;\": r\"\\textless{}\",\n        \"&gt;\": r\"\\textgreater{}\",\n    }\n    return replace_strings(str(text), replacements=replacements)\n</code></pre>"},{"location":"reference/jinja/#sereto.jinja.yesno_filter","title":"<code>yesno_filter(value, arg='yes,no,maybe')</code>","text":"<p>Tex filter for converting boolean values to strings.</p> <p>Given a string mapping values for true, false, and (optionally) None, return one of those strings according to the value: ==========  ======================  ================================== Value       Argument                Outputs ==========  ======================  ================================== <code>True</code> <code>\"yeah,no,maybe\"</code> <code>yeah</code> <code>False</code> <code>\"yeah,no,maybe\"</code> <code>no</code> <code>None</code> <code>\"yeah,no,maybe\"</code> <code>maybe</code> <code>None</code> <code>\"yeah,no\"</code> <code>\"no\"</code> (converts None to False                                     if no mapping for None is given. ==========  ======================  ==================================</p> Source code in <code>sereto/jinja.py</code> <pre><code>def yesno_filter(value: str | None, arg: str = \"yes,no,maybe\") -&gt; str:\n    \"\"\"Tex filter for converting boolean values to strings.\n\n    Given a string mapping values for true, false, and (optionally) None,\n    return one of those strings according to the value:\n    ==========  ======================  ==================================\n    Value       Argument                Outputs\n    ==========  ======================  ==================================\n    ``True``    ``\"yeah,no,maybe\"``     ``yeah``\n    ``False``   ``\"yeah,no,maybe\"``     ``no``\n    ``None``    ``\"yeah,no,maybe\"``     ``maybe``\n    ``None``    ``\"yeah,no\"``           ``\"no\"`` (converts None to False\n                                        if no mapping for None is given.\n    ==========  ======================  ==================================\n    \"\"\"\n    bits = arg.split(\",\")\n    if len(bits) &lt; 2 or len(bits) &gt; 3:\n        raise SeretoValueError(\"invalid argument\")\n    try:\n        yes, no, maybe = bits\n    except ValueError:\n        # Unpack list of wrong size (no \"maybe\" value provided).\n        yes, no, maybe = bits[0], bits[1], bits[1]\n    if value is None:\n        return maybe\n    if value:\n        return yes\n    return no\n</code></pre>"},{"location":"reference/keyring/","title":"Keyring","text":""},{"location":"reference/keyring/#sereto.keyring","title":"<code>sereto.keyring</code>","text":""},{"location":"reference/keyring/#sereto.keyring.get_password","title":"<code>get_password(service_name, username)</code>","text":"<p>Retrieve a password from the system keyring with fallback to plaintext file.</p> Source code in <code>sereto/keyring.py</code> <pre><code>def get_password(service_name: str, username: str) -&gt; str | None:\n    \"\"\"Retrieve a password from the system keyring with fallback to plaintext file.\"\"\"\n    try:\n        return keyring.get_password(service_name=service_name, username=username)\n    except keyring.errors.InitError:\n        keyring.set_keyring(PlaintextKeyring())\n        return keyring.get_password(service_name=service_name, username=username)\n</code></pre>"},{"location":"reference/keyring/#sereto.keyring.set_password","title":"<code>set_password(service_name, username, password)</code>","text":"<p>Set a password to the system keyring with fallback to plaintext file.</p> Source code in <code>sereto/keyring.py</code> <pre><code>def set_password(service_name: str, username: str, password: str) -&gt; None:\n    \"\"\"Set a password to the system keyring with fallback to plaintext file.\"\"\"\n    try:\n        keyring.set_password(service_name=service_name, username=username, password=password)\n    except keyring.errors.InitError:\n        keyring.set_keyring(PlaintextKeyring())\n        keyring.set_password(service_name=service_name, username=username, password=password)\n</code></pre>"},{"location":"reference/parsing/","title":"Parsing","text":""},{"location":"reference/parsing/#sereto.parsing","title":"<code>sereto.parsing</code>","text":""},{"location":"reference/parsing/#sereto.parsing.parse_query","title":"<code>parse_query(query, keys)</code>","text":"<p>Parse a search query string into a structured dictionary.</p> Source code in <code>sereto/parsing.py</code> <pre><code>def parse_query(query: str, keys: dict[str, str]) -&gt; dict[str, list[str]]:\n    \"\"\"Parse a search query string into a structured dictionary.\"\"\"\n    parser = search_parser(keys)\n    reverse_keys = {v: k for k, v in keys.items()}\n\n    result: dict[str, list[str]] = {key: [] for key in keys}\n\n    try:\n        for token in parser.parseString(query):\n            if len(token) == 2:\n                key, value = token\n\n                if isinstance(value, str) and not value.strip():\n                    continue\n\n                full_key = reverse_keys.get(key, key)\n                result[full_key].append(value)\n            else:\n                value = token[0]\n\n                if isinstance(value, str) and not value.strip():\n                    continue\n\n                first_key = next(iter(keys))\n                result[first_key].append(value)\n\n    except pp.ParseException:\n        pass\n\n    return result\n</code></pre>"},{"location":"reference/parsing/#sereto.parsing.search_parser","title":"<code>search_parser(keys)</code>","text":"<p>Builds and returns a search query parser for simple key-value syntax.</p> Source code in <code>sereto/parsing.py</code> <pre><code>def search_parser(keys: dict[str, str]) -&gt; pp.ParserElement:\n    \"\"\"Builds and returns a search query parser for simple key-value syntax.\"\"\"\n    value = pp.Word(pp.alphanums + \"-_.\") | pp.QuotedString('\"') | pp.QuotedString(\"'\")\n    key = pp.oneOf(list(keys.keys()) + list(keys.values()))\n\n    complete = pp.Group(key + pp.Suppress(\":\") + value)\n    partial = pp.Group(key + pp.Suppress(\":\"))\n    free_value = pp.Group(value)\n\n    return pp.ZeroOrMore(complete | partial | free_value)\n</code></pre>"},{"location":"reference/pdf/","title":"Pdf","text":""},{"location":"reference/pdf/#sereto.pdf","title":"<code>sereto.pdf</code>","text":""},{"location":"reference/pdf/#sereto.pdf.find_and_generate_pdf_finding_group","title":"<code>find_and_generate_pdf_finding_group(project, target_selector, finding_group_selector, converter, renderer, version)</code>","text":"<p>Generate a finding group PDF from given target and finding group selectors.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>Project</code> <p>Project's representation.</p> required <code>target_selector</code> <code>int | str | None</code> <p>The target selector (1-based index or unique name). If None, the only target is selected.</p> required <code>finding_group_selector</code> <code>int | str | None</code> <p>The finding group selector (1-based index or unique name). If None, the only finding group is selected.</p> required <code>converter</code> <code>str | None</code> <p>The convert recipe used for file format transformations. If None, the first recipe is used.</p> required <code>renderer</code> <code>str | None</code> <p>The recipe used for generating the finding group. If None, the first recipe is used.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The version of the project to use. If None, the last version is used.</p> required <p>Returns:</p> Type Description <code>FilePath</code> <p>Path to the generated finding group PDF.</p> Source code in <code>sereto/pdf.py</code> <pre><code>@validate_call\ndef find_and_generate_pdf_finding_group(\n    project: Project,\n    target_selector: int | str | None,\n    finding_group_selector: int | str | None,\n    converter: str | None,\n    renderer: str | None,\n    version: ProjectVersion | None,\n) -&gt; FilePath:\n    \"\"\"Generate a finding group PDF from given target and finding group selectors.\n\n    Args:\n        project: Project's representation.\n        target_selector: The target selector (1-based index or unique name). If None, the only target is selected.\n        finding_group_selector: The finding group selector (1-based index or unique name). If None, the only finding\n            group is selected.\n        converter: The convert recipe used for file format transformations. If None, the first recipe is used.\n        renderer: The recipe used for generating the finding group. If None, the first recipe is used.\n        version: The version of the project to use. If None, the last version is used.\n\n    Returns:\n        Path to the generated finding group PDF.\n    \"\"\"\n    if version is None:\n        version = project.config.last_version\n\n    # Select target and finding group\n    target = project.config.at_version(version).select_target(\n        categories=project.settings.categories, selector=target_selector\n    )\n    fg = target.findings.select_group(selector=finding_group_selector)\n\n    # Create missing objects\n    project_create_missing(project=project, version_config=project.config.at_version(version))\n\n    return generate_pdf_finding_group(\n        project=project,\n        target=target,\n        fg=fg,\n        converter=converter,\n        renderer=renderer,\n        version=version,\n    )\n</code></pre>"},{"location":"reference/pdf/#sereto.pdf.generate_all_pdf_finding_groups","title":"<code>generate_all_pdf_finding_groups(project, converter, renderer, version)</code>","text":"<p>Generate all finding group PDFs.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>Project</code> <p>Project's representation.</p> required <code>converter</code> <code>str | None</code> <p>The convert recipe used for file format transformations. If None, the first recipe is used.</p> required <code>renderer</code> <code>str | None</code> <p>The recipe used for generating the finding group. If None, the first recipe is used.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The version of the project to use. If None, the last version is used.</p> required <p>Returns:</p> Type Description <code>list[FilePath]</code> <p>List of paths to the generated finding group PDFs.</p> Source code in <code>sereto/pdf.py</code> <pre><code>@validate_call\ndef generate_all_pdf_finding_groups(\n    project: Project,\n    converter: str | None,\n    renderer: str | None,\n    version: ProjectVersion | None,\n) -&gt; list[FilePath]:\n    \"\"\"Generate all finding group PDFs.\n\n    Args:\n        project: Project's representation.\n        converter: The convert recipe used for file format transformations. If None, the first recipe is used.\n        renderer: The recipe used for generating the finding group. If None, the first recipe is used.\n        version: The version of the project to use. If None, the last version is used.\n\n    Returns:\n        List of paths to the generated finding group PDFs.\n    \"\"\"\n    if version is None:\n        version = project.config.last_version\n\n    # Create missing objects\n    project_create_missing(project=project, version_config=project.config.at_version(version))\n\n    return [\n        generate_pdf_finding_group(\n            project=project,\n            target=target,\n            fg=fg,\n            converter=converter,\n            renderer=renderer,\n            version=version,\n        )\n        for target in project.config.at_version(version).targets\n        for fg in target.findings.groups\n    ]\n</code></pre>"},{"location":"reference/pdf/#sereto.pdf.generate_pdf_finding_group","title":"<code>generate_pdf_finding_group(project, target, fg, converter, renderer, version)</code>","text":"<p>Generate a finding group PDF.</p> <p>You should call <code>project_create_missing</code> before calling this function.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>Project</code> <p>Project's representation.</p> required <code>target</code> <code>Target</code> <p>The target containing the finding group.</p> required <code>fg</code> <code>FindingGroup</code> <p>The finding group to generate.</p> required <code>converter</code> <code>str | None</code> <p>The convert recipe used for file format transformations. If None, the first recipe is used.</p> required <code>renderer</code> <code>str | None</code> <p>The recipe used for generating the finding group. If None, the first recipe is used.</p> required <code>version</code> <code>ProjectVersion</code> <p>The version of the project to use.</p> required <p>Returns:</p> Type Description <code>FilePath</code> <p>Path to the generated finding group PDF.</p> Source code in <code>sereto/pdf.py</code> <pre><code>@validate_call\ndef generate_pdf_finding_group(\n    project: Project,\n    target: Target,\n    fg: FindingGroup,\n    converter: str | None,\n    renderer: str | None,\n    version: ProjectVersion,\n) -&gt; FilePath:\n    \"\"\"Generate a finding group PDF.\n\n    You should call `project_create_missing` before calling this function.\n\n    Args:\n        project: Project's representation.\n        target: The target containing the finding group.\n        fg: The finding group to generate.\n        converter: The convert recipe used for file format transformations. If None, the first recipe is used.\n        renderer: The recipe used for generating the finding group. If None, the first recipe is used.\n        version: The version of the project to use.\n\n    Returns:\n        Path to the generated finding group PDF.\n    \"\"\"\n    logger.info(\"Rendering partial report for finding group '{}'\", fg.uname)\n    recipe = project.settings.render.get_finding_group_recipe(name=renderer)\n\n    # Build finding group to intermediate format\n    build_finding_group_dependencies(\n        project=project,\n        target=target,\n        finding_group=fg,\n        version=version,\n        intermediate_format=recipe.intermediate_format,\n        converter=converter,\n    )\n    finding_group_intermediate = build_finding_group_to_format(\n        project=project, target=target, finding_group=fg, format=recipe.intermediate_format, version=version\n    )\n\n    # Render PDF\n    finding_group_pdf = render_to_pdf(\n        file=finding_group_intermediate,\n        templates=project.settings.templates_path,\n        project_path=project.path,\n        render=project.settings.render,\n        recipe=recipe,\n    )\n\n    # Move the finding group PDF to the \"pdf\" directory\n    pdf_dir = project.ensure_dir(\"pdf\")\n    return finding_group_pdf.replace(pdf_dir / f\"{target.uname}_{finding_group_pdf.name}\")\n</code></pre>"},{"location":"reference/pdf/#sereto.pdf.generate_pdf_report","title":"<code>generate_pdf_report(project, template, report_recipe=None, convert_recipe=None, version=None)</code>","text":"<p>Generate a report PDF.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>Project</code> <p>Project's representation.</p> required <code>template</code> <code>str</code> <p>The template used for generating the report.</p> required <code>report_recipe</code> <code>str | None</code> <p>The recipe used for generating the report. If None, the first recipe is used.</p> <code>None</code> <code>convert_recipe</code> <code>str | None</code> <p>The convert recipe used for file format transformations. If None, the first recipe is used.</p> <code>None</code> <code>version</code> <code>ProjectVersion | None</code> <p>The version of the project to use. If None, the last version</p> <code>None</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the generated report PDF.</p> Source code in <code>sereto/pdf.py</code> <pre><code>@validate_call\ndef generate_pdf_report(\n    project: Project,\n    template: str,\n    report_recipe: str | None = None,\n    convert_recipe: str | None = None,\n    version: ProjectVersion | None = None,\n) -&gt; Path:\n    \"\"\"Generate a report PDF.\n\n    Args:\n        project: Project's representation.\n        template: The template used for generating the report.\n        report_recipe: The recipe used for generating the report. If None, the first recipe is used.\n        convert_recipe: The convert recipe used for file format transformations. If None, the first recipe is used.\n        version: The version of the project to use. If None, the last version\n\n    Returns:\n        Path to the generated report PDF.\n    \"\"\"\n    if version is None:\n        version = project.config.last_version\n\n    logger.info(\"Rendering report version: '{}'\", version)\n\n    project_create_missing(project=project, version_config=project.config.at_version(version))\n    recipe = project.settings.render.get_report_recipe(name=report_recipe)\n\n    # Build report to intermediate format\n    report_intermediate = build_report_to_format(\n        project=project,\n        template=template,\n        version=version,\n        format=recipe.intermediate_format,\n        converter=convert_recipe,\n    )\n\n    # Render PDF\n    report_pdf = render_to_pdf(\n        file=report_intermediate,\n        templates=project.settings.templates_path,\n        project_path=project.path,\n        render=project.settings.render,\n        recipe=recipe,\n    )\n\n    # Create directory for the PDF results if it does not exist\n    if not (pdf_dir := project.path / \"pdf\").is_dir():\n        pdf_dir.mkdir()\n\n    # Move the report PDF to the \"pdf\" directory\n    version_config = project.config.at_version(version) if version else project.config.last_config\n    report_pdf = report_pdf.rename(project.path / \"pdf\" / version_config.report_name)\n\n    return report_pdf\n</code></pre>"},{"location":"reference/pdf/#sereto.pdf.generate_pdf_sow","title":"<code>generate_pdf_sow(project, sow_recipe, version)</code>","text":"<p>Generate a Statement of Work (SoW) PDF.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>Project</code> <p>Project's representation.</p> required <code>sow_recipe</code> <code>str | None</code> <p>The recipe used for generating the SoW. If None, the first recipe is used.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The version of the project to use. If None, the last version</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path to the generated Statement of Work (SoW) PDF.</p> Source code in <code>sereto/pdf.py</code> <pre><code>@validate_call\ndef generate_pdf_sow(project: Project, sow_recipe: str | None, version: ProjectVersion | None) -&gt; Path:\n    \"\"\"Generate a Statement of Work (SoW) PDF.\n\n    Args:\n        project: Project's representation.\n        sow_recipe: The recipe used for generating the SoW. If None, the first recipe is used.\n        version: The version of the project to use. If None, the last version\n\n    Returns:\n        Path to the generated Statement of Work (SoW) PDF.\n    \"\"\"\n    if version is None:\n        version = project.config.last_version\n\n    logger.info(\"Rendering SoW version: '{}'\", version)\n\n    project_create_missing(project=project, version_config=project.config.at_version(version))\n    recipe = project.settings.render.get_sow_recipe(name=sow_recipe)\n\n    # Build SoW to intermediate format\n    sow_intermediate = build_sow_to_format(project=project, version=version, format=recipe.intermediate_format)\n\n    # Render PDF\n    sow_pdf = render_to_pdf(\n        file=sow_intermediate,\n        templates=project.settings.templates_path,\n        project_path=project.path,\n        render=project.settings.render,\n        recipe=recipe,\n    )\n\n    # Create directory for the PDF results if it does not exist\n    if not (pdf_dir := project.path / \"pdf\").is_dir():\n        pdf_dir.mkdir()\n\n    # Move the SoW PDF to the \"pdf\" directory\n    version_config = project.config.at_version(version) if version else project.config.last_config\n    sow_pdf = sow_pdf.rename(project.path / \"pdf\" / version_config.sow_name)\n\n    return sow_pdf\n</code></pre>"},{"location":"reference/pdf/#sereto.pdf.generate_pdf_target","title":"<code>generate_pdf_target(project, target_selector, target_recipe, convert_recipe, version)</code>","text":"<p>Generate a target PDF.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>Project</code> <p>Project's representation.</p> required <code>target_selector</code> <code>int | str | None</code> <p>The target selector (1-based index or unique name). If None, the only target is selected.</p> required <code>target_recipe</code> <code>str | None</code> <p>The recipe used for generating the target. If None, the first recipe is used.</p> required <code>convert_recipe</code> <code>str | None</code> <p>The convert recipe used for file format transformations. If None, the first recipe is used.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The version of the project to use. If None, the last version</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path to the generated target PDF.</p> Source code in <code>sereto/pdf.py</code> <pre><code>@validate_call\ndef generate_pdf_target(\n    project: Project,\n    target_selector: int | str | None,\n    target_recipe: str | None,\n    convert_recipe: str | None,\n    version: ProjectVersion | None,\n) -&gt; Path:\n    \"\"\"Generate a target PDF.\n\n    Args:\n        project: Project's representation.\n        target_selector: The target selector (1-based index or unique name). If None, the only target is selected.\n        target_recipe: The recipe used for generating the target. If None, the first recipe is used.\n        convert_recipe: The convert recipe used for file format transformations. If None, the first recipe is used.\n        version: The version of the project to use. If None, the last version\n\n    Returns:\n        Path to the generated target PDF.\n    \"\"\"\n    if version is None:\n        version = project.config.last_version\n\n    # Select target\n    target = project.config.last_config.select_target(categories=project.settings.categories, selector=target_selector)\n\n    logger.info(\"Rendering partial report for target '{}'\", target.uname)\n\n    project_create_missing(project=project, version_config=project.config.at_version(version))\n    recipe = project.settings.render.get_target_recipe(name=target_recipe)\n\n    # Build target to intermediate format\n    build_target_dependencies(\n        project=project,\n        target=target,\n        version=version,\n        intermediate_format=recipe.intermediate_format,\n        converter=convert_recipe,\n    )\n    target_intermediate = build_target_to_format(\n        project=project, target=target, format=recipe.intermediate_format, version=version\n    )\n\n    # Render PDF\n    target_pdf = render_to_pdf(\n        file=target_intermediate,\n        templates=project.settings.templates_path,\n        project_path=project.path,\n        render=project.settings.render,\n        recipe=recipe,\n    )\n\n    # Create directory for the PDF results if it does not exist\n    if not (pdf_dir := project.path / \"pdf\").is_dir():\n        pdf_dir.mkdir()\n\n    # Move the target PDF to the \"pdf\" directory\n    target_pdf = target_pdf.rename(project.path / \"pdf\" / target_pdf.name)\n\n    return target_pdf\n</code></pre>"},{"location":"reference/plot/","title":"Plot","text":""},{"location":"reference/plot/#sereto.plot","title":"<code>sereto.plot</code>","text":""},{"location":"reference/plot/#sereto.plot.risks_plot","title":"<code>risks_plot(risks, path)</code>","text":"<p>Generate a bar plot with the number of vulnerabilities per risk rating.</p> <p>Parameters:</p> Name Type Description Default <code>risks</code> <code>Risks</code> <p>Object containing the counts of vulnerabilities for each risk rating.</p> required <code>path</code> <code>Path</code> <p>Desired destination for the generated PNG file.</p> required Source code in <code>sereto/plot.py</code> <pre><code>@validate_call\ndef risks_plot(risks: Risks, path: Path) -&gt; None:\n    \"\"\"Generate a bar plot with the number of vulnerabilities per risk rating.\n\n    Args:\n        risks: Object containing the counts of vulnerabilities for each risk rating.\n        path: Desired destination for the generated PNG file.\n    \"\"\"\n    NAMES = [\"Critical\", \"High\", \"Medium\", \"Low\", \"Info\"]\n    COUNTS = [risks.critical, risks.high, risks.medium, risks.low, risks.info]\n    COLORS = [\"red\", \"orange\", \"#f0f000\", \"#33cc33\", \"#3366ff\"]\n\n    # Set global font size\n    rcParams[\"font.size\"] = 14\n\n    fig, ax = plt.subplots()\n    fig.set_size_inches(10, 5)\n    ax.set_title(\"Number of Vulnerabilities by Risk Rating\")\n\n    rect = ax.bar(range(len(NAMES)), COUNTS, align=\"center\", color=COLORS)\n    ax.set_xticks(range(len(NAMES)))\n    ax.set_xticklabels(NAMES)\n    ax.set_yticks(range(max(risks.critical, risks.high, risks.medium, risks.low, risks.info) + 1))\n    _label_plot(ax, rect)\n\n    fig.tight_layout()\n    plt.margins(0.15)\n    plt.savefig(path, dpi=100)\n    plt.close(\"all\")\n</code></pre>"},{"location":"reference/project/","title":"Project","text":""},{"location":"reference/project/#sereto.project","title":"<code>sereto.project</code>","text":""},{"location":"reference/project/#sereto.project.Project","title":"<code>Project</code>  <code>dataclass</code>","text":"Source code in <code>sereto/project.py</code> <pre><code>@dataclass\nclass Project:\n    _settings: Settings | None = None\n    _project_path: DirectoryPath | None = None\n    _config: Config | None = None\n\n    @property\n    def settings(self) -&gt; Settings:\n        if self._settings is None:\n            self._settings = load_settings_function()\n        return self._settings\n\n    @property\n    def path(self) -&gt; DirectoryPath:\n        if self._project_path is None:\n            self._project_path = get_project_path_from_dir(dir=Path.cwd(), dir_subtree=self.settings.projects_path)\n        return self._project_path\n\n    @property\n    def config(self) -&gt; Config:\n        if self._config is None:\n            self._config = Config.load_from(\n                self.path / \"config.json\",\n                templates=self.settings.templates_path,\n                risk_due_dates=self.settings.risk_due_dates,\n            )\n        return self._config\n\n    @validate_call\n    def ensure_dir(self, relative_path: str | Path) -&gt; Path:\n        \"\"\"Ensure a directory inside the project exists, creating it if necessary.\n\n        Args:\n            relative_path: Path relative to the project root (e.g. \"pdf\" or \"reports/html\").\n\n        Returns:\n            Absolute Path to the ensured directory.\n\n        Raises:\n            SeretoValueError: If the path is absolute or escapes the project root.\n            SeretoPathError: If a non-directory object exists at the target path.\n        \"\"\"\n        rel = Path(relative_path)\n        if rel == Path(\"\") or rel == Path(\".\"):\n            return self.path\n\n        if rel.is_absolute():\n            raise SeretoValueError(\"relative_path must be relative, not absolute\")\n\n        dest = (self.path / rel).resolve()\n        project_root = self.path.resolve()\n\n        if not dest.is_relative_to(project_root):\n            raise SeretoValueError(\"relative_path points outside the project root\")\n\n        if dest.exists() and not dest.is_dir():\n            raise SeretoPathError(\"a non-directory object already exists at the requested path\")\n\n        if not dest.exists():\n            dest.mkdir(parents=True)\n\n        return dest\n\n    @property\n    def config_path(self) -&gt; Path:\n        \"\"\"Get the path to the project configuration file.\"\"\"\n        return self.path / \"config.json\"\n\n    @classmethod\n    def load_from(cls, path: DirectoryPath) -&gt; Self:\n        if not is_project_dir(path):\n            raise SeretoPathError(\"not a project directory\")\n        return cls(_project_path=path)\n</code></pre>"},{"location":"reference/project/#sereto.project.Project.config_path","title":"<code>config_path</code>  <code>property</code>","text":"<p>Get the path to the project configuration file.</p>"},{"location":"reference/project/#sereto.project.Project.ensure_dir","title":"<code>ensure_dir(relative_path)</code>","text":"<p>Ensure a directory inside the project exists, creating it if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>relative_path</code> <code>str | Path</code> <p>Path relative to the project root (e.g. \"pdf\" or \"reports/html\").</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Absolute Path to the ensured directory.</p> <p>Raises:</p> Type Description <code>SeretoValueError</code> <p>If the path is absolute or escapes the project root.</p> <code>SeretoPathError</code> <p>If a non-directory object exists at the target path.</p> Source code in <code>sereto/project.py</code> <pre><code>@validate_call\ndef ensure_dir(self, relative_path: str | Path) -&gt; Path:\n    \"\"\"Ensure a directory inside the project exists, creating it if necessary.\n\n    Args:\n        relative_path: Path relative to the project root (e.g. \"pdf\" or \"reports/html\").\n\n    Returns:\n        Absolute Path to the ensured directory.\n\n    Raises:\n        SeretoValueError: If the path is absolute or escapes the project root.\n        SeretoPathError: If a non-directory object exists at the target path.\n    \"\"\"\n    rel = Path(relative_path)\n    if rel == Path(\"\") or rel == Path(\".\"):\n        return self.path\n\n    if rel.is_absolute():\n        raise SeretoValueError(\"relative_path must be relative, not absolute\")\n\n    dest = (self.path / rel).resolve()\n    project_root = self.path.resolve()\n\n    if not dest.is_relative_to(project_root):\n        raise SeretoValueError(\"relative_path points outside the project root\")\n\n    if dest.exists() and not dest.is_dir():\n        raise SeretoPathError(\"a non-directory object already exists at the requested path\")\n\n    if not dest.exists():\n        dest.mkdir(parents=True)\n\n    return dest\n</code></pre>"},{"location":"reference/project/#sereto.project.get_project_path_from_dir","title":"<code>get_project_path_from_dir(dir=None, dir_subtree=Path('/'))</code>","text":"<p>Get the path to the project directory.</p> <p>Start the search from the 'dir' directory and go up the directory tree until the project directory is found or 'dir_subtree' is reached.</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>DirectoryPath | None</code> <p>The directory to start the search from. Defaults to the current working directory.</p> <code>None</code> <code>dir_subtree</code> <code>DirectoryPath</code> <p>The directory to stop the search at. Defaults to the root directory.</p> <code>Path('/')</code> <p>Raises:</p> Type Description <code>SeretoPathError</code> <p>If the current working directory is not inside the project's (sub)directory.</p> <p>Returns:</p> Type Description <code>Path</code> <p>The path to the project directory.</p> Source code in <code>sereto/project.py</code> <pre><code>@validate_call\ndef get_project_path_from_dir(dir: DirectoryPath | None = None, dir_subtree: DirectoryPath = Path(\"/\")) -&gt; Path:\n    \"\"\"Get the path to the project directory.\n\n    Start the search from the 'dir' directory and go up the directory tree until the project directory is\n    found or 'dir_subtree' is reached.\n\n    Args:\n        dir: The directory to start the search from. Defaults to the current working directory.\n        dir_subtree: The directory to stop the search at. Defaults to the root directory.\n\n    Raises:\n        SeretoPathError: If the current working directory is not inside the project's (sub)directory.\n\n    Returns:\n        The path to the project directory.\n    \"\"\"\n    if dir is None:\n        dir = Path.cwd()\n\n    # start from the current working directory and go up the directory tree\n    for d in [dir] + list(dir.parents):\n        # if the current directory is inside the subtree\n        if d.is_relative_to(dir_subtree):\n            # if the current directory is a project directory\n            if is_project_dir(d):\n                return d\n        else:\n            # stop the search before leaving the subtree\n            break\n\n    raise SeretoPathError(\"Not inside project's (sub)directory\")\n</code></pre>"},{"location":"reference/project/#sereto.project.init_build_dir","title":"<code>init_build_dir(project, version_config=None, target=None)</code>","text":"<p>Initialize the build directory.</p> Source code in <code>sereto/project.py</code> <pre><code>@validate_call\ndef init_build_dir(\n    project: Project, version_config: VersionConfig | None = None, target: Target | None = None\n) -&gt; None:\n    \"\"\"Initialize the build directory.\"\"\"\n    if (version_config is None and target is None) or (version_config is not None and target is not None):\n        raise SeretoValueError(\"either 'version_config' or 'target' must be specified\")\n\n    # Ensure .build/ directory exists even when there are no targets\n    project.ensure_dir(\".build\")\n\n    # Create target directories in .build/\n    targets: list[Target] = [target] if target is not None else version_config.targets  # type: ignore[union-attr]\n    for target in targets:\n        project.ensure_dir(f\".build/{target.uname}\")\n</code></pre>"},{"location":"reference/project/#sereto.project.is_project_dir","title":"<code>is_project_dir(path)</code>","text":"<p>Check if the provided path is a root directory of a project.</p> <p>A project directory contains at least <code>.sereto</code> and <code>config.json</code> files.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to examine.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the path is a project directory, False otherwise.</p> Source code in <code>sereto/project.py</code> <pre><code>@validate_call\ndef is_project_dir(path: Path) -&gt; bool:\n    \"\"\"Check if the provided path is a root directory of a project.\n\n    A project directory contains at least `.sereto` and `config.json` files.\n\n    Args:\n        path: The path to examine.\n\n    Returns:\n        True if the path is a project directory, False otherwise.\n    \"\"\"\n    return path.is_dir() and path.exists() and (path / \".sereto\").is_file() and (path / \"config.json\").is_file()\n</code></pre>"},{"location":"reference/project/#sereto.project.new_project","title":"<code>new_project(projects_path, templates_path, risk_due_dates, id, name, people)</code>","text":"<p>Generates a new project with the specified ID.</p> <p>Parameters:</p> Name Type Description Default <code>projects_path</code> <code>DirectoryPath</code> <p>The path to the projects directory.</p> required <code>templates_path</code> <code>DirectoryPath</code> <p>The path to the templates directory.</p> required <code>risk_due_dates</code> <code>dict[Risk, timedelta]</code> <p>due dates for fixing the findings, for each risk level, as a timedelta</p> required <code>id</code> <code>TypeProjectId</code> <p>The ID of the new project. This should be a string that uniquely identifies the project.</p> required <code>name</code> <code>str</code> <p>The name of the new project.</p> required <code>people</code> <code>list[Person]</code> <p>Initial list of people from global settings.</p> required <p>Raises:</p> Type Description <code>SeretoValueError</code> <p>If a project with the specified ID already exists in the <code>projects</code> directory.</p> Source code in <code>sereto/project.py</code> <pre><code>@validate_call\ndef new_project(\n    projects_path: DirectoryPath,\n    templates_path: DirectoryPath,\n    risk_due_dates: dict[Risk, timedelta],\n    id: TypeProjectId,\n    name: str,\n    people: list[Person],\n) -&gt; None:\n    \"\"\"Generates a new project with the specified ID.\n\n    Args:\n        projects_path: The path to the projects directory.\n        templates_path: The path to the templates directory.\n        risk_due_dates: due dates for fixing the findings, for each risk level, as a timedelta\n        id: The ID of the new project. This should be a string that uniquely identifies the project.\n        name: The name of the new project.\n        people: Initial list of people from global settings.\n\n    Raises:\n        SeretoValueError: If a project with the specified ID already exists in the `projects` directory.\n    \"\"\"\n    logger.info(\"Generating a new project with ID '{}'\", id)\n\n    if (new_path := projects_path / id).exists():\n        raise SeretoPathError(\"project with specified ID already exists\")\n    elif not (skel_path := templates_path / \"skel\").is_dir():\n        raise SeretoPathError(f\"skel path '{skel_path}' does not exist or is not a directory\")\n    else:\n        new_path.mkdir()\n\n    sereto_ver = importlib.metadata.version(\"sereto\")\n\n    logger.info(\"Copying project skeleton\")\n    copy_skel(templates=templates_path, dst=new_path)\n\n    config_path = new_path / \"config.json\"\n\n    logger.info(\"Writing the config '{}'\", config_path)\n    Config(\n        sereto_version=SeretoVersion.from_str(sereto_ver),\n        version_configs={\n            ProjectVersion.from_str(\"v1.0\"): VersionConfig(\n                version=ProjectVersion.from_str(\"v1.0\"),\n                id=id,\n                name=name,\n                version_description=\"Initial\",\n                risk_due_dates=risk_due_dates,\n                people=people,\n            ),\n        },\n        path=config_path,\n        risk_due_dates=risk_due_dates,\n    ).save()\n</code></pre>"},{"location":"reference/project/#sereto.project.project_create_missing","title":"<code>project_create_missing(project, version_config)</code>","text":"<p>Creates missing content in the project.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>Project</code> <p>The project instance.</p> required <code>version_config</code> <code>VersionConfig</code> <p>Configuration for a specific project version.</p> required Source code in <code>sereto/project.py</code> <pre><code>@validate_call\ndef project_create_missing(project: Project, version_config: VersionConfig) -&gt; None:\n    \"\"\"Creates missing content in the project.\n\n    Args:\n        project: The project instance.\n        version_config: Configuration for a specific project version.\n    \"\"\"\n    # Initialize the build directory\n    init_build_dir(project=project, version_config=version_config)\n\n    project.ensure_dir(\"layouts/generated\")\n\n    for target in version_config.targets:\n        # Generate risks plot for the target\n        risks_plot(risks=target.findings.risks, path=project.path / \".build\" / target.uname / \"risks.png\")\n</code></pre>"},{"location":"reference/project/#sereto.project.resolve_project_directory","title":"<code>resolve_project_directory(projects_path, project_id, *, templates_path)</code>","text":"<p>Resolve a project identifier to an on-disk path.</p> <p>First match wins: if a directory with the exact name of <code>project_id</code> exists, it is returned. Otherwise, all project directories are scanned and their configurations loaded to find a matching project ID.</p> Source code in <code>sereto/project.py</code> <pre><code>@validate_call\ndef resolve_project_directory(\n    projects_path: DirectoryPath,\n    project_id: TypeProjectId,\n    *,\n    templates_path: DirectoryPath,\n) -&gt; Path:\n    \"\"\"Resolve a project identifier to an on-disk path.\n\n    First match wins: if a directory with the exact name of `project_id` exists, it is returned.\n    Otherwise, all project directories are scanned and their configurations loaded to find a matching project ID.\n    \"\"\"\n    direct_candidate = projects_path / project_id\n    if is_project_dir(direct_candidate):\n        return direct_candidate\n\n    for entry in projects_path.iterdir():\n        if not is_project_dir(entry) or entry == direct_candidate:\n            continue\n\n        try:\n            config = Config.load_from(\n                entry / \"config.json\",\n                templates=templates_path,\n                risk_due_dates={},\n            )\n        except (SeretoValueError, SeretoPathError):\n            continue\n\n        if any([config.at_version(ver).id == project_id for ver in config.versions]):\n            return entry\n\n    raise SeretoPathError(f\"project '{project_id}' does not exist. Use 'ls' to list all projects\")\n</code></pre>"},{"location":"reference/retest/","title":"Retest","text":""},{"location":"reference/retest/#sereto.retest","title":"<code>sereto.retest</code>","text":""},{"location":"reference/risk/","title":"Risk","text":""},{"location":"reference/risk/#sereto.risk","title":"<code>sereto.risk</code>","text":""},{"location":"reference/sereto_types/","title":"Sereto types","text":""},{"location":"reference/sereto_types/#sereto.sereto_types","title":"<code>sereto.sereto_types</code>","text":""},{"location":"reference/sereto_types/#sereto.sereto_types.TypeCategories","title":"<code>TypeCategories = list[TypeCategoryName]</code>  <code>module-attribute</code>","text":"<p>Type for set of categories.</p> <p>The values should meet the following requirements:</p> <ul> <li>It can only contain letters (<code>a-zA-Z</code>), numbers (<code>0-9</code>), underscore (<code>_</code>), dash (<code>-</code>), and dot (<code>.</code>).</li> <li>It should be between 1 and 20 characters long.</li> </ul> Example <p>You can provide values such as <code>dast</code>, <code>sast</code> (or <code>DAST</code>, <code>SAST</code>), etc.</p>"},{"location":"reference/sereto_types/#sereto.sereto_types.TypeCategoryName","title":"<code>TypeCategoryName = Annotated[str, StringConstraints(pattern='^[a-zA-Z0-9._-]{1,20}$', strict=True)]</code>  <code>module-attribute</code>","text":"<p>Type for category name.</p> <p>The value should meet the following requirements:</p> <ul> <li>It can only contain letters (<code>a-zA-Z</code>), numbers (<code>0-9</code>), underscore (<code>_</code>), dash (<code>-</code>), and dot (<code>.</code>).</li> <li>It should be between 1 and 20 characters long.</li> </ul>"},{"location":"reference/sereto_types/#sereto.sereto_types.TypeNonce12B","title":"<code>TypeNonce12B = Annotated[SecretBytes, Len(12, 12), Strict(), AfterValidator(zero_bytes)]</code>  <code>module-attribute</code>","text":"<p>Type for a 12 byte long nonce.</p> <p>Using SecretBytes prevents the nonce from being printed in logs or tracebacks.</p> <p>The value must contain at least one non-zero byte. This check is in place to prevent unintentional errors.</p>"},{"location":"reference/sereto_types/#sereto.sereto_types.TypePassword","title":"<code>TypePassword = Annotated[SecretStr, Strict(), Len(8, 100)]</code>  <code>module-attribute</code>","text":"<p>Type for password.</p> <p>Using SecretStr prevents the password from being printed in logs or tracebacks.</p> <p>The value should meet the following requirements:</p> <ul> <li>It should be between 8 and 100 characters long.</li> </ul>"},{"location":"reference/sereto_types/#sereto.sereto_types.TypePathName","title":"<code>TypePathName = Annotated[str, StringConstraints(pattern='^[a-zA-Z0-9._-]{1,100}$', strict=True)]</code>  <code>module-attribute</code>","text":"<p>Type for path name.</p> <p>The value should meet the following requirements:</p> <ul> <li>It can only contain letters (<code>a-zA-Z</code>), numbers (<code>0-9</code>), underscore (<code>_</code>), dash (<code>-</code>), and dot (<code>.</code>).</li> <li>It should be between 1 and 100 characters long.</li> </ul>"},{"location":"reference/sereto_types/#sereto.sereto_types.TypeProjectId","title":"<code>TypeProjectId = Annotated[str, StringConstraints(pattern='^[a-zA-Z0-9._-]{1,20}$', strict=True)]</code>  <code>module-attribute</code>","text":"<p>Type for project ID.</p> <p>The value should meet the following requirements:</p> <ul> <li>It can only contain letters (<code>a-zA-Z</code>), numbers (<code>0-9</code>), underscore (<code>_</code>), dash (<code>-</code>), and dot (<code>.</code>).</li> <li>It should be between 1 and 20 characters long.</li> </ul>"},{"location":"reference/sereto_types/#sereto.sereto_types.TypeSalt16B","title":"<code>TypeSalt16B = Annotated[SecretBytes, Len(16, 16), Strict(), AfterValidator(zero_bytes)]</code>  <code>module-attribute</code>","text":"<p>Type for a 16 byte long salt.</p> <p>Using SecretBytes prevents the salt from being printed in logs or tracebacks.</p> <p>The value must contain at least one non-zero byte. This check is in place to prevent unintentional errors.</p>"},{"location":"reference/settings/","title":"Settings","text":""},{"location":"reference/settings/#sereto.settings","title":"<code>sereto.settings</code>","text":""},{"location":"reference/settings/#sereto.settings.write_settings","title":"<code>write_settings(settings)</code>","text":"<p>Write settings to a standard system location.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>Settings</code> <p>The Settings object to write.</p> required Source code in <code>sereto/settings.py</code> <pre><code>@validate_call\ndef write_settings(settings: Settings) -&gt; None:\n    \"\"\"Write settings to a standard system location.\n\n    Args:\n        settings: The Settings object to write.\n    \"\"\"\n    settings_path = Settings.get_path()\n    settings_path.parent.mkdir(parents=True, exist_ok=True)\n\n    with settings_path.open(\"w\", encoding=\"utf-8\") as f:\n        f.write(settings.model_dump_json(indent=2, exclude_defaults=True))\n        f.write(\"\\n\")\n</code></pre>"},{"location":"reference/singleton/","title":"Singleton","text":""},{"location":"reference/singleton/#sereto.singleton","title":"<code>sereto.singleton</code>","text":""},{"location":"reference/source_archive/","title":"Source archive","text":""},{"location":"reference/source_archive/#sereto.source_archive","title":"<code>sereto.source_archive</code>","text":""},{"location":"reference/source_archive/#sereto.source_archive.create_source_archive","title":"<code>create_source_archive(project_path, config)</code>","text":"<p>Create a source archive for the project.</p> <p>This function creates a source archive for the project by copying all the files not matching any ignore pattern in the project directory to a compressed archive file. The archive is encrypted if the password is set in the system's keyring.</p> <p>Parameters:</p> Name Type Description Default <code>project_path</code> <code>DirectoryPath</code> <p>The path to the project directory.</p> required <code>config</code> <code>Config</code> <p>The configuration object..</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The path to the created source archive.</p> Source code in <code>sereto/source_archive.py</code> <pre><code>@validate_call\ndef create_source_archive(project_path: DirectoryPath, config: Config) -&gt; Path:\n    \"\"\"Create a source archive for the project.\n\n    This function creates a source archive for the project by copying all the files not matching any ignore pattern in\n    the project directory to a compressed archive file. The archive is encrypted if the password is set in the system's\n    keyring.\n\n    Args:\n        project_path: The path to the project directory.\n        config: The configuration object..\n\n    Returns:\n        The path to the created source archive.\n    \"\"\"\n    # Read the ignore patterns from the '.seretoignore' file\n    if (seretoignore_path := project_path / \".seretoignore\").is_file():\n        assert_file_size_within_range(file=seretoignore_path, max_bytes=10_485_760, interactive=True)\n\n        with seretoignore_path.open(\"r\") as seretoignore:\n            ignore_lines = seretoignore.readlines()\n    else:\n        logger.warning(\"File '{}' does not exist\", seretoignore_path)\n        ignore_lines = []\n\n    # Create a temporary file to store the source archive\n    with NamedTemporaryFile(suffix=\".tgz\", delete=False) as tmp:\n        archive_path = Path(tmp.name)\n\n        logger.info(\"Creating source archive at '{}'\", archive_path)\n\n        # Determine the original project ID (store the project always with the original ID)\n        original_id = config.first_config.id\n\n        # Create the source archive\n        with tarfile.open(archive_path, \"w:gz\") as tar:\n            for item in project_path.rglob(\"*\"):\n                relative_path = item.relative_to(project_path)\n\n                if not item.is_file() or item.is_symlink():\n                    logger.info(\n                        \"[yellow]-[/yellow] Skipping directory or symlink: '{}'\",\n                        escape(str(relative_path)),\n                        markup=True,\n                    )\n                    continue\n\n                if _is_ignored(str(relative_path), ignore_lines):\n                    logger.info(\"[yellow]-[/yellow] Skipping item: '{}'\", escape(str(relative_path)), markup=True)\n                    continue\n\n                logger.info(\"[green]+[/green] Adding item: '{}'\", escape(str(relative_path)), markup=True)\n                tar.add(item, arcname=str(Path(original_id) / item.relative_to(project_path)))\n\n    try:\n        return encrypt_file(archive_path)\n    except SeretoEncryptionError:\n        return archive_path\n</code></pre>"},{"location":"reference/source_archive/#sereto.source_archive.embed_attachment_to_pdf","title":"<code>embed_attachment_to_pdf(pdf, attachment, name=None, keep_original=True)</code>","text":"<p>Embed the attachment to the PDF.</p> <p>Parameters:</p> Name Type Description Default <code>pdf</code> <code>FilePath</code> <p>The path to the PDF file where the attachment will be embedded.</p> required <code>attachment</code> <code>FilePath</code> <p>The path to the attahcment.</p> required <code>name</code> <code>str | None</code> <p>The name of the attachment in the PDF. If None, the attachment's name is used. Defaults to None.</p> <code>None</code> <code>keep_original</code> <code>bool</code> <p>If True, the original source archive is kept. Defaults to True.</p> <code>True</code> Source code in <code>sereto/source_archive.py</code> <pre><code>@validate_call\ndef embed_attachment_to_pdf(\n    pdf: FilePath, attachment: FilePath, name: str | None = None, keep_original: bool = True\n) -&gt; None:\n    \"\"\"Embed the attachment to the PDF.\n\n    Args:\n        pdf: The path to the PDF file where the attachment will be embedded.\n        attachment: The path to the attahcment.\n        name: The name of the attachment in the PDF. If None, the attachment's name is used. Defaults to None.\n        keep_original: If True, the original source archive is kept. Defaults to True.\n    \"\"\"\n    # Initialize PDF reader and writer\n    reader = PdfReader(pdf, strict=True)\n    writer = PdfWriter()\n\n    # Copy content from the reader to the writer\n    writer.append(reader)\n\n    # Embed the source archive\n    attachment_name = name if name is not None else attachment.name\n    writer.add_attachment(filename=attachment_name, data=attachment.read_bytes())\n\n    # Write the output PDF\n    with pdf.open(\"wb\") as output_pdf:\n        writer.write(output_pdf)\n        logger.info(\n            \"[green]+[/green] Embedded attachment '{}' into '{}'\",\n            escape(attachment.name),\n            escape(str(pdf)),\n            markup=True,\n        )\n\n    # Delete the source archive if `keep_original=False`\n    if not keep_original:\n        attachment.unlink()\n        logger.info(\"[red]-[/red] Deleted original file: '{}'\", escape(str(attachment)), markup=True)\n</code></pre>"},{"location":"reference/source_archive/#sereto.source_archive.extract_source_archive","title":"<code>extract_source_archive(file, output_dir, keep_original=True)</code>","text":"<p>Extracts the project sources from a given tarball file.</p> <p>Expects the tarball file to be Gzip-compressed.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>FilePath</code> <p>The path to the .tgz file.</p> required <code>output_dir</code> <code>DirectoryPath</code> <p>The directory where the sources will be extracted.</p> required <code>keep_original</code> <code>bool</code> <p>If True, the original tarball file is kept. Defaults to True.</p> <code>True</code> Source code in <code>sereto/source_archive.py</code> <pre><code>@validate_call\ndef extract_source_archive(file: FilePath, output_dir: DirectoryPath, keep_original: bool = True) -&gt; None:\n    \"\"\"Extracts the project sources from a given tarball file.\n\n    Expects the tarball file to be Gzip-compressed.\n\n    Args:\n        file: The path to the .tgz file.\n        output_dir: The directory where the sources will be extracted.\n        keep_original: If True, the original tarball file is kept. Defaults to True.\n    \"\"\"\n    logger.info(\"Extracting archive ...\")\n\n    with tarfile.open(file, \"r:gz\") as tar:\n        # Check for empty source archive\n        if len(tar.getmembers()) == 0:\n            logger.warning(\"Empty source archive: '{}'\", file)\n            return\n\n        # Get the common directory in the tar archive\n        common_dir = Path(commonpath(tar.getnames()))\n\n        # There should always be a top level directory with the project ID\n        if len(common_dir.parts) == 0:\n            raise SeretoValueError(\"corrupted source archive (multiple top-level directories found)\") from None\n\n        # Validate project ID\n        try:\n            ta_id: TypeAdapter[TypeProjectId] = TypeAdapter(TypeProjectId)  # hack for mypy\n            project_id = ta_id.validate_python(common_dir.parts[0])\n        except ValidationError as e:\n            raise SeretoValueError(\"corrupted source archive (invalid project ID)\") from e\n\n        # Check that this is a valid sereto project\n        try:\n            tar.getmember(f\"{project_id}/.sereto\")\n            tar.getmember(f\"{project_id}/config.json\")\n        except KeyError:\n            raise SeretoValueError(\"corrupted source archive (missing core project files)\") from None\n\n        logger.info(\"Detected project with ID: {}\", project_id)\n\n        # Make sure the project directory does not already exist\n        if (output_dir / project_id).exists():\n            raise SeretoPathError(f\"project directory already exists: '{output_dir / project_id}'\")\n\n        # Extract the source archive\n        tar.extractall(path=output_dir, filter=\"data\")\n        logger.info(\n            \"[green]+[/green] Extracted sources from '{}' to '{}'\",\n            escape(str(file)),\n            escape(str(output_dir / project_id)),\n            markup=True,\n        )\n\n    # Delete the original tarball\n    if not keep_original:\n        file.unlink()\n        logger.info(\"[red]-[/red] Deleted tarball: '{}'\", escape(str(file)), markup=True)\n</code></pre>"},{"location":"reference/source_archive/#sereto.source_archive.retrieve_source_archive","title":"<code>retrieve_source_archive(pdf, name)</code>","text":"<p>Extracts an attachment from a given PDF file and writes it to a temporary file.</p> <p>Parameters:</p> Name Type Description Default <code>pdf</code> <code>FilePath</code> <p>The path to the PDF file from which to extract the attachment.</p> required <code>name</code> <code>str</code> <p>The name of the attachment to extract.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The path to the temporary file containing the extracted attachment.</p> <p>Raises:</p> Type Description <code>SeretoValueError</code> <p>If no or multiple attachments with the same name are found in the PDF.</p> Source code in <code>sereto/source_archive.py</code> <pre><code>@validate_call\ndef retrieve_source_archive(pdf: FilePath, name: str) -&gt; Path:\n    \"\"\"Extracts an attachment from a given PDF file and writes it to a temporary file.\n\n    Args:\n        pdf: The path to the PDF file from which to extract the attachment.\n        name: The name of the attachment to extract.\n\n    Returns:\n        The path to the temporary file containing the extracted attachment.\n\n    Raises:\n        SeretoValueError: If no or multiple attachments with the same name are found in the PDF.\n    \"\"\"\n    if not pdf.is_file():\n        raise SeretoPathError(f\"file not found: '{pdf}'\")\n\n    # Read the PDF file\n    reader = PdfReader(pdf, strict=True)\n\n    # Check if the attachment is present\n    if name not in reader.attachments:\n        logger.error(\"No '{}' attachment found in '{}'\", name, pdf)\n        logger.info(\"Manually inspect the file to make sure the attachment '{}' is present\", name)\n        raise SeretoValueError(f\"no '{name}' attachment found in '{pdf}'\")\n\n    # PDF attachment names are not unique; check if there is only one attachment with the expected name\n    if len(reader.attachments[name]) != 1:\n        logger.warning(\"Only a single '{}' attachment should be present\", name)\n        logger.info(\"Manually extract the correct file and use `sereto decrypt` command instead\")\n        raise SeretoValueError(f\"multiple '{name}' attachments found\")\n\n    # Extract the attachment's content\n    content: bytes = reader.attachments[name][0]\n\n    # Write the content to a temporary file\n    with NamedTemporaryFile(suffix=Path(name).suffix if \".\" in name else None, delete=False) as tmp:\n        output_file = Path(tmp.name)\n        output_file.write_bytes(content)\n\n    logger.info(\n        \"[green]+[/green] Extracted attachment '{}' from '{}' to '{}'\",\n        escape(name),\n        escape(str(pdf)),\n        escape(str(output_file)),\n        markup=True,\n    )\n\n    return output_file\n</code></pre>"},{"location":"reference/target/","title":"Target","text":""},{"location":"reference/target/#sereto.target","title":"<code>sereto.target</code>","text":""},{"location":"reference/target/#sereto.target.Target","title":"<code>Target</code>  <code>dataclass</code>","text":"Source code in <code>sereto/target.py</code> <pre><code>@dataclass\nclass Target:\n    data: TargetModel\n    findings: Findings\n    path: DirectoryPath\n    version: ProjectVersion\n\n    @classmethod\n    @validate_call\n    def load(cls, data: TargetModel, path: DirectoryPath, version: ProjectVersion, templates: DirectoryPath) -&gt; Self:\n        return cls(\n            data=data,\n            findings=Findings.load_from(target_dir=path, target_locators=data.locators, templates=templates),\n            path=path,\n            version=version,\n        )\n\n    @classmethod\n    @validate_call\n    def new(\n        cls, data: TargetModel, project_path: DirectoryPath, templates: DirectoryPath, version: ProjectVersion\n    ) -&gt; Self:\n        target_path = project_path / (data.uname + version.path_suffix)\n\n        logger.info(\"Creating target directory: '{}'\", target_path)\n        target_path.mkdir()\n\n        category_templates = templates / \"categories\" / data.category\n\n        if (category_templates / \"skel\").is_dir():\n            logger.info(\"Populating new target directory from: '{}'\", category_templates / \"skel\")\n            copy_skel(templates=category_templates, dst=target_path)\n        else:\n            logger.warning(\"No 'skel' directory found: '{}'\", category_templates)\n\n        return cls.load(data=data, path=target_path, version=version, templates=templates)\n\n    @validate_call\n    def to_model(self) -&gt; TargetModel:\n        return self.data\n\n    @property\n    def uname(self) -&gt; str:\n        \"\"\"Unique name for the target instance.\n\n        Returns:\n            The unique name of the target.\n        \"\"\"\n        return self.data.uname + self.version.path_suffix\n\n    @validate_call\n    def filter_locators(self, type: str | Iterable[str]) -&gt; list[LocatorModel]:\n        \"\"\"Filter locators by type.\n\n        Args:\n            type: The type of locators to filter by. Can be a single type or an iterable of types.\n\n        Returns:\n            A list of locators of the specified type.\n        \"\"\"\n        type = [type] if isinstance(type, str) else list(type)\n        return [loc for loc in self.data.locators if loc.type in type]\n</code></pre>"},{"location":"reference/target/#sereto.target.Target.uname","title":"<code>uname</code>  <code>property</code>","text":"<p>Unique name for the target instance.</p> <p>Returns:</p> Type Description <code>str</code> <p>The unique name of the target.</p>"},{"location":"reference/target/#sereto.target.Target.filter_locators","title":"<code>filter_locators(type)</code>","text":"<p>Filter locators by type.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str | Iterable[str]</code> <p>The type of locators to filter by. Can be a single type or an iterable of types.</p> required <p>Returns:</p> Type Description <code>list[LocatorModel]</code> <p>A list of locators of the specified type.</p> Source code in <code>sereto/target.py</code> <pre><code>@validate_call\ndef filter_locators(self, type: str | Iterable[str]) -&gt; list[LocatorModel]:\n    \"\"\"Filter locators by type.\n\n    Args:\n        type: The type of locators to filter by. Can be a single type or an iterable of types.\n\n    Returns:\n        A list of locators of the specified type.\n    \"\"\"\n    type = [type] if isinstance(type, str) else list(type)\n    return [loc for loc in self.data.locators if loc.type in type]\n</code></pre>"},{"location":"reference/utils/","title":"Utils","text":""},{"location":"reference/utils/#sereto.utils","title":"<code>sereto.utils</code>","text":""},{"location":"reference/utils/#sereto.utils.assert_file_size_within_range","title":"<code>assert_file_size_within_range(file, max_bytes, min_bytes=0, interactive=False)</code>","text":"<p>Evaluates if the file size is within the specified range.</p> <p>If <code>interactive</code> is True, the user is first prompted whether to continue if the file size is not within the range.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>FilePath</code> <p>The path to the file.</p> required <code>max_bytes</code> <code>int</code> <p>The maximum file size in bytes.</p> required <code>min_bytes</code> <code>int</code> <p>The minimum file size in bytes. Defaults to 0.</p> <code>0</code> <code>interactive</code> <code>bool</code> <p>If True, the user is prompted whether to continue if the file size is not within the range. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>SeretoPathError</code> <p>If the file does not exist.</p> <code>SeretoValueError</code> <p>If the file size is not within the specified range.</p> Source code in <code>sereto/utils.py</code> <pre><code>@validate_call\ndef assert_file_size_within_range(\n    file: FilePath, max_bytes: int, min_bytes: int = 0, interactive: bool = False\n) -&gt; None:\n    \"\"\"Evaluates if the file size is within the specified range.\n\n    If `interactive` is True, the user is first prompted whether to continue if the file size is not within the range.\n\n    Args:\n        file: The path to the file.\n        max_bytes: The maximum file size in bytes.\n        min_bytes: The minimum file size in bytes. Defaults to 0.\n        interactive: If True, the user is prompted whether to continue if the file size is not within the range.\n            Defaults to False.\n\n    Raises:\n        SeretoPathError: If the file does not exist.\n        SeretoValueError: If the file size is not within the specified range.\n    \"\"\"\n    # Check the input values\n    if not file.is_file():\n        raise SeretoPathError(f\"File '{file}' does not exist\")\n\n    if not 0 &lt;= min_bytes &lt;= max_bytes:\n        raise SeretoValueError(f\"Invalid size threshold range: {min_bytes} - {max_bytes}\")\n\n    # Get the file size in bytes\n    size = file.stat().st_size\n\n    # Check if the file size is within the specified range\n    if min_bytes &lt;= size &lt;= max_bytes:\n        return\n\n    # File size is not within the range\n\n    logger.warning(\n        \"File '{}' size is {}, which is outside the allowed range {} - {}\",\n        file,\n        naturalsize(size, binary=True),\n        naturalsize(min_bytes, binary=True),\n        naturalsize(max_bytes, binary=True),\n    )\n\n    # In interactive mode, user can choose to continue\n    if interactive and click.confirm(\"Do you want to continue?\", default=False):\n        return\n\n    # Otherwise, raise an error\n    raise SeretoValueError(f\"File '{file}' size is not within the range {min_bytes} - {max_bytes} B\")\n</code></pre>"},{"location":"reference/utils/#sereto.utils.copy_skel","title":"<code>copy_skel(templates, dst, overwrite=False)</code>","text":"<p>Copy the content of a templates <code>skel</code> directory to a destination directory.</p> <p>A <code>skel</code> directory is a directory that contains a set of files and directories that can be used as a template for creating new projects. This function copies the contents of the <code>skel</code> directory located at the path specified by <code>templates</code> to the destination directory specified by <code>dst</code>.</p> <p>Parameters:</p> Name Type Description Default <code>templates</code> <code>DirectoryPath</code> <p>The path to the directory containing the <code>skel</code> directory.</p> required <code>dst</code> <code>DirectoryPath</code> <p>The destination directory to copy the <code>skel</code> directory contents to.</p> required <code>overwrite</code> <code>bool</code> <p>Whether to allow overwriting of existing files in the destination directory. If <code>True</code>, existing files will be overwritten. If <code>False</code> (default), a <code>SeretoPathError</code> will be raised if the destination already exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>SeretoPathError</code> <p>If the destination directory already exists and <code>overwrite</code> is <code>False</code>.</p> Source code in <code>sereto/utils.py</code> <pre><code>@validate_call\ndef copy_skel(templates: DirectoryPath, dst: DirectoryPath, overwrite: bool = False) -&gt; None:\n    \"\"\"Copy the content of a templates `skel` directory to a destination directory.\n\n    A `skel` directory is a directory that contains a set of files and directories that can be used as a template\n    for creating new projects. This function copies the contents of the `skel` directory located at\n    the path specified by `templates` to the destination directory specified by `dst`.\n\n    Args:\n        templates: The path to the directory containing the `skel` directory.\n        dst: The destination directory to copy the `skel` directory contents to.\n        overwrite: Whether to allow overwriting of existing files in the destination directory.\n            If `True`, existing files will be overwritten. If `False` (default), a `SeretoPathError` will be raised\n            if the destination already exists.\n\n    Raises:\n        SeretoPathError: If the destination directory already exists and `overwrite` is `False`.\n    \"\"\"\n    skel_path: Path = templates / \"skel\"\n\n    logger.info(\"Copying 'skel' directory: '{}' -&gt; '{}'\", skel_path, dst)\n\n    for item in skel_path.iterdir():\n        dst_item: Path = dst / (item.relative_to(skel_path))\n        if not overwrite and dst_item.exists():\n            raise SeretoPathError(\"Destination already exists\")\n        if item.is_file():\n            logger.info(\"[green]+[/green] copy file: '{}'\", escape(str(item.relative_to(skel_path))), markup=True)\n            copy2(item, dst_item, follow_symlinks=False)\n        if item.is_dir():\n            logger.info(\"[green]+[/green] copy dir: '{}'\", escape(str(item.relative_to(skel_path))), markup=True)\n            copytree(item, dst_item, dirs_exist_ok=overwrite)\n</code></pre>"},{"location":"reference/utils/#sereto.utils.lower_alphanum","title":"<code>lower_alphanum(text)</code>","text":"<p>Converts the input text to lowercase alphanumerical delimited by underscores.</p> <p>Also all spaces are replaced with underscores.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The input text with the modifications applied.</p> Source code in <code>sereto/utils.py</code> <pre><code>@validate_call\ndef lower_alphanum(text: str) -&gt; str:\n    \"\"\"Converts the input text to lowercase alphanumerical delimited by underscores.\n\n    Also all spaces are replaced with underscores.\n\n    Args:\n        text: The input text.\n\n    Returns:\n        The input text with the modifications applied.\n    \"\"\"\n    normalized = unicodedata.normalize(\"NFKD\", text)\n    ascii_text = normalized.encode(\"ascii\", \"ignore\").decode(\"ascii\").lower()\n    ascii_text = re.sub(r\"[^a-z0-9_\\s]\", \"\", ascii_text)\n    return re.sub(r\"\\s+\", \"_\", ascii_text)\n</code></pre>"},{"location":"reference/utils/#sereto.utils.replace_strings","title":"<code>replace_strings(text, replacements)</code>","text":"<pre><code>replace_strings(text: str, replacements: dict[str, str]) -&gt; str\n</code></pre><pre><code>replace_strings(text: list[str], replacements: dict[str, str]) -&gt; list[str]\n</code></pre> <p>One-pass string replacement with values from dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | list[str]</code> <p>The input text.</p> required <code>replacements</code> <code>dict[str, str]</code> <p>Dictionary with replacements. Key-value in dictionary refers to pattern string and replacement string, respectively.</p> required <p>Returns:</p> Type Description <code>str | list[str]</code> <p>String (or list of strings, depending on the input value) obtained by applying the replacements from the <code>replacements</code> dictionary.</p> Source code in <code>sereto/utils.py</code> <pre><code>@validate_call\ndef replace_strings(text: str | list[str], replacements: dict[str, str]) -&gt; str | list[str]:\n    \"\"\"One-pass string replacement with values from dictionary.\n\n    Args:\n        text: The input text.\n        replacements: Dictionary with replacements. Key-value in dictionary refers to pattern string and replacement\n            string, respectively.\n\n    Returns:\n        String (or list of strings, depending on the input value) obtained by applying the replacements from the\n            `replacements` dictionary.\n    \"\"\"\n\n    @validate_call\n    def _clip(value: str, max_chars: Annotated[int, Field(ge=3)] = 120) -&gt; str:\n        return value if len(value) &lt;= max_chars else f\"{value[: max_chars - 3]}...\"\n\n    @validate_call\n    def _preview_text(\n        value: str | list[str],\n        max_chars: Annotated[int, Field(ge=1)] = 120,\n        max_items: Annotated[int, Field(ge=1)] = 5,\n    ) -&gt; str:\n        if isinstance(value, str):\n            return _clip(value, max_chars=max_chars)\n        items: list[str] = []\n        for idx, item in enumerate(value):\n            if idx &gt;= max_items:\n                items.append(f\"... (+{len(value) - max_items} more)\")\n                break\n            items.append(_clip(item, max_chars=max_chars))\n        return f\"[{', '.join(items)}]\"\n\n    @validate_call\n    def _preview_replacements(\n        max_items: Annotated[int, Field(ge=1)] = 5, max_chars: Annotated[int, Field(ge=3)] = 80\n    ) -&gt; str:\n        pairs: list[str] = []\n        for idx, (pattern_key, pattern_value) in enumerate(replacements.items()):\n            if idx &gt;= max_items:\n                pairs.append(f\"... (+{len(replacements) - max_items} more)\")\n                break\n            pairs.append(f\"{_clip(pattern_key, max_chars=max_chars)}-&gt;{_clip(pattern_value, max_chars=max_chars)}\")\n        return \", \".join(pairs)\n\n    text_len = len(text)\n    replacements_count = len(replacements)\n\n    logger.trace(\n        \"replace_strings called (text_type={}, text_len={}, replacements_count={}, text_preview='{}', \"\n        \"replacements_preview={})\",\n        type(text).__name__,\n        text_len,\n        replacements_count,\n        _preview_text(text),\n        _preview_replacements(),\n    )\n\n    if text_len == 0 or replacements_count == 0:\n        logger.debug(\n            \"replace_strings returning input unchanged (text_len={}, replacements={})\",\n            text_len,\n            replacements_count,\n        )\n        return text\n\n    pattern_source = \"|\".join([re.escape(rep) for rep in replacements])\n    pattern = re.compile(pattern_source)\n\n    if isinstance(text, str):\n        result = pattern.sub(lambda match: replacements[match.group(0)], text)\n        logger.trace(\n            \"replace_strings applied to string (before_len={}, after_len={}, replacements={}, before_preview='{}', \"\n            \"after_preview='{}')\",\n            len(text),\n            len(result),\n            replacements_count,\n            _preview_text(text),\n            _preview_text(result),\n        )\n        return result\n\n    result_list = [pattern.sub(lambda match: replacements[match.group(0)], item) for item in text]\n    changed = sum(1 for original, updated in zip(text, result_list, strict=True) if original != updated)\n    logger.debug(\n        \"replace_strings applied to list[str] (items={}, changed={}, replacements={}, before_preview={}, \"\n        \"after_preview={})\",\n        len(result_list),\n        changed,\n        replacements_count,\n        _preview_text(text),\n        _preview_text(result_list),\n    )\n    return result_list\n</code></pre>"},{"location":"reference/utils/#sereto.utils.write_if_different","title":"<code>write_if_different(file, content)</code>","text":"<p>Writes content to file only if the content is different from the existing file content.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path</code> <p>The path to the file.</p> required <code>content</code> <code>str</code> <p>The content to write to the file.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if new content was written to the file, False otherwise.</p> Source code in <code>sereto/utils.py</code> <pre><code>@validate_call\ndef write_if_different(file: Path, content: str) -&gt; bool:\n    \"\"\"Writes content to file only if the content is different from the existing file content.\n\n    Args:\n        file: The path to the file.\n        content: The content to write to the file.\n\n    Returns:\n        True if new content was written to the file, False otherwise.\n    \"\"\"\n    # Check if the file exists and has the same size\n    if file.is_file() and file.stat().st_size == len(content):\n        assert_file_size_within_range(file=file, max_bytes=104_857_600)  # 100 MiB\n        # Check if the content is the same\n        if file.read_text(encoding=\"utf-8\") == content:\n            return False\n\n    # Changes detected, write the content to the file\n    file.write_text(content, encoding=\"utf-8\")\n    return True\n</code></pre>"},{"location":"reference/cli/cli/","title":"CLI","text":""},{"location":"reference/cli/cli/#sereto.cli.cli","title":"<code>sereto.cli.cli</code>","text":""},{"location":"reference/cli/cli/#sereto.cli.cli.clean","title":"<code>clean(ctx)</code>","text":"<p>Delete auxilary files created during the PDF build.</p> Source code in <code>sereto/cli/cli.py</code> <pre><code>@cli.command()\n@click.pass_obj\ndef clean(ctx: Project) -&gt; None:\n    \"\"\"Delete auxilary files created during the PDF build.\"\"\"\n    if (build_dir := ctx.path / \".build\").is_dir():\n        shutil.rmtree(build_dir)\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.cli","title":"<code>cli(ctx, log_level)</code>","text":"<p>Security Reporting Tool.</p> <p>This tool provides various commands for managing and generating security reports.</p> Source code in <code>sereto/cli/cli.py</code> <pre><code>@click.group(cls=AliasedGroup, context_settings={\"help_option_names\": [\"-h\", \"--help\"]})\n@click.version_option(version=importlib.metadata.version(\"sereto\"))\n@click.option(\n    \"--log-level\",\n    \"log_level\",\n    default=os.getenv(\"SERETO_LOG_LEVEL\", LogLevel.INFO),\n    type=click.Choice([level.value for level in LogLevel], case_sensitive=False),\n    show_default=True,\n    help=\"Set log verbosity for terminal output.\",\n)\n@click.pass_context\ndef cli(ctx: click.Context, log_level: LogLevel) -&gt; None:\n    \"\"\"Security Reporting Tool.\n\n    This tool provides various commands for managing and generating security reports.\n    \"\"\"\n    setup_logging(log_level)\n    ctx.obj = Project()\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.cli_pdf_finding_group","title":"<code>cli_pdf_finding_group(ctx, target_selector, finding_group_selector, converter, renderer, version, all)</code>","text":"<p>Generate a finding group PDF.\f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required <code>target_selector</code> <code>int | str | None</code> <p>The target for which the finding group is being generated.</p> required <code>finding_group_selector</code> <code>int | str | None</code> <p>The finding group to be generated.</p> required <code>converter</code> <code>str | None</code> <p>The recipe for converting the findings.</p> required <code>renderer</code> <code>str | None</code> <p>The recipe for building TeX.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The version of the configuration to use. If None, the last version is used.</p> required <code>all</code> <code>bool</code> <p>Flag to render all finding groups (exclusive with selectors).</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@pdf.command(name=\"finding-group\")\n@handle_exceptions\n@click.option(\"-ts\", \"--target-selector\", help=\"Target selector.\")\n@click.option(\"-fs\", \"--finding-group-selector\", help=\"Finding group selector.\")\n@click.option(\"-c\", \"--converter\", help=\"Convert finding recipe\")\n@click.option(\"-r\", \"--renderer\", help=\"Build TeX finding recipe\")\n@click.option(\"-v\", \"--version\", help=\"Use config at specific version, e.g. 'v1.0'.\")\n@click.option(\n    \"-a\",\n    \"--all\",\n    is_flag=True,\n    default=False,\n    help=\"Render all finding groups (mutually exclusive with --target-selector / --finding-group-selector).\",\n)\n@click.pass_obj\n@validate_call\ndef cli_pdf_finding_group(\n    ctx: Project,\n    target_selector: int | str | None,\n    finding_group_selector: int | str | None,\n    converter: str | None,\n    renderer: str | None,\n    version: ProjectVersion | None,\n    all: bool,\n) -&gt; None:\n    \"\"\"Generate a finding group PDF.\\f\n\n    Args:\n        ctx: Project's representation.\n        target_selector: The target for which the finding group is being generated.\n        finding_group_selector: The finding group to be generated.\n        converter: The recipe for converting the findings.\n        renderer: The recipe for building TeX.\n        version: The version of the configuration to use. If None, the last version is used.\n        all: Flag to render all finding groups (exclusive with selectors).\n    \"\"\"\n    # Exclusivity checks\n    if all and (target_selector is not None or finding_group_selector is not None):\n        raise SeretoValueError(\"--all cannot be used together with --target-selector or --finding-group-selector\")\n\n    if all:\n        generate_all_pdf_finding_groups(project=ctx, converter=converter, renderer=renderer, version=version)\n    else:\n        find_and_generate_pdf_finding_group(\n            project=ctx,\n            target_selector=target_selector,\n            finding_group_selector=finding_group_selector,\n            converter=converter,\n            renderer=renderer,\n            version=version,\n        )\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.cli_pdf_report","title":"<code>cli_pdf_report(ctx, convert_recipe, report_recipe, template, version)</code>","text":"<p>Generate a report PDF.\f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required <code>convert_recipe</code> <code>str | None</code> <p>The recipe for converting the findings.</p> required <code>report_recipe</code> <code>str | None</code> <p>The recipe for building the TeX report.</p> required <code>template</code> <code>str</code> <p>The template for the report.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The version of the configuration to use. If None, the last version is used.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@pdf.command(name=\"report\")\n@handle_exceptions\n@click.option(\"-c\", \"--convert-recipe\", help=\"Convert finding recipe.\")\n@click.option(\"-r\", \"--report-recipe\", help=\"Build TeX report recipe.\")\n@click.option(\"-t\", \"--template\", default=\"report\", help=\"Template for the report.\")\n@click.option(\"-v\", \"--version\", help=\"Use config at specific version, e.g. 'v1.0'.\")\n# @click.option(\"-l\", \"--layout\", help=\"Alternative layout for the report.\")\n@click.pass_obj\n@validate_call\ndef cli_pdf_report(\n    ctx: Project,\n    convert_recipe: str | None,\n    report_recipe: str | None,\n    template: str,\n    version: ProjectVersion | None,\n) -&gt; None:\n    \"\"\"Generate a report PDF.\\f\n\n    Args:\n        ctx: Project's representation.\n        convert_recipe: The recipe for converting the findings.\n        report_recipe: The recipe for building the TeX report.\n        template: The template for the report.\n        version: The version of the configuration to use. If None, the last version is used.\n    \"\"\"\n    # Create report PDF\n    report_pdf = generate_pdf_report(\n        project=ctx, template=template, report_recipe=report_recipe, convert_recipe=convert_recipe, version=version\n    )\n\n    # Create and attach source archive\n    archive = create_source_archive(project_path=ctx.path, config=ctx.config)\n    embed_attachment_to_pdf(attachment=archive, pdf=report_pdf, name=f\"source{archive.suffix}\", keep_original=False)\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.cli_pdf_sow","title":"<code>cli_pdf_sow(ctx, sow_recipe, version)</code>","text":"<p>Generate a Statement of Work (SoW) PDF.\f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required <code>sow_recipe</code> <code>str | None</code> <p>The recipe for building the TeX SoW.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The version of the configuration to use. If None, the last version is used.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@pdf.command(name=\"sow\")\n@handle_exceptions\n@click.option(\"-r\", \"--sow-recipe\", help=\"Build TeX recipe\")\n@click.option(\"-v\", \"--version\", help=\"Use config at specific version, e.g. 'v1.0'.\")\n@click.pass_obj\n@validate_call\ndef cli_pdf_sow(ctx: Project, sow_recipe: str | None, version: ProjectVersion | None) -&gt; None:\n    \"\"\"Generate a Statement of Work (SoW) PDF.\\f\n\n    Args:\n        ctx: Project's representation.\n        sow_recipe: The recipe for building the TeX SoW.\n        version: The version of the configuration to use. If None, the last version is used.\n    \"\"\"\n    generate_pdf_sow(project=ctx, sow_recipe=sow_recipe, version=version)\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.cli_pdf_target","title":"<code>cli_pdf_target(ctx, target_selector, target_recipe, convert_recipe, version)</code>","text":"<p>Generate a target PDF.\f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required <code>target_selector</code> <code>int | str | None</code> <p>The target for which the PDF is being generated.</p> required <code>target_recipe</code> <code>str | None</code> <p>The recipe for building the TeX target.</p> required <code>convert_recipe</code> <code>str | None</code> <p>The recipe for converting the findings.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The version of the configuration to use. If None, the last version is used.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@pdf.command(name=\"target\")\n@handle_exceptions\n@click.option(\"-ts\", \"--target-selector\", help=\"Target selector.\")\n@click.option(\"-c\", \"--convert-recipe\", help=\"Convert finding recipe\")\n@click.option(\"-r\", \"--target-recipe\", help=\"Build TeX target recipe\")\n@click.option(\"-v\", \"--version\", help=\"Use config at specific version, e.g. 'v1.0'.\")\n@click.pass_obj\n@validate_call\ndef cli_pdf_target(\n    ctx: Project,\n    target_selector: int | str | None,\n    target_recipe: str | None,\n    convert_recipe: str | None,\n    version: ProjectVersion | None,\n) -&gt; None:\n    \"\"\"Generate a target PDF.\\f\n\n    Args:\n        ctx: Project's representation.\n        target_selector: The target for which the PDF is being generated.\n        target_recipe: The recipe for building the TeX target.\n        convert_recipe: The recipe for converting the findings.\n        version: The version of the configuration to use. If None, the last version is used.\n    \"\"\"\n    generate_pdf_target(\n        project=ctx,\n        target_selector=target_selector,\n        target_recipe=target_recipe,\n        convert_recipe=convert_recipe,\n        version=version,\n    )\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.config","title":"<code>config()</code>","text":"<p>Project's configuration.</p> <p>This group of commands allows you to manage the configuration of a project.</p> Source code in <code>sereto/cli/cli.py</code> <pre><code>@cli.group(cls=AliasedGroup)\ndef config() -&gt; None:\n    \"\"\"Project's configuration.\n\n    This group of commands allows you to manage the configuration of a project.\n    \"\"\"\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.config_dates","title":"<code>config_dates()</code>","text":"<p>Configuration of dates.</p> <p>This group of commands allows you to manage the dates configuration of a project.</p> Source code in <code>sereto/cli/cli.py</code> <pre><code>@config.group(cls=AliasedGroup, name=\"dates\")\ndef config_dates() -&gt; None:\n    \"\"\"Configuration of dates.\n\n    This group of commands allows you to manage the dates configuration of a project.\n    \"\"\"\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.config_dates_add","title":"<code>config_dates_add(ctx, version)</code>","text":"<p>Add date to the project's configuration.\f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The specific version of the configuration to add the date to. If None, the last version is used.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@config_dates.command(name=\"add\")\n@handle_exceptions\n@click.option(\"-v\", \"--version\", help=\"Use specific version, e.g. 'v1.0'.\")\n@click.pass_obj\n@validate_call\ndef config_dates_add(ctx: Project, version: ProjectVersion | None) -&gt; None:\n    \"\"\"Add date to the project's configuration.\\f\n\n    Args:\n        ctx: Project's representation.\n        version: The specific version of the configuration to add the date to. If None, the last version is used.\n    \"\"\"\n    add_dates_config(config=ctx.config, version=version)\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.config_dates_delete","title":"<code>config_dates_delete(ctx, index, version)</code>","text":"<p>Delete date from the project's configuration.\f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required <code>index</code> <code>int</code> <p>The index of the date to be deleted. You can obtain the index by running <code>sereto config dates show</code>.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The specific version of the configuration to delete the date from. If None, the last version is used.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@config_dates.command(name=\"delete\")\n@handle_exceptions\n@click.option(\"-i\", \"--index\", required=True, type=int, help=\"Date index to be deleted.\")\n@click.option(\"-v\", \"--version\", help=\"Use specific version, e.g. 'v1.0'.\")\n@click.pass_obj\n@validate_call\ndef config_dates_delete(ctx: Project, index: int, version: ProjectVersion | None) -&gt; None:\n    \"\"\"Delete date from the project's configuration.\\f\n\n    Args:\n        ctx: Project's representation.\n        index: The index of the date to be deleted. You can obtain the index by running `sereto config dates show`.\n        version: The specific version of the configuration to delete the date from. If None, the last version is used.\n    \"\"\"\n    if version is None:\n        version = ctx.config.last_version\n\n    # Delete the date from the configuration\n    ctx.config.at_version(version).delete_date(index=index)\n\n    # Write the configuration\n    ctx.config.save()\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.config_dates_show","title":"<code>config_dates_show(ctx, version, all, output_format)</code>","text":"<p>Show dates from the project's configuration.\f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The specific version of the configuration to show dates from. If None, the last version is used.</p> required <code>all</code> <code>bool</code> <p>Flag to show dates from all versions of the configuration.</p> required <code>output_format</code> <code>OutputFormat</code> <p>The output format for displaying the dates.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@config_dates.command(name=\"show\")\n@handle_exceptions\n@click.option(\"-v\", \"--version\", help=\"Show dates from specific version, e.g. 'v1.0'.\")\n@click.option(\n    \"-a\",\n    \"--all\",\n    is_flag=True,\n    show_default=True,\n    default=False,\n    help=\"Show dates from all versions.\",\n)\n@click.option(\n    \"-o\",\n    \"--output-format\",\n    type=click.Choice([of for of in OutputFormat]),\n    default=OutputFormat.table,\n    help=\"Output format.\",\n)\n@click.pass_obj\n@validate_call\ndef config_dates_show(ctx: Project, version: ProjectVersion | None, all: bool, output_format: OutputFormat) -&gt; None:\n    \"\"\"Show dates from the project's configuration.\\f\n\n    Args:\n        ctx: Project's representation.\n        version: The specific version of the configuration to show dates from. If None, the last version is used.\n        all: Flag to show dates from all versions of the configuration.\n        output_format: The output format for displaying the dates.\n    \"\"\"\n    show_dates_config(config=ctx.config, output_format=output_format, all=all, version=version)\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.config_edit","title":"<code>config_edit(ctx)</code>","text":"<p>Launch editor with project's configuration file.\f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@config.command(name=\"edit\")\n@handle_exceptions\n@click.pass_obj\ndef config_edit(ctx: Project) -&gt; None:\n    \"\"\"Launch editor with project's configuration file.\\f\n\n    Args:\n        ctx: Project's representation.\n    \"\"\"\n    edit_config(project=ctx)\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.config_people","title":"<code>config_people()</code>","text":"<p>Configuration of people.</p> <p>This group of commands allows you to manage the people configuration of a project.</p> Source code in <code>sereto/cli/cli.py</code> <pre><code>@config.group(cls=AliasedGroup, name=\"people\")\ndef config_people() -&gt; None:\n    \"\"\"Configuration of people.\n\n    This group of commands allows you to manage the people configuration of a project.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.config_people_add","title":"<code>config_people_add(ctx, version)</code>","text":"<p>Add person to the project's configuration.\f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The specific version of the configuration to add the person to. If None, the last version is used.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@config_people.command(name=\"add\")\n@handle_exceptions\n@click.option(\"-v\", \"--version\", help=\"Use specific version, e.g. 'v1.0'.\")\n@click.pass_obj\n@validate_call\ndef config_people_add(ctx: Project, version: ProjectVersion | None) -&gt; None:\n    \"\"\"Add person to the project's configuration.\\f\n\n    Args:\n        ctx: Project's representation.\n        version: The specific version of the configuration to add the person to. If None, the last version is used.\n    \"\"\"\n    add_people_config(config=ctx.config, version=version)\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.config_people_delete","title":"<code>config_people_delete(ctx, index, version)</code>","text":"<p>Delete person from the project's configuration.\f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required <code>index</code> <code>int</code> <p>The index of the person to be deleted. You can obtain the index by running <code>sereto config people show</code>.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The specific version of the configuration to delete the person from. If None, the last version is used.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@config_people.command(name=\"delete\")\n@handle_exceptions\n@click.option(\"-i\", \"--index\", required=True, type=int, help=\"Person index to be deleted.\")\n@click.option(\"-v\", \"--version\", help=\"Use specific version, e.g. 'v1.0'.\")\n@click.pass_obj\n@validate_call\ndef config_people_delete(ctx: Project, index: int, version: ProjectVersion | None) -&gt; None:\n    \"\"\"Delete person from the project's configuration.\\f\n\n    Args:\n        ctx: Project's representation.\n        index: The index of the person to be deleted. You can obtain the index by running `sereto config people show`.\n        version: The specific version of the configuration to delete the person from. If None, the last version is\n            used.\n    \"\"\"\n    if version is None:\n        version = ctx.config.last_version\n\n    # Delete the date from the configuration\n    ctx.config.at_version(version).delete_person(index=index)\n\n    # Write the configuration\n    ctx.config.save()\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.config_people_show","title":"<code>config_people_show(ctx, version, all, output_format)</code>","text":"<p>Show people from the project's configuration.\f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The specific version of the configuration to show people from. If None, the last version is used.</p> required <code>all</code> <code>bool</code> <p>Flag to show people from all versions of the configuration.</p> required <code>output_format</code> <code>OutputFormat</code> <p>The output format for displaying the people.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@config_people.command(name=\"show\")\n@handle_exceptions\n@click.option(\"-v\", \"--version\", help=\"Show people at specific version, e.g. 'v1.0'.\")\n@click.option(\n    \"-a\",\n    \"--all\",\n    is_flag=True,\n    show_default=True,\n    default=False,\n    help=\"Show people from all versions.\",\n)\n@click.option(\n    \"-o\",\n    \"--output-format\",\n    type=click.Choice([of for of in OutputFormat]),\n    default=OutputFormat.table,\n    help=\"Output format.\",\n)\n@click.pass_obj\n@validate_call\ndef config_people_show(ctx: Project, version: ProjectVersion | None, all: bool, output_format: OutputFormat) -&gt; None:\n    \"\"\"Show people from the project's configuration.\\f\n\n    Args:\n        ctx: Project's representation.\n        version: The specific version of the configuration to show people from. If None, the last version is used.\n        all: Flag to show people from all versions of the configuration.\n        output_format: The output format for displaying the people.\n    \"\"\"\n    show_people_config(config=ctx.config, output_format=output_format, all=all, version=version)\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.config_show","title":"<code>config_show(ctx, version, all, output_format)</code>","text":"<p>Show the projects's configuration.\f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The specific version of the configuration to show. If None, the last version is used.</p> required <code>all</code> <code>bool</code> <p>Flag to show all versions of the configuration.</p> required <code>output_format</code> <code>OutputFormat</code> <p>The output format for displaying the configuration.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@config.command(name=\"show\")\n@handle_exceptions\n@click.option(\"-v\", \"--version\", help=\"Show config at specific version, e.g. 'v1.0'.\")\n@click.option(\n    \"-a\",\n    \"--all\",\n    is_flag=True,\n    show_default=True,\n    default=False,\n    help=\"Show all versions.\",\n)\n@click.option(\n    \"-o\",\n    \"--output-format\",\n    type=click.Choice([of for of in OutputFormat]),\n    default=OutputFormat.table,\n    help=\"Output format.\",\n)\n@click.pass_obj\n@validate_call\ndef config_show(ctx: Project, version: ProjectVersion | None, all: bool, output_format: OutputFormat) -&gt; None:\n    \"\"\"Show the projects's configuration.\\f\n\n    Args:\n        ctx: Project's representation.\n        version: The specific version of the configuration to show. If None, the last version is used.\n        all: Flag to show all versions of the configuration.\n        output_format: The output format for displaying the configuration.\n    \"\"\"\n    show_config(config=ctx.config, output_format=output_format, all=all, version=version)\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.config_targets","title":"<code>config_targets()</code>","text":"<p>Configuration of targets.</p> <p>This group of commands allows you to manage the targets configuration of a project.</p> Source code in <code>sereto/cli/cli.py</code> <pre><code>@config.group(cls=AliasedGroup, name=\"targets\")\ndef config_targets() -&gt; None:\n    \"\"\"Configuration of targets.\n\n    This group of commands allows you to manage the targets configuration of a project.\n    \"\"\"\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.config_targets_add","title":"<code>config_targets_add(ctx, version)</code>","text":"<p>Add targets to the project's configuration.\f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The specific version of the configuration to add the targets to. If None, the last version is used.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@config_targets.command(name=\"add\")\n@handle_exceptions\n@click.option(\"-v\", \"--version\", help=\"Use specific version, e.g. 'v1.0'.\")\n@click.pass_obj\n@validate_call\ndef config_targets_add(ctx: Project, version: ProjectVersion | None) -&gt; None:\n    \"\"\"Add targets to the project's configuration.\\f\n\n    Args:\n        ctx: Project's representation.\n        version: The specific version of the configuration to add the targets to. If None, the last version is used.\n    \"\"\"\n    add_target(\n        project_path=ctx.path,\n        templates=ctx.settings.templates_path,\n        config=ctx.config,\n        categories=ctx.settings.categories,\n        version=version,\n    )\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.config_targets_delete","title":"<code>config_targets_delete(ctx, index, version)</code>","text":"<p>Delete target from the project's configuration.\f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required <code>index</code> <code>int</code> <p>The index of the target to be deleted. You can obtain the index by running <code>sereto config targets show</code>.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The specific version of the configuration to delete the target from. If None, the last version is used.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@config_targets.command(name=\"delete\")\n@handle_exceptions\n@click.option(\"-i\", \"--index\", required=True, type=int, help=\"Target index to be deleted.\")\n@click.option(\"-v\", \"--version\", help=\"Use specific version, e.g. 'v1.0'.\")\n@click.pass_obj\n@validate_call\ndef config_targets_delete(ctx: Project, index: int, version: ProjectVersion | None) -&gt; None:\n    \"\"\"Delete target from the project's configuration.\\f\n\n    Args:\n        ctx: Project's representation.\n        index: The index of the target to be deleted. You can obtain the index by running `sereto config targets show`.\n        version: The specific version of the configuration to delete the target from. If None, the last version is\n            used.\n    \"\"\"\n    delete_target(config=ctx.config, index=index, version=version, interactive=True)\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.config_targets_show","title":"<code>config_targets_show(ctx, version, all, output_format)</code>","text":"<p>Show targets from the project's configuration.\f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The specific version of the configuration to show targets from. If None, the last version is used.</p> required <code>all</code> <code>bool</code> <p>Flag to show targets from all versions of the configuration.</p> required <code>output_format</code> <code>OutputFormat</code> <p>The output format for displaying the targets.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@config_targets.command(name=\"show\")\n@handle_exceptions\n@click.option(\"-v\", \"--version\", help=\"Show targets at specific version, e.g. 'v1.0'.\")\n@click.option(\n    \"-a\",\n    \"--all\",\n    is_flag=True,\n    show_default=True,\n    default=False,\n    help=\"Show targets from all versions.\",\n)\n@click.option(\n    \"-o\",\n    \"--output-format\",\n    type=click.Choice([of for of in OutputFormat]),\n    default=OutputFormat.table,\n    help=\"Output format.\",\n)\n@click.pass_obj\n@validate_call\ndef config_targets_show(ctx: Project, version: ProjectVersion | None, all: bool, output_format: OutputFormat) -&gt; None:\n    \"\"\"Show targets from the project's configuration.\\f\n\n    Args:\n        ctx: Project's representation.\n        version: The specific version of the configuration to show targets from. If None, the last version is used.\n        all: Flag to show targets from all versions of the configuration.\n        output_format: The output format for displaying the targets.\n    \"\"\"\n    show_targets_config(config=ctx.config, output_format=output_format, all=all, version=version)\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.decrypt","title":"<code>decrypt(ctx, file)</code>","text":"<p>Extract the SeReTo project from the encrypted archive.</p> Source code in <code>sereto/cli/cli.py</code> <pre><code>@cli.command()\n@handle_exceptions\n@click.option(\"-f\", \"--file\", required=True, help=\"Path to the source.sereto file.\", type=Path)\n@click.pass_obj\n@validate_call\ndef decrypt(ctx: Project, file: FilePath) -&gt; None:\n    \"\"\"Extract the SeReTo project from the encrypted archive.\"\"\"\n    source_tgz = decrypt_file(file=file, keep_original=True)\n    extract_source_archive(file=source_tgz, output_dir=ctx.settings.projects_path, keep_original=False)\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.finding_add","title":"<code>finding_add(ctx)</code>","text":"<p>Launch TUI app for searching and adding findings from templates.\f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@findings.command(name=\"add\")\n@handle_exceptions\n@click.pass_obj\n@validate_call\ndef finding_add(ctx: Project) -&gt; None:\n    \"\"\"Launch TUI app for searching and adding findings from templates.\\f\n\n    Args:\n        ctx: Project's representation.\n    \"\"\"\n    asyncio.run(launch_finding_tui())\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.finding_show","title":"<code>finding_show(ctx, version)</code>","text":"<p>Show findings.\f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The version of the findings to show. If None, the last version is used.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@findings.command(name=\"show\")\n@handle_exceptions\n# @click.option(\"--target\", \"-t\", type=str, help=\"Specify target (required for more than one).\")\n@click.option(\"-v\", \"--version\", help=\"Use specific version, e.g. 'v1.0'.\")\n@click.pass_obj\n@validate_call\ndef finding_show(ctx: Project, version: ProjectVersion | None) -&gt; None:\n    \"\"\"Show findings.\\f\n\n    Args:\n        ctx: Project's representation.\n        version: The version of the findings to show. If None, the last version is used.\n    \"\"\"\n    if version is None:\n        version = ctx.config.last_version\n    show_findings(version_config=ctx.config.at_version(version))\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.findings","title":"<code>findings()</code>","text":"<p>Operations with findings.</p> <p>This group of commands allows you to manage the findings of a project.</p> Source code in <code>sereto/cli/cli.py</code> <pre><code>@cli.group(cls=AliasedGroup)\ndef findings() -&gt; None:\n    \"\"\"Operations with findings.\n\n    This group of commands allows you to manage the findings of a project.\n    \"\"\"\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.load_plugins","title":"<code>load_plugins()</code>","text":"<p>Load plugins from the plugins directory.</p> <p>This function loads plugins from the configured directory and registers their commands with the CLI. The plugin support needs to be enabled in the settings.</p> Source code in <code>sereto/cli/cli.py</code> <pre><code>def load_plugins() -&gt; None:\n    \"\"\"Load plugins from the plugins directory.\n\n    This function loads plugins from the configured directory and registers their commands with the CLI. The plugin\n    support needs to be enabled in the settings.\n    \"\"\"\n    settings = load_settings_function()\n\n    # Check if plugins are enabled\n    if not settings.plugins.enabled:\n        return\n    # Get plugins directory\n    plugins_dir = Path(\n        replace_strings(text=settings.plugins.directory, replacements={\"%TEMPLATES%\": str(settings.templates_path)})\n    )\n    if not plugins_dir.is_dir():\n        raise SeretoPathError(f\"Plugins directory not found: '{plugins_dir}'\")\n\n    # Ensure plugins directory is in a package-importable location\n    plugins_parent = plugins_dir.parent\n    if not plugins_parent.is_dir():\n        raise SeretoPathError(f\"Plugins parent directory not found: '{plugins_parent}'\")\n    if not (plugins_dir / \"__init__.py\").exists():\n        raise SeretoPathError(f\"Plugins directory '{plugins_dir}' is not a package (missing __init__.py)\")\n    if str(plugins_parent) not in sys.path:\n        sys.path.insert(0, str(plugins_parent))\n    # Compatibility for older SeReTo plugins; add plugins directory at the end of sys.path\n    if str(plugins_dir) not in sys.path:\n        sys.path.append(str(plugins_dir))\n\n    # Load plugins from the directory\n    for file in plugins_dir.iterdir():\n        # Skip dunder files like __init__.py\n        if file.name.startswith(\"__\"):\n            continue\n\n        if file.is_dir() and (file / \"__init__.py\").exists():\n            # It's a package\n            module_name = f\"plugins.{file.name}\"\n            module_path = file / \"__init__.py\"\n            submodule_search_locations = [str(file)]\n        elif file.suffix == \".py\":\n            module_name = f\"plugins.{file.name[:-3]}\"\n            module_path = file\n            submodule_search_locations = None\n        else:\n            continue\n\n        # Register commands\n        try:\n            # Create a module specification\n            spec = importlib.util.spec_from_file_location(\n                module_name, module_path, submodule_search_locations=submodule_search_locations\n            )\n            if spec is None or spec.loader is None:\n                logger.error(\"Failed to load plugin: {}\", file.name)\n                continue\n\n            # Create a new module based on the specification\n            module = importlib.util.module_from_spec(spec)\n\n            # Execute the module to initialize it\n            spec.loader.exec_module(module)\n        except ModuleNotFoundError as e:\n            logger.error(\"Module '{}' referenced in plugin '{}' not found.\", e.name, file.name)\n            continue\n\n        # Run the plugin's register_commands function\n        if hasattr(module, \"register_commands\"):\n            module.register_commands(cli)\n            logger.debug(\"Plugin registered: '{}'\", file.name)\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.ls","title":"<code>ls(ctx)</code>","text":"<p>List all available projects.</p> Source code in <code>sereto/cli/cli.py</code> <pre><code>@cli.command()\n@handle_exceptions\n@click.pass_obj\ndef ls(ctx: Project) -&gt; None:\n    \"\"\"List all available projects.\"\"\"\n    sereto_ls(settings=ctx.settings)\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.new","title":"<code>new(ctx, project_id)</code>","text":"<p>Create a new project.</p> <p>\b Example:     <pre><code>sereto new PT01234\n</code></pre> </p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required <code>project_id</code> <code>TypeProjectId</code> <p>The ID of the project to be created.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@cli.command()\n@handle_exceptions\n@click.argument(\"project_id\")\n@click.pass_obj\n@validate_call\ndef new(ctx: Project, project_id: TypeProjectId) -&gt; None:\n    \"\"\"Create a new project.\n\n    \\b\n    Example:\n        ```sh\n        sereto new PT01234\n        ```\n    \\f\n\n    Args:\n        ctx: Project's representation.\n        project_id: The ID of the project to be created.\n    \"\"\"\n    Console().print(\"[cyan]We will ask you a few questions to set up the new project.\\n\")\n    name = prompt(\"Name of the project: \")\n    new_project(\n        projects_path=ctx.settings.projects_path,\n        templates_path=ctx.settings.templates_path,\n        risk_due_dates=ctx.settings.risk_due_dates,\n        id=project_id,\n        name=name,\n        people=ctx.settings.default_people,\n    )\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.open","title":"<code>open()</code>","text":"<p>Open report, Statement of Work (SoW), or the project's folder.</p> Source code in <code>sereto/cli/cli.py</code> <pre><code>@cli.group(cls=AliasedGroup)\ndef open() -&gt; None:\n    \"\"\"Open report, Statement of Work (SoW), or the project's folder.\"\"\"\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.open_folder","title":"<code>open_folder(ctx)</code>","text":"<p>Open the folder containing the current project.\f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@open.command(name=\"folder\")\n@handle_exceptions\n@click.pass_obj\ndef open_folder(ctx: Project) -&gt; None:\n    \"\"\"Open the folder containing the current project.\\f\n\n    Args:\n        ctx: Project's representation.\n    \"\"\"\n    click.launch(str(ctx.path))\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.open_report","title":"<code>open_report(ctx, version)</code>","text":"<p>Open the report document in the default PDF viewer.\f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The version of the report that is opened. If None, the last version is used.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@open.command(name=\"report\")\n@handle_exceptions\n@click.option(\"-v\", \"--version\", help=\"Use specific version, e.g. 'v1.0'.\")\n@click.pass_obj\n@validate_call\ndef open_report(ctx: Project, version: ProjectVersion | None) -&gt; None:\n    \"\"\"Open the report document in the default PDF viewer.\\f\n\n    Args:\n        ctx: Project's representation.\n        version: The version of the report that is opened. If None, the last version is used.\n    \"\"\"\n    version_config = ctx.config.at_version(version) if version else ctx.config.last_config\n\n    if not (report_path := ctx.path / \"pdf\" / version_config.report_name).is_file():\n        raise SeretoPathError(f\"File not found '{report_path}'\")\n\n    click.launch(str(report_path))\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.open_sow","title":"<code>open_sow(ctx, version)</code>","text":"<p>Open the Statement of Work (SoW) document in the default PDF viewer.\f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The version of the SoW that is opened. If None, the last version is used.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@open.command(name=\"sow\")\n@handle_exceptions\n@click.option(\"-v\", \"--version\", help=\"Use specific version, e.g. 'v1.0'.\")\n@click.pass_obj\n@validate_call\ndef open_sow(ctx: Project, version: ProjectVersion | None) -&gt; None:\n    \"\"\"Open the Statement of Work (SoW) document in the default PDF viewer.\\f\n\n    Args:\n        ctx: Project's representation.\n        version: The version of the SoW that is opened. If None, the last version is used.\n    \"\"\"\n    version_config = ctx.config.at_version(version) if version else ctx.config.last_config\n\n    if not (sow_path := ctx.path / \"pdf\" / version_config.sow_name).is_file():\n        raise SeretoPathError(f\"File not found '{sow_path}'\")\n\n    click.launch(str(sow_path))\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.oxipng","title":"<code>oxipng(ctx)</code>","text":"<p>Lossless PNGs compression.</p> Source code in <code>sereto/cli/cli.py</code> <pre><code>@cli.command()\n@handle_exceptions\n@click.pass_obj\n@validate_call\ndef oxipng(ctx: Project) -&gt; None:\n    \"\"\"Lossless PNGs compression.\"\"\"\n    run_oxipng(project_path=ctx.path)\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.password","title":"<code>password()</code>","text":"<p>Manage password for the encryption of attached archives.</p> Source code in <code>sereto/cli/cli.py</code> <pre><code>@settings.group(cls=AliasedGroup)\ndef password() -&gt; None:\n    \"\"\"Manage password for the encryption of attached archives.\"\"\"\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.pdf","title":"<code>pdf()</code>","text":"<p>Render PDF documents.</p> <p>This group of commands allows you to render a PDF report or Statement of Work.</p> Source code in <code>sereto/cli/cli.py</code> <pre><code>@cli.group(cls=AliasedGroup)\ndef pdf() -&gt; None:\n    \"\"\"Render PDF documents.\n\n    This group of commands allows you to render a PDF report or Statement of Work.\n    \"\"\"\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.repl","title":"<code>repl()</code>","text":"<p>Start an interactive shell (REPL) for SeReTo.</p> Source code in <code>sereto/cli/cli.py</code> <pre><code>@cli.command()\ndef repl() -&gt; None:\n    \"\"\"Start an interactive shell (REPL) for SeReTo.\"\"\"\n    sereto_repl(cli=cli)\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.retest","title":"<code>retest(ctx)</code>","text":"<p>Add retest to the project.\f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@cli.command(name=\"retest\")\n@handle_exceptions\n@click.pass_obj\ndef retest(ctx: Project) -&gt; None:\n    \"\"\"Add retest to the project.\\f\n\n    Args:\n        ctx: Project's representation.\n    \"\"\"\n    add_retest(project=ctx)\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.settings","title":"<code>settings()</code>","text":"<p>Manage global settings.</p> <p>This group of commands allows you to display and edit the global settings.</p> Source code in <code>sereto/cli/cli.py</code> <pre><code>@cli.group(cls=AliasedGroup)\ndef settings() -&gt; None:\n    \"\"\"Manage global settings.\n\n    This group of commands allows you to display and edit the global settings.\n    \"\"\"\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.settings_edit","title":"<code>settings_edit()</code>","text":"<p>Edit settings with the configured editor.</p> <p>This command opens the global settings configuration file in the default editor. If the configuration file does not exist, it will be created first with the default values.</p> Source code in <code>sereto/cli/cli.py</code> <pre><code>@settings.command(name=\"edit\")\n@handle_exceptions\ndef settings_edit() -&gt; None:\n    \"\"\"Edit settings with the configured editor.\n\n    This command opens the global settings configuration file in the default editor.\n    If the configuration file does not exist, it will be created first with the default values.\n    \"\"\"\n    if not (path := Settings.get_path()).is_file():\n        load_settings_function()\n    click.edit(filename=str(path))\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.settings_password_get","title":"<code>settings_password_get()</code>","text":"<p>Get the password for the encryption of attached archives.</p> <p>This will print the password from the system's keyring.</p> Source code in <code>sereto/cli/cli.py</code> <pre><code>@password.command(name=\"get\")\n@handle_exceptions\ndef settings_password_get() -&gt; None:\n    \"\"\"Get the password for the encryption of attached archives.\n\n    This will print the password from the system's keyring.\n    \"\"\"\n    click.echo(get_password(\"sereto\", \"encrypt_attached_archive\"))\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.settings_password_set","title":"<code>settings_password_set(password)</code>","text":"<p>Set the password for the encryption of attached archives.</p> <p>This will store the password in the system's keyring. \f</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>str</code> <p>The password to be stored.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@password.command(name=\"set\")\n@handle_exceptions\n@validate_call\n@click.option(\"--password\", prompt=True, hide_input=True)\ndef settings_password_set(password: str) -&gt; None:\n    \"\"\"Set the password for the encryption of attached archives.\n\n    This will store the password in the system's keyring.\n    \\f\n\n    Args:\n        password: The password to be stored.\n    \"\"\"\n    set_password(\"sereto\", \"encrypt_attached_archive\", password)\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.settings_show","title":"<code>settings_show(ctx)</code>","text":"<p>Display the current settings.</p> <p>This function prints the current settings of the tool, including both the set values and the default values for any unset settings. \f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>The settings object containing the tool's global configuration.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@settings.command(name=\"show\")\n@handle_exceptions\n@click.pass_obj\ndef settings_show(ctx: Project) -&gt; None:\n    \"\"\"Display the current settings.\n\n    This function prints the current settings of the tool, including both the set values and the default values for any\n    unset settings.\n    \\f\n\n    Args:\n        ctx: The settings object containing the tool's global configuration.\n    \"\"\"\n    Console().print_json(ctx.settings.model_dump_json())\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.skel","title":"<code>skel()</code>","text":"<p>Project template skeleton files.</p> Source code in <code>sereto/cli/cli.py</code> <pre><code>@templates.group(cls=AliasedGroup)\ndef skel() -&gt; None:\n    \"\"\"Project template skeleton files.\"\"\"\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.target_skel","title":"<code>target_skel()</code>","text":"<p>Target template skeleton files.</p> Source code in <code>sereto/cli/cli.py</code> <pre><code>@templates.group(cls=AliasedGroup)\ndef target_skel() -&gt; None:\n    \"\"\"Target template skeleton files.\"\"\"\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.templates","title":"<code>templates()</code>","text":"<p>Operations with templates.</p> <p>This group of commands allows you to copy project's skeleton from templates.</p> Source code in <code>sereto/cli/cli.py</code> <pre><code>@cli.group(cls=AliasedGroup)\ndef templates() -&gt; None:\n    \"\"\"Operations with templates.\n\n    This group of commands allows you to copy project's skeleton from templates.\n    \"\"\"\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.templates_skel_copy","title":"<code>templates_skel_copy(ctx)</code>","text":"<p>Update the project's templates from the skeleton directory.</p> <p>This function copies all files from the templates skeleton directory to the project's directory, overwriting any existing files. \f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@skel.command(name=\"copy\")\n@handle_exceptions\n@click.pass_obj\ndef templates_skel_copy(ctx: Project) -&gt; None:\n    \"\"\"Update the project's templates from the skeleton directory.\n\n    This function copies all files from the templates skeleton directory to the project's directory, overwriting any\n    existing files.\n    \\f\n\n    Args:\n        ctx: Project's representation.\n    \"\"\"\n    copy_skel(templates=ctx.settings.templates_path, dst=ctx.path, overwrite=True)\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.templates_target_skel_copy","title":"<code>templates_target_skel_copy(ctx, target)</code>","text":"<p>Update the target's templates from the skeleton directory.</p> <p>This function copies all files from the templates skeleton directory to the target's directory, overwriting any existing files. \f</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Project</code> <p>Project's representation.</p> required <code>target</code> <code>str | None</code> <p>Selector of a target for which the templates are being copied.</p> required Source code in <code>sereto/cli/cli.py</code> <pre><code>@target_skel.command(name=\"copy\")\n@handle_exceptions\n@click.option(\"--target\", \"-t\", type=str, help=\"Specify target (required for more than one).\")\n@click.pass_obj\n@validate_call\ndef templates_target_skel_copy(ctx: Project, target: str | None) -&gt; None:\n    \"\"\"Update the target's templates from the skeleton directory.\n\n    This function copies all files from the templates skeleton directory to the target's directory, overwriting any\n    existing files.\n    \\f\n\n    Args:\n        ctx: Project's representation.\n        target: Selector of a target for which the templates are being copied.\n    \"\"\"\n    selected_target = ctx.config.last_config.select_target(categories=ctx.settings.categories, selector=target)\n\n    copy_skel(\n        templates=ctx.settings.templates_path / \"categories\" / selected_target.data.category,\n        dst=selected_target.path,\n        overwrite=True,\n    )\n</code></pre>"},{"location":"reference/cli/cli/#sereto.cli.cli.unpack","title":"<code>unpack(ctx, file)</code>","text":"<p>Unpack the SeReTo project from the report's PDF.</p> Source code in <code>sereto/cli/cli.py</code> <pre><code>@cli.command()\n@handle_exceptions\n@click.option(\"-f\", \"--file\", required=True, help=\"Path to the PDF file.\", type=Path)\n@click.pass_obj\n@validate_call\ndef unpack(ctx: Project, file: FilePath) -&gt; None:\n    \"\"\"Unpack the SeReTo project from the report's PDF.\"\"\"\n    attachment: Path | None = None\n\n    with suppress(SeretoValueError):\n        attachment = retrieve_source_archive(pdf=file, name=\"source.sereto\")\n\n    if attachment is not None:\n        source_tgz = decrypt_file(file=attachment, keep_original=False)\n    else:\n        source_tgz = retrieve_source_archive(pdf=file, name=\"source.tgz\")\n\n    extract_source_archive(file=source_tgz, output_dir=ctx.settings.projects_path, keep_original=False)\n</code></pre>"},{"location":"reference/cli/commands/","title":"Commands","text":""},{"location":"reference/cli/commands/#sereto.cli.commands","title":"<code>sereto.cli.commands</code>","text":""},{"location":"reference/cli/commands/#sereto.cli.commands.WorkingDir","title":"<code>WorkingDir</code>","text":"<p>Helper class for REPL implementing the <code>cd</code> command.</p> <p>Attributes:</p> Name Type Description <code>old_cwd</code> <code>Path</code> <p>The previous working directory.</p> Source code in <code>sereto/cli/commands.py</code> <pre><code>class WorkingDir(metaclass=Singleton):\n    \"\"\"Helper class for REPL implementing the `cd` command.\n\n    Attributes:\n        old_cwd: The previous working directory.\n    \"\"\"\n\n    old_cwd: Path = Field(default_factory=Path.cwd)\n\n    def change(self, dst: Path, /) -&gt; None:\n        \"\"\"Change the current working directory to the new location.\n\n        Also saves the previous location for future reference.\n\n        Args:\n            dst: The new working directory\n\n        Raises:\n            SeretoPathError: If the provided path is not an existing directory.\n        \"\"\"\n        if not dst.is_dir():\n            raise SeretoPathError(f\"Directory '{dst}' does not exist.\")\n\n        cwd = Path.cwd()\n        os.chdir(dst)\n        self.old_cwd = cwd\n\n    def go_back(self) -&gt; None:\n        \"\"\"Change the current working directory to the previous location.\"\"\"\n        self.change(self.old_cwd)\n</code></pre>"},{"location":"reference/cli/commands/#sereto.cli.commands.WorkingDir.change","title":"<code>change(dst)</code>","text":"<p>Change the current working directory to the new location.</p> <p>Also saves the previous location for future reference.</p> <p>Parameters:</p> Name Type Description Default <code>dst</code> <code>Path</code> <p>The new working directory</p> required <p>Raises:</p> Type Description <code>SeretoPathError</code> <p>If the provided path is not an existing directory.</p> Source code in <code>sereto/cli/commands.py</code> <pre><code>def change(self, dst: Path, /) -&gt; None:\n    \"\"\"Change the current working directory to the new location.\n\n    Also saves the previous location for future reference.\n\n    Args:\n        dst: The new working directory\n\n    Raises:\n        SeretoPathError: If the provided path is not an existing directory.\n    \"\"\"\n    if not dst.is_dir():\n        raise SeretoPathError(f\"Directory '{dst}' does not exist.\")\n\n    cwd = Path.cwd()\n    os.chdir(dst)\n    self.old_cwd = cwd\n</code></pre>"},{"location":"reference/cli/commands/#sereto.cli.commands.WorkingDir.go_back","title":"<code>go_back()</code>","text":"<p>Change the current working directory to the previous location.</p> Source code in <code>sereto/cli/commands.py</code> <pre><code>def go_back(self) -&gt; None:\n    \"\"\"Change the current working directory to the previous location.\"\"\"\n    self.change(self.old_cwd)\n</code></pre>"},{"location":"reference/cli/commands/#sereto.cli.commands.repl_cd","title":"<code>repl_cd(project_id)</code>","text":"<p>Switch the active project in the REPL.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>TypeProjectId | Literal['-']</code> <p>The ID of the project to switch to. Use '-' to go back to the previous working directory.</p> required <p>Raises:</p> Type Description <code>SeretoValueError</code> <p>If the project ID is invalid.</p> <code>SeretoPathError</code> <p>If the project's path does not exist.</p> Source code in <code>sereto/cli/commands.py</code> <pre><code>@click.command(name=\"cd\")\n@handle_exceptions\n@click.argument(\"project_id\", type=str)\n@validate_call\ndef repl_cd(project_id: TypeProjectId | Literal[\"-\"]) -&gt; None:\n    \"\"\"Switch the active project in the REPL.\n\n    Args:\n        project_id: The ID of the project to switch to. Use '-' to go back to the previous working directory.\n\n    Raises:\n        SeretoValueError: If the project ID is invalid.\n        SeretoPathError: If the project's path does not exist.\n    \"\"\"\n    project: Project = get_current_context().obj\n    wd = WorkingDir()\n\n    # `cd -` ... Go back to the previous working directory\n    if project_id == \"-\":\n        wd.go_back()\n        return\n\n    settings = project.settings\n    project_path = resolve_project_directory(\n        projects_path=settings.projects_path,\n        project_id=project_id,\n        templates_path=settings.templates_path,\n    )\n\n    # Change the current working directory to the new location\n    wd.change(project_path)\n</code></pre>"},{"location":"reference/cli/commands/#sereto.cli.commands.repl_exit","title":"<code>repl_exit()</code>","text":"<p>Exit from the Read-Eval-Print Loop (REPL).</p> Source code in <code>sereto/cli/commands.py</code> <pre><code>@click.command(name=\"exit\")\ndef repl_exit() -&gt; None:\n    \"\"\"Exit from the Read-Eval-Print Loop (REPL).\"\"\"\n    click_repl_exit()\n</code></pre>"},{"location":"reference/cli/commands/#sereto.cli.commands.repl_toggle_debug","title":"<code>repl_toggle_debug()</code>","text":"<p>Toggle the debug mode.</p> Source code in <code>sereto/cli/commands.py</code> <pre><code>@click.command(name=\"debug\")\ndef repl_toggle_debug() -&gt; None:\n    \"\"\"Toggle the debug mode.\"\"\"\n    if os.environ.get(\"DEBUG\", \"0\") == \"1\":\n        del os.environ[\"DEBUG\"]\n    else:\n        os.environ[\"DEBUG\"] = \"1\"\n</code></pre>"},{"location":"reference/cli/commands/#sereto.cli.commands.sereto_ls","title":"<code>sereto_ls(settings)</code>","text":"<p>List all projects in the user's projects directory.</p> <p>Print a table with the details to the console.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>Settings</code> <p>The Settings object.</p> required Source code in <code>sereto/cli/commands.py</code> <pre><code>@validate_call\ndef sereto_ls(settings: Settings) -&gt; None:\n    \"\"\"List all projects in the user's projects directory.\n\n    Print a table with the details to the console.\n\n    Args:\n        settings: The Settings object.\n    \"\"\"\n    project_paths: list[Path] = [d for d in settings.projects_path.iterdir() if is_project_dir(d)]\n    table = Table(\"ID\", \"Name\", \"Location\", title=\"Projects\", box=box.MINIMAL)\n\n    for dir in project_paths:\n        try:\n            project_name = Project.load_from(dir).config.last_config.name\n        except (RuntimeError, SeretoValueError):\n            project_name = \"n/a\"\n\n        table.add_row(dir.name, project_name, f\"[link {dir.as_uri()}]{dir}\")\n\n    Console().print(table, justify=\"center\")\n</code></pre>"},{"location":"reference/cli/commands/#sereto.cli.commands.sereto_repl","title":"<code>sereto_repl(cli)</code>","text":"<p>Start an interactive Read-Eval-Print Loop (REPL) session.</p> <p>Parameters:</p> Name Type Description Default <code>cli</code> <code>Group</code> <p>The main CLI group.</p> required Source code in <code>sereto/cli/commands.py</code> <pre><code>def sereto_repl(cli: Group) -&gt; None:\n    \"\"\"Start an interactive Read-Eval-Print Loop (REPL) session.\n\n    Args:\n        cli: The main CLI group.\n    \"\"\"\n    logger.info(\n        r\"\"\"\n  ____       ____     _____\n / ___|  ___|  _ \\ __|_   _|__\n \\___ \\ / _ \\ |_) / _ \\| |/ _ \\\n  ___) |  __/  _ &lt;  __/| | (_) |\n |____/ \\___|_| \\_\\___||_|\\___/\n\nWelcome to [blue]SeReTo Interactive Mode[/blue]!\n---------------------------------------------\nType 'exit' or press 'Ctrl+D' to quit.\nUse 'cd &lt;ID&gt;' to change the active project.\nType '-h'/'--help' to see available commands.\n    \"\"\",\n        markup=True,\n    )\n\n    # Add REPL specific commands\n    cli.add_command(repl_cd)\n    cli.add_command(repl_exit)\n    cli.add_command(repl_toggle_debug)\n\n    # Define the prompt style\n    prompt_style = Style.from_dict(\n        {\n            \"debug\": \"red\",\n            \"sereto\": \"#02a0f0 bold\",\n            \"bracket\": \"#8a8a8a\",\n            \"project_id\": \"#00ff00\",\n            \"gt\": \"#8a8a8a bold\",\n        }\n    )\n\n    prompt_kwargs = {\n        \"message\": _get_repl_prompt,\n        \"history\": FileHistory(Path(get_app_dir(app_name=\"sereto\")) / \".sereto_history\"),\n        \"style\": prompt_style,\n    }\n    repl(click.get_current_context(), prompt_kwargs=prompt_kwargs)\n</code></pre>"},{"location":"reference/cli/config/","title":"Config","text":""},{"location":"reference/cli/config/#sereto.cli.config","title":"<code>sereto.cli.config</code>","text":""},{"location":"reference/cli/config/#sereto.cli.config.add_dates_config","title":"<code>add_dates_config(config, version=None)</code>","text":"<p>Add date to the configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>Configuration of the project.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The version of the project. If not provided, the last version is used.</p> <code>None</code> Source code in <code>sereto/cli/config.py</code> <pre><code>@validate_call\ndef add_dates_config(config: Config, version: ProjectVersion | None = None) -&gt; None:\n    \"\"\"Add date to the configuration.\n\n    Args:\n        config: Configuration of the project.\n        version: The version of the project. If not provided, the last version is used.\n    \"\"\"\n    if version is None:\n        version = config.last_version\n\n    # Prompt user for the date\n    date_type: DateType = load_enum(enum=DateType, message=\"Type:\")\n    new_date = prompt_user_for_date(date_type=date_type)\n\n    # Add the date to the configuration\n    config.at_version(version).add_date(Date(type=date_type, date=new_date))\n\n    # Write the configuration\n    config.save()\n</code></pre>"},{"location":"reference/cli/config/#sereto.cli.config.add_people_config","title":"<code>add_people_config(config, version=None)</code>","text":"<p>Add person to the configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>Configuration of the project.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The version of the project. If not provided, the last version is used.</p> <code>None</code> Source code in <code>sereto/cli/config.py</code> <pre><code>@validate_call\ndef add_people_config(config: Config, version: ProjectVersion | None = None) -&gt; None:\n    \"\"\"Add person to the configuration.\n\n    Args:\n        config: Configuration of the project.\n        version: The version of the project. If not provided, the last version is used.\n    \"\"\"\n    if version is None:\n        version = config.last_version\n\n    # Prompt user for the person\n    person_type: PersonType = load_enum(enum=PersonType, message=\"Type:\")\n    new_person = prompt_user_for_person(person_type=person_type)\n\n    # Add the person to the configuration\n    config.at_version(version).add_person(new_person)\n\n    # Write the configuration\n    config.save()\n</code></pre>"},{"location":"reference/cli/config/#sereto.cli.config.add_target","title":"<code>add_target(project_path, templates, config, categories, version=None)</code>","text":"<p>Add target to the configuration.</p> <p>Parameters:</p> Name Type Description Default <code>project_path</code> <code>DirectoryPath</code> <p>Path to the project directory.</p> required <code>templates</code> <code>DirectoryPath</code> <p>Path to the templates directory.</p> required <code>config</code> <code>Config</code> <p>Configuration of the project.</p> required <code>categories</code> <code>Iterable[str]</code> <p>List of all categories.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The version of the project. If not provided, the last version is used.</p> <code>None</code> Source code in <code>sereto/cli/config.py</code> <pre><code>@validate_call\ndef add_target(\n    project_path: DirectoryPath,\n    templates: DirectoryPath,\n    config: Config,\n    categories: Iterable[str],\n    version: ProjectVersion | None = None,\n) -&gt; None:\n    \"\"\"Add target to the configuration.\n\n    Args:\n        project_path: Path to the project directory.\n        templates: Path to the templates directory.\n        config: Configuration of the project.\n        categories: List of all categories.\n        version: The version of the project. If not provided, the last version is used.\n    \"\"\"\n    if version is None:\n        version = config.last_version\n\n    # Prompt user for the target details\n    new_target_model = prompt_user_for_target(categories=categories)\n\n    # Create the target instance, including on the filesystem\n    new_target = Target.new(data=new_target_model, project_path=project_path, templates=templates, version=version)\n\n    # Add the target to the configuration\n    config.at_version(version).add_target(new_target)\n\n    # Write the configuration\n    config.save()\n</code></pre>"},{"location":"reference/cli/config/#sereto.cli.config.delete_target","title":"<code>delete_target(config, index, version=None, interactive=False)</code>","text":"<p>Delete target from the configuration by its index.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>Configuration of the project.</p> required <code>index</code> <code>int</code> <p>Index to item which should be deleted. First item is 1.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>The version of the project. If not provided, the last version is used.</p> <code>None</code> <code>interactive</code> <code>bool</code> <p>Whether to ask for confirmations.</p> <code>False</code> Source code in <code>sereto/cli/config.py</code> <pre><code>@validate_call\ndef delete_target(\n    config: Config, index: int, version: ProjectVersion | None = None, interactive: bool = False\n) -&gt; None:\n    \"\"\"Delete target from the configuration by its index.\n\n    Args:\n        config: Configuration of the project.\n        index: Index to item which should be deleted. First item is 1.\n        version: The version of the project. If not provided, the last version is used.\n        interactive: Whether to ask for confirmations.\n    \"\"\"\n    if version is None:\n        version = config.last_version\n\n    # Extract the filesystem path before deleting the values\n    version_config = config.at_version(version)\n    target_path = version_config.targets[index - 1].path\n\n    # Delete the date from the configuration\n    version_config.delete_target(index=index)\n\n    # Write the configuration\n    config.save()\n\n    # Delete target from the filesystem\n    if (\n        target_path.is_dir()\n        and interactive\n        and yes_no_dialog(title=\"Confirm\", text=f\"Delete '{target_path}' from the filesystem?\").run()\n    ):\n        shutil.rmtree(target_path)\n</code></pre>"},{"location":"reference/cli/config/#sereto.cli.config.edit_config","title":"<code>edit_config(project)</code>","text":"<p>Edit the configuration file in default CLI editor.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>Project</code> <p>Project's representation.</p> required Source code in <code>sereto/cli/config.py</code> <pre><code>@validate_call\ndef edit_config(project: Project) -&gt; None:\n    \"\"\"Edit the configuration file in default CLI editor.\n\n    Args:\n        project: Project's representation.\n    \"\"\"\n    sereto_ver = importlib.metadata.version(\"sereto\")\n    config = project.config_path\n\n    # If the config file does not exist, create it with default values\n    if not project.config_path.is_file():\n        Config(\n            sereto_version=SeretoVersion.from_str(sereto_ver),\n            version_configs={\n                ProjectVersion.from_str(\"v1.0\"): VersionConfig(\n                    version=ProjectVersion.from_str(\"v1.0\"),\n                    id=\"\",\n                    name=\"\",\n                    version_description=\"Initial\",\n                    risk_due_dates=project.settings.risk_due_dates,\n                ),\n            },\n            path=project.config_path,\n            risk_due_dates=project.settings.risk_due_dates,\n        ).save()\n\n    # Open the config file in the default editor\n    click.edit(filename=str(config))\n</code></pre>"},{"location":"reference/cli/config/#sereto.cli.config.show_config","title":"<code>show_config(config, output_format, all=False, version=None)</code>","text":"<p>Display the configuration for a project.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>Configuration of the project.</p> required <code>output_format</code> <code>OutputFormat</code> <p>Format of the output.</p> required <code>all</code> <code>bool</code> <p>Whether to show values from all versions or just the last one.</p> <code>False</code> <code>version</code> <code>ProjectVersion | None</code> <p>Show config at specific version, e.g. 'v1.0'.</p> <code>None</code> Source code in <code>sereto/cli/config.py</code> <pre><code>@validate_call\ndef show_config(\n    config: Config, output_format: OutputFormat, all: bool = False, version: ProjectVersion | None = None\n) -&gt; None:\n    \"\"\"Display the configuration for a project.\n\n    Args:\n        config: Configuration of the project.\n        output_format: Format of the output.\n        all: Whether to show values from all versions or just the last one.\n        version: Show config at specific version, e.g. 'v1.0'.\n    \"\"\"\n    if version is None:\n        version = config.last_version\n\n    version_config = config.at_version(version)\n\n    match output_format:\n        case OutputFormat.table:\n            Console().print(f\"\\n\\n[blue]{version_config.id} - {version_config.name}\\n\", justify=\"center\")\n            show_targets_config(config=config, output_format=OutputFormat.table, all=all, version=version)\n            show_dates_config(config=config, output_format=OutputFormat.table, all=all, version=version)\n            show_people_config(config=config, output_format=OutputFormat.table, all=all, version=version)\n        case OutputFormat.json:\n            if all:\n                Console().print_json(config.to_model().model_dump_json())\n            else:\n                Console().print_json(version_config.to_model().model_dump_json())\n</code></pre>"},{"location":"reference/cli/config/#sereto.cli.config.show_dates_config","title":"<code>show_dates_config(config, output_format, all, version)</code>","text":"<p>Display the configured dates.</p> <p>By default, if neither of <code>version</code> and <code>all</code> arguments are used, dates from the latest version are displayed.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>Configuration of the project.</p> required <code>output_format</code> <code>OutputFormat</code> <p>Select format of the output.</p> required <code>all</code> <code>bool</code> <p>Show dates from all versions.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>Show dates from specific version.</p> required Source code in <code>sereto/cli/config.py</code> <pre><code>@validate_call\ndef show_dates_config(\n    config: Config,\n    output_format: OutputFormat,\n    all: bool,\n    version: ProjectVersion | None,\n) -&gt; None:\n    \"\"\"Display the configured dates.\n\n    By default, if neither of `version` and `all` arguments are used, dates from the latest version are displayed.\n\n    Args:\n        config: Configuration of the project.\n        output_format: Select format of the output.\n        all: Show dates from all versions.\n        version: Show dates from specific version.\n    \"\"\"\n    if version is None:\n        version = config.last_version\n\n    match output_format:\n        case OutputFormat.table:\n            for ver in config.versions if all else [version]:\n                Console().line()\n                table = _get_dates_table(version_config=config.at_version(version=ver).to_model(), version=ver)\n                Console().print(table, justify=\"center\")\n        case OutputFormat.json:\n            DateList: TypeAdapter[list[Date]] = TypeAdapter(list[Date])\n            DateAll: TypeAdapter[dict[str, list[Date]]] = TypeAdapter(dict[str, list[Date]])\n\n            if all:\n                all_dates = DateAll.validate_python(\n                    {str(ver): config.at_version(version=ver).dates for ver in config.versions}\n                )\n                Console().print_json(DateAll.dump_json(all_dates).decode(\"utf-8\"))\n            else:\n                dates = DateList.validate_python(config.at_version(version).dates)\n                Console().print_json(DateList.dump_json(dates).decode(\"utf-8\"))\n</code></pre>"},{"location":"reference/cli/config/#sereto.cli.config.show_people_config","title":"<code>show_people_config(config, output_format, all, version)</code>","text":"<p>Display the configured people.</p> <p>By default, if neither of <code>version</code> and <code>all</code> arguments are used, people from the latest version are displayed.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>Configuration of the project.</p> required <code>output_format</code> <code>OutputFormat</code> <p>Select format of the output.</p> required <code>all</code> <code>bool</code> <p>Show people from all versions.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>Show people from specific version.</p> required Source code in <code>sereto/cli/config.py</code> <pre><code>@validate_call\ndef show_people_config(config: Config, output_format: OutputFormat, all: bool, version: ProjectVersion | None) -&gt; None:\n    \"\"\"Display the configured people.\n\n    By default, if neither of `version` and `all` arguments are used, people from the latest version are displayed.\n\n    Args:\n        config: Configuration of the project.\n        output_format: Select format of the output.\n        all: Show people from all versions.\n        version: Show people from specific version.\n    \"\"\"\n    if version is None:\n        version = config.last_version\n\n    match output_format:\n        case OutputFormat.table:\n            for ver in config.versions if all else [version]:\n                Console().line()\n                table = _get_person_table(version_config=config.at_version(version=ver).to_model(), version=ver)\n                Console().print(table, justify=\"center\")\n        case OutputFormat.json:\n            PersonList: TypeAdapter[list[Person]] = TypeAdapter(list[Person])\n            PersonAll: TypeAdapter[dict[str, list[Person]]] = TypeAdapter(dict[str, list[Person]])\n\n            if all:\n                all_people = PersonAll.validate_python(\n                    {str(ver): config.at_version(version=ver).people for ver in config.versions}\n                )\n                Console().print_json(PersonAll.dump_json(all_people).decode(\"utf-8\"))\n            else:\n                people = PersonList.validate_python(config.at_version(version).people)\n                Console().print_json(PersonList.dump_json(people).decode(\"utf-8\"))\n</code></pre>"},{"location":"reference/cli/config/#sereto.cli.config.show_targets_config","title":"<code>show_targets_config(config, output_format, all, version)</code>","text":"<p>Display the configured targets.</p> <p>By default, if neither of <code>version</code> and <code>all</code> arguments are used, targets from the latest version are displayed.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>Configuration of the project.</p> required <code>output_format</code> <code>OutputFormat</code> <p>Select format of the output.</p> required <code>all</code> <code>bool</code> <p>Show targets from all versions.</p> required <code>version</code> <code>ProjectVersion | None</code> <p>Show targets from the specified project's version.</p> required Source code in <code>sereto/cli/config.py</code> <pre><code>@validate_call\ndef show_targets_config(\n    config: Config, output_format: OutputFormat, all: bool, version: ProjectVersion | None\n) -&gt; None:\n    \"\"\"Display the configured targets.\n\n    By default, if neither of `version` and `all` arguments are used, targets from the latest version are displayed.\n\n    Args:\n        config: Configuration of the project.\n        output_format: Select format of the output.\n        all: Show targets from all versions.\n        version: Show targets from the specified project's version.\n    \"\"\"\n    if version is None:\n        version = config.last_version\n\n    match output_format:\n        case OutputFormat.table:\n            for ver in config.versions if all else [version]:\n                Console().line()\n                table = _get_target_table(version_config=config.at_version(version=ver).to_model(), version=ver)\n                Console().print(table, justify=\"center\")\n        case OutputFormat.json:\n            TargetList: TypeAdapter[list[TargetModel]] = TypeAdapter(list[TargetModel])\n            TargetAll: TypeAdapter[dict[str, list[TargetModel]]] = TypeAdapter(dict[str, list[TargetModel]])\n\n            if all:\n                all_targets = TargetAll.validate_python(\n                    {\n                        str(ver): [t.to_model() for t in config.at_version(version=ver).targets]\n                        for ver in config.versions\n                    }\n                )\n                Console().print_json(TargetAll.dump_json(all_targets).decode(\"utf-8\"))\n            else:\n                target_models = [t.to_model() for t in config.at_version(version).targets]\n                targets = TargetList.validate_python(target_models)\n                Console().print_json(TargetList.dump_json(targets).decode(\"utf-8\"))\n</code></pre>"},{"location":"reference/cli/date/","title":"Date","text":""},{"location":"reference/cli/date/#sereto.cli.date","title":"<code>sereto.cli.date</code>","text":""},{"location":"reference/cli/date/#sereto.cli.date.prompt_user_for_date","title":"<code>prompt_user_for_date(date_type)</code>","text":"<p>Prompt user for a date or date range, depending on the provided date type.</p> <p>Date format is DD-Mmm-YYYY.</p> <p>Parameters:</p> Name Type Description Default <code>date_type</code> <code>DateType</code> <p>The type of date to prompt for.</p> required <p>Returns:</p> Type Description <code>SeretoDate | DateRange</code> <p>The date as provided by the user.</p> Source code in <code>sereto/cli/date.py</code> <pre><code>@validate_call\ndef prompt_user_for_date(date_type: DateType) -&gt; SeretoDate | DateRange:\n    \"\"\"Prompt user for a date or date range, depending on the provided date type.\n\n    Date format is DD-Mmm-YYYY.\n\n    Args:\n        date_type: The type of date to prompt for.\n\n    Returns:\n        The date as provided by the user.\n    \"\"\"\n    # Check if the date type allows for a range\n    allow_range = date_type in TYPES_WITH_ALLOWED_RANGE\n\n    while True:\n        # Prompt user for the start date\n        prompt: str = f\"Date{' start' if allow_range else ''} (DD-Mmm-YYYY)\"\n        if (start_date := _prompt_date(f\"{prompt}: \")) is None:\n            Console().print(\"[red]Invalid input, try again\\n\")\n            continue\n\n        # Prompt user for the end date, if the date type allows it\n        if allow_range:\n            if (end_date := _prompt_date(\"Date end (DD-Mmm-YYYY): \", default=start_date)) is None:\n                Console().print(\"[red]Invalid input, try again\\n\")\n                continue\n        else:\n            end_date = start_date\n\n        return DateRange(start=start_date, end=end_date) if start_date != end_date else start_date\n</code></pre>"},{"location":"reference/cli/finding/","title":"Finding","text":""},{"location":"reference/cli/finding/#sereto.cli.finding","title":"<code>sereto.cli.finding</code>","text":""},{"location":"reference/cli/finding/#sereto.cli.finding.show_findings","title":"<code>show_findings(version_config)</code>","text":"<p>Show the findings for a specific version.</p> <p>Parameters:</p> Name Type Description Default <code>version_config</code> <code>VersionConfig</code> <p>The project configuration for specific version.</p> required Source code in <code>sereto/cli/finding.py</code> <pre><code>@validate_call\ndef show_findings(version_config: VersionConfig) -&gt; None:\n    \"\"\"Show the findings for a specific version.\n\n    Args:\n        version_config: The project configuration for specific version.\n    \"\"\"\n    logger.info(\"Showing findings for version {}\", version_config.version)\n\n    for target in version_config.targets:\n        Console().line()\n        table = Table(\"Finding name\", \"Category\", \"Risk\", title=f\"Target {target.data.name}\")\n\n        for finding_group in target.findings.groups:\n            table.add_row(finding_group.name, target.data.category, finding_group.risk)\n\n        Console().print(table, justify=\"center\")\n</code></pre>"},{"location":"reference/cli/person/","title":"Person","text":""},{"location":"reference/cli/person/#sereto.cli.person","title":"<code>sereto.cli.person</code>","text":""},{"location":"reference/cli/person/#sereto.cli.person.prompt_user_for_person","title":"<code>prompt_user_for_person(person_type)</code>","text":"<p>Interactively prompt for a person's details.</p> <p>Parameters:</p> Name Type Description Default <code>person_type</code> <code>PersonType</code> <p>The type of person to prompt for.</p> required <p>Returns:</p> Type Description <code>Person</code> <p>The person as provided by the user.</p> Source code in <code>sereto/cli/person.py</code> <pre><code>@validate_call\ndef prompt_user_for_person(person_type: PersonType) -&gt; Person:\n    \"\"\"Interactively prompt for a person's details.\n\n    Args:\n        person_type: The type of person to prompt for.\n\n    Returns:\n        The person as provided by the user.\n    \"\"\"\n    name = prompt(\"Name: \")\n    business_unit = prompt(\"Business unit: \")\n    while True:\n        try:\n            e = prompt(\"Email: \")\n            ta: TypeAdapter[EmailStr] = TypeAdapter(EmailStr)  # hack for mypy\n            email: EmailStr | None = ta.validate_python(e) if len(e) &gt; 0 else None\n            break\n        except ValidationError:\n            Console().print(\"[red]Please enter valid email address\")\n    role = prompt(\"Role: \")\n\n    return Person(\n        type=person_type,\n        name=name if len(name) &gt; 0 else None,\n        business_unit=business_unit if len(business_unit) &gt; 0 else None,\n        email=email,\n        role=role if len(role) &gt; 0 else None,\n    )\n</code></pre>"},{"location":"reference/cli/target/","title":"Target","text":""},{"location":"reference/cli/target/#sereto.cli.target","title":"<code>sereto.cli.target</code>","text":""},{"location":"reference/cli/target/#sereto.cli.target.prompt_user_for_target","title":"<code>prompt_user_for_target(categories)</code>","text":"<p>Interactively prompt for a target's details.</p> <p>Parameters:</p> Name Type Description Default <code>categories</code> <code>Iterable[str]</code> <p>List of all categories to present to the user for selection.</p> required <p>Returns:</p> Type Description <code>TargetModel</code> <p>The target as provided by the user.</p> Source code in <code>sereto/cli/target.py</code> <pre><code>def prompt_user_for_target(categories: Iterable[str]) -&gt; TargetModel:\n    \"\"\"Interactively prompt for a target's details.\n\n    Args:\n        categories: List of all categories to present to the user for selection.\n\n    Returns:\n        The target as provided by the user.\n    \"\"\"\n    Console().line()\n    category = radiolist_dialog(\n        title=\"New target\",\n        text=\"Category:\",\n        values=[(c, c.upper()) for c in categories],\n    ).run()\n    name = prompt(\"Name: \")\n\n    match category:\n        case \"dast\":\n            target: TargetModel = TargetDastModel(category=category, name=name)\n        case \"sast\":\n            target = TargetSastModel(category=category, name=name)\n        case \"mobile\":\n            target = TargetMobileModel(category=category, name=name)\n        case _:\n            target = TargetModel(category=category, name=name)\n\n    target_edited = click.edit(target.model_dump_json(indent=2), extension=\".json\", require_save=False)\n\n    if target_edited is None:\n        raise SeretoRuntimeError(\"aborting, editor closed without saving\")\n\n    return TargetModel.model_validate_json(target_edited)\n</code></pre>"},{"location":"reference/cli/utils/","title":"Utils","text":""},{"location":"reference/cli/utils/#sereto.cli.utils","title":"<code>sereto.cli.utils</code>","text":""},{"location":"reference/cli/utils/#sereto.cli.utils.AliasedGroup","title":"<code>AliasedGroup</code>","text":"<p>               Bases: <code>Group</code></p> <p>A click Group subclass that allows for writing aliases and prefixes of any command.</p> Source code in <code>sereto/cli/utils.py</code> <pre><code>class AliasedGroup(click.Group):\n    \"\"\"A click Group subclass that allows for writing aliases and prefixes of any command.\"\"\"\n\n    def get_command(self, ctx: click.core.Context, cmd_name: str) -&gt; click.Command | None:\n        \"\"\"Retrieves the command with the given name.\n\n        If the command is not found, it looks up an explicit command alias or a command prefix.\n\n        Args:\n            ctx: The click context object.\n            cmd_name: The name of the command to retrieve.\n\n        Returns:\n            The command with the given name, or None if no command is found.\n        \"\"\"\n        # built-in commands\n        rv = click.Group.get_command(self, ctx, cmd_name)\n        if rv is not None:\n            return rv\n\n        # look up an explicit command alias\n        if cmd_name in cli_aliases:\n            actual_cmd = cli_aliases[cmd_name]\n            return click.Group.get_command(self, ctx, actual_cmd)\n\n        # look up a command prefix\n        matches = [x for x in self.list_commands(ctx) if x.lower().startswith(cmd_name.lower())]\n        if not matches:\n            return None\n        elif len(matches) == 1:\n            return click.Group.get_command(self, ctx, matches[0])\n        ctx.fail(f\"Too many matches: {', '.join(sorted(matches))}\")\n\n    def resolve_command(\n        self, ctx: click.core.Context, args: list[str]\n    ) -&gt; tuple[str | None, click.Command | None, list[str]]:\n        \"\"\"Resolves the full command's name.\"\"\"\n        _, cmd, args = super().resolve_command(ctx, args)\n        if cmd is None:\n            ctx.fail(\"No such command\")\n        return cmd.name, cmd, args\n</code></pre>"},{"location":"reference/cli/utils/#sereto.cli.utils.AliasedGroup.get_command","title":"<code>get_command(ctx, cmd_name)</code>","text":"<p>Retrieves the command with the given name.</p> <p>If the command is not found, it looks up an explicit command alias or a command prefix.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The click context object.</p> required <code>cmd_name</code> <code>str</code> <p>The name of the command to retrieve.</p> required <p>Returns:</p> Type Description <code>Command | None</code> <p>The command with the given name, or None if no command is found.</p> Source code in <code>sereto/cli/utils.py</code> <pre><code>def get_command(self, ctx: click.core.Context, cmd_name: str) -&gt; click.Command | None:\n    \"\"\"Retrieves the command with the given name.\n\n    If the command is not found, it looks up an explicit command alias or a command prefix.\n\n    Args:\n        ctx: The click context object.\n        cmd_name: The name of the command to retrieve.\n\n    Returns:\n        The command with the given name, or None if no command is found.\n    \"\"\"\n    # built-in commands\n    rv = click.Group.get_command(self, ctx, cmd_name)\n    if rv is not None:\n        return rv\n\n    # look up an explicit command alias\n    if cmd_name in cli_aliases:\n        actual_cmd = cli_aliases[cmd_name]\n        return click.Group.get_command(self, ctx, actual_cmd)\n\n    # look up a command prefix\n    matches = [x for x in self.list_commands(ctx) if x.lower().startswith(cmd_name.lower())]\n    if not matches:\n        return None\n    elif len(matches) == 1:\n        return click.Group.get_command(self, ctx, matches[0])\n    ctx.fail(f\"Too many matches: {', '.join(sorted(matches))}\")\n</code></pre>"},{"location":"reference/cli/utils/#sereto.cli.utils.AliasedGroup.resolve_command","title":"<code>resolve_command(ctx, args)</code>","text":"<p>Resolves the full command's name.</p> Source code in <code>sereto/cli/utils.py</code> <pre><code>def resolve_command(\n    self, ctx: click.core.Context, args: list[str]\n) -&gt; tuple[str | None, click.Command | None, list[str]]:\n    \"\"\"Resolves the full command's name.\"\"\"\n    _, cmd, args = super().resolve_command(ctx, args)\n    if cmd is None:\n        ctx.fail(\"No such command\")\n    return cmd.name, cmd, args\n</code></pre>"},{"location":"reference/cli/utils/#sereto.cli.utils.Console","title":"<code>Console</code>","text":"<p>               Bases: <code>Console</code></p> <p>Singleton wrapper around Rich's Console.</p> Source code in <code>sereto/cli/utils.py</code> <pre><code>class Console(RichConsole, metaclass=Singleton):\n    \"\"\"Singleton wrapper around Rich's Console.\"\"\"\n</code></pre>"},{"location":"reference/cli/utils/#sereto.cli.utils.load_enum","title":"<code>load_enum(enum, message)</code>","text":"<p>Let user select a value from enum.</p> Source code in <code>sereto/cli/utils.py</code> <pre><code>def load_enum[E: Enum](enum: type[E], message: str) -&gt; E:\n    \"\"\"Let user select a value from enum.\"\"\"\n    choice = radiolist_dialog(\n        title=\"Select value\",\n        text=message,\n        values=[(e.name, e.value) for e in enum],\n    ).run()\n\n    return enum(choice)\n</code></pre>"},{"location":"reference/models/base/","title":"Base","text":""},{"location":"reference/models/base/#sereto.models.base","title":"<code>sereto.models.base</code>","text":""},{"location":"reference/models/base/#sereto.models.base.SeretoBaseModel","title":"<code>SeretoBaseModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic BaseModel with custom strict configuration.</p> <p>This class is a subclass of pydantic's BaseModel. It is used to define custom configuration for Pydantic models.</p> Source code in <code>sereto/models/base.py</code> <pre><code>class SeretoBaseModel(BaseModel):\n    \"\"\"Pydantic BaseModel with custom strict configuration.\n\n    This class is a subclass of pydantic's BaseModel. It is used to define custom configuration for Pydantic models.\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\", strict=True, validate_assignment=True)\n</code></pre>"},{"location":"reference/models/base/#sereto.models.base.SeretoBaseSettings","title":"<code>SeretoBaseSettings</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Pydantic's BaseSettings with custom configuration.</p> Source code in <code>sereto/models/base.py</code> <pre><code>class SeretoBaseSettings(BaseSettings):\n    \"\"\"Pydantic's BaseSettings with custom configuration.\"\"\"\n\n    model_config = SettingsConfigDict(\n        env_prefix=\"SERETO_\",\n        extra=\"forbid\",\n        # strict=True,\n        validate_assignment=True,\n    )\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n        \"\"\"Define the sources and their order for loading the settings values.\n\n        Args:\n            settings_cls: The Settings class.\n            init_settings: The `InitSettingsSource` instance.\n            env_settings: The `EnvSettingsSource` instance.\n            dotenv_settings: The `DotEnvSettingsSource` instance.\n            file_secret_settings: The `SecretsSettingsSource` instance.\n\n        Returns:\n            A tuple containing the sources and their order for loading the settings values.\n        \"\"\"\n        return env_settings, init_settings, dotenv_settings, file_secret_settings\n</code></pre>"},{"location":"reference/models/base/#sereto.models.base.SeretoBaseSettings.settings_customise_sources","title":"<code>settings_customise_sources(settings_cls, init_settings, env_settings, dotenv_settings, file_secret_settings)</code>  <code>classmethod</code>","text":"<p>Define the sources and their order for loading the settings values.</p> <p>Parameters:</p> Name Type Description Default <code>settings_cls</code> <code>type[BaseSettings]</code> <p>The Settings class.</p> required <code>init_settings</code> <code>PydanticBaseSettingsSource</code> <p>The <code>InitSettingsSource</code> instance.</p> required <code>env_settings</code> <code>PydanticBaseSettingsSource</code> <p>The <code>EnvSettingsSource</code> instance.</p> required <code>dotenv_settings</code> <code>PydanticBaseSettingsSource</code> <p>The <code>DotEnvSettingsSource</code> instance.</p> required <code>file_secret_settings</code> <code>PydanticBaseSettingsSource</code> <p>The <code>SecretsSettingsSource</code> instance.</p> required <p>Returns:</p> Type Description <code>tuple[PydanticBaseSettingsSource, ...]</code> <p>A tuple containing the sources and their order for loading the settings values.</p> Source code in <code>sereto/models/base.py</code> <pre><code>@classmethod\ndef settings_customise_sources(\n    cls,\n    settings_cls: type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n    \"\"\"Define the sources and their order for loading the settings values.\n\n    Args:\n        settings_cls: The Settings class.\n        init_settings: The `InitSettingsSource` instance.\n        env_settings: The `EnvSettingsSource` instance.\n        dotenv_settings: The `DotEnvSettingsSource` instance.\n        file_secret_settings: The `SecretsSettingsSource` instance.\n\n    Returns:\n        A tuple containing the sources and their order for loading the settings values.\n    \"\"\"\n    return env_settings, init_settings, dotenv_settings, file_secret_settings\n</code></pre>"},{"location":"reference/models/config/","title":"Config","text":""},{"location":"reference/models/config/#sereto.models.config","title":"<code>sereto.models.config</code>","text":""},{"location":"reference/models/config/#sereto.models.config.ConfigModel","title":"<code>ConfigModel</code>","text":"<p>               Bases: <code>SeretoBaseModel</code></p> <p>Model representing the full project configuration in config.json file.</p> <p>Attributes:</p> Name Type Description <code>sereto_version</code> <code>SeretoVersion</code> <p>Version of SeReTo which produced the config.</p> <code>version_configs</code> <code>dict[ProjectVersion, VersionConfigModel]</code> <p>Configuration for each version of the Project.</p> Source code in <code>sereto/models/config.py</code> <pre><code>class ConfigModel(SeretoBaseModel):\n    \"\"\"Model representing the full project configuration in config.json file.\n\n    Attributes:\n        sereto_version: Version of SeReTo which produced the config.\n        version_configs: Configuration for each version of the Project.\n    \"\"\"\n\n    sereto_version: SeretoVersion\n    version_configs: dict[ProjectVersion, VersionConfigModel]\n\n    @classmethod\n    @validate_call\n    def load_from(cls, file: FilePath) -&gt; Self:\n        \"\"\"Load the configuration from a JSON file.\n\n        Args:\n            file: The path to the configuration file.\n\n        Returns:\n            The configuration object.\n\n        Raises:\n            SeretoPathError: If the file is not found or permission is denied.\n            SeretoValueError: If the configuration is invalid.\n        \"\"\"\n        try:\n            return cls.model_validate_json(file.read_bytes())\n        except FileNotFoundError:\n            raise SeretoPathError(f\"file not found at '{file}'\") from None\n        except PermissionError:\n            raise SeretoPathError(f\"permission denied for '{file}'\") from None\n        except ValidationError as e:\n            raise SeretoValueError(f\"invalid config\\n\\n{e}\") from e\n</code></pre>"},{"location":"reference/models/config/#sereto.models.config.ConfigModel.load_from","title":"<code>load_from(file)</code>  <code>classmethod</code>","text":"<p>Load the configuration from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>FilePath</code> <p>The path to the configuration file.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The configuration object.</p> <p>Raises:</p> Type Description <code>SeretoPathError</code> <p>If the file is not found or permission is denied.</p> <code>SeretoValueError</code> <p>If the configuration is invalid.</p> Source code in <code>sereto/models/config.py</code> <pre><code>@classmethod\n@validate_call\ndef load_from(cls, file: FilePath) -&gt; Self:\n    \"\"\"Load the configuration from a JSON file.\n\n    Args:\n        file: The path to the configuration file.\n\n    Returns:\n        The configuration object.\n\n    Raises:\n        SeretoPathError: If the file is not found or permission is denied.\n        SeretoValueError: If the configuration is invalid.\n    \"\"\"\n    try:\n        return cls.model_validate_json(file.read_bytes())\n    except FileNotFoundError:\n        raise SeretoPathError(f\"file not found at '{file}'\") from None\n    except PermissionError:\n        raise SeretoPathError(f\"permission denied for '{file}'\") from None\n    except ValidationError as e:\n        raise SeretoValueError(f\"invalid config\\n\\n{e}\") from e\n</code></pre>"},{"location":"reference/models/config/#sereto.models.config.VersionConfigModel","title":"<code>VersionConfigModel</code>","text":"<p>               Bases: <code>SeretoBaseModel</code></p> <p>Model with core attributes for a specific version of the project configuration.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The ID of the project.</p> <code>name</code> <code>str</code> <p>The name of the project.</p> <code>version_description</code> <code>str</code> <p>The description of the version (e.g. \"retest\").</p> <code>targets</code> <code>list[TargetModel]</code> <p>List of targets.</p> <code>dates</code> <code>list[Date]</code> <p>List of dates.</p> <code>people</code> <code>list[Person]</code> <p>List of people.</p> Source code in <code>sereto/models/config.py</code> <pre><code>class VersionConfigModel(SeretoBaseModel):\n    \"\"\"Model with core attributes for a specific version of the project configuration.\n\n    Attributes:\n        id: The ID of the project.\n        name: The name of the project.\n        version_description: The description of the version (e.g. \"retest\").\n        targets: List of targets.\n        dates: List of dates.\n        people: List of people.\n    \"\"\"\n\n    id: str\n    name: str\n    version_description: str\n    targets: list[TargetModel] = Field(default_factory=list)\n    dates: list[Date] = Field(default_factory=list)\n    people: list[Person] = Field(default_factory=list)\n\n    @model_validator(mode=\"after\")\n    def unique_target_names(self) -&gt; Self:\n        unames = [target.uname for target in self.targets]\n        if len(unames) != len(set(unames)):\n            raise ValueError(\"duplicate target uname\")\n        return self\n</code></pre>"},{"location":"reference/models/date/","title":"Date","text":""},{"location":"reference/models/date/#sereto.models.date","title":"<code>sereto.models.date</code>","text":""},{"location":"reference/models/date/#sereto.models.date.Date","title":"<code>Date</code>","text":"<p>               Bases: <code>SeretoBaseModel</code></p> <p>Model representing a date with its associated event.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>DateType</code> <p>Type of the event.</p> <code>date</code> <code>SeretoDate | DateRange</code> <p>Date or date range.</p> Source code in <code>sereto/models/date.py</code> <pre><code>class Date(SeretoBaseModel):\n    \"\"\"Model representing a date with its associated event.\n\n    Attributes:\n        type (DateType): Type of the event.\n        date (SeretoDate | DateRange): Date or date range.\n    \"\"\"\n\n    type: DateType\n    date: SeretoDate | DateRange\n\n    @model_validator(mode=\"after\")\n    def range_allowed(self) -&gt; \"Date\":\n        if isinstance(self.date, DateRange) and self.type not in TYPES_WITH_ALLOWED_RANGE:\n            raise ValueError(f\"type {self.type} does not have allowed date range, only single date\")\n        return self\n\n    def __str__(self) -&gt; str:\n        match self.date:\n            case SeretoDate():\n                return str(self.date)\n            case DateRange():\n                return f\"{self.date.start} to {self.date.end}\"\n\n    def __hash__(self) -&gt; int:\n        return hash((self.type, self.date))\n</code></pre>"},{"location":"reference/models/date/#sereto.models.date.DateRange","title":"<code>DateRange</code>","text":"<p>               Bases: <code>SeretoBaseModel</code></p> <p>Model representing a period of time with start and end date.</p> <p><code>start</code> cannot be equal to <code>end</code>. In that case you should use <code>SeretoDate</code>.</p> <p>Attributes:</p> Name Type Description <code>start</code> <code>SeretoDate</code> <p>Start date of the period.</p> <code>end</code> <code>SeretoDate</code> <p>End date of the period.</p> Source code in <code>sereto/models/date.py</code> <pre><code>class DateRange(SeretoBaseModel):\n    \"\"\"Model representing a period of time with start and end date.\n\n    `start` cannot be equal to `end`. In that case you should use `SeretoDate`.\n\n    Attributes:\n        start (SeretoDate): Start date of the period.\n        end (SeretoDate): End date of the period.\n    \"\"\"\n\n    start: SeretoDate\n    end: SeretoDate\n\n    @model_validator(mode=\"after\")\n    def chronological_order(self) -&gt; \"DateRange\":\n        if self.start &gt;= self.end:\n            raise ValueError(\"DateRange type forbids start after or equal to end\")\n        return self\n\n    def __hash__(self) -&gt; int:\n        return hash((self.start, self.end))\n</code></pre>"},{"location":"reference/models/date/#sereto.models.date.DateType","title":"<code>DateType</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum representing the event type for date.</p> Source code in <code>sereto/models/date.py</code> <pre><code>class DateType(StrEnum):\n    \"\"\"Enum representing the event type for date.\"\"\"\n\n    sow_sent = \"sow_sent\"\n    pentest_ongoing = \"pentest_ongoing\"\n    review = \"review\"\n    report_sent = \"report_sent\"\n</code></pre>"},{"location":"reference/models/date/#sereto.models.date.SeretoDate","title":"<code>SeretoDate</code>","text":"<p>               Bases: <code>RootModel[date]</code></p> <p>Date representation for Pydantic with format <code>%d-%b-%Y</code>.</p> <p>The <code>%d-%b-%Y</code> format string specifies the format of the date string as follows:</p> <ul> <li><code>%d</code>: Day of the month as a zero-padded decimal number (e.g. 01, 02, ..., 31).</li> <li><code>%b</code>: Month abbreviation in the current locale's abbreviated name (e.g. Jan, Feb, ..., Dec).</li> <li><code>%Y</code>: Year with century as a decimal number (e.g. 2021, 2022, ...).</li> </ul> Source code in <code>sereto/models/date.py</code> <pre><code>@total_ordering\nclass SeretoDate(RootModel[date]):\n    \"\"\"Date representation for Pydantic with format `%d-%b-%Y`.\n\n    The `%d-%b-%Y` format string specifies the format of the date string as follows:\n\n     - `%d`: Day of the month as a zero-padded decimal number (e.g. 01, 02, ..., 31).\n     - `%b`: Month abbreviation in the current locale's abbreviated name (e.g. Jan, Feb, ..., Dec).\n     - `%Y`: Year with century as a decimal number (e.g. 2021, 2022, ...).\n    \"\"\"\n\n    root: date\n\n    @field_validator(\"root\", mode=\"before\")\n    @classmethod\n    def convert_date(cls, v: Any) -&gt; date:\n        match v:\n            case SeretoDate():\n                return v.root\n            case str():\n                return datetime.strptime(v, r\"%d-%b-%Y\").date()\n            case _:\n                raise ValueError(\"invalid type, use string or date\")\n\n    @classmethod\n    def from_str(cls, v: str, fmt: str = r\"%d-%b-%Y\") -&gt; \"SeretoDate\":\n        \"\"\"Create a SeretoDate instance from a string.\n\n        Args:\n            v: String to convert.\n            fmt: Format of the input string.\n\n        Returns:\n            The resulting SeretoDate instance.\n        \"\"\"\n        date = datetime.strptime(v, fmt).date()\n        return cls.model_construct(root=date)\n\n    @field_serializer(\"root\")\n    def serialize_root(self, root: date, info: FieldSerializationInfo) -&gt; str:\n        return self.__str__()\n\n    def __str__(self) -&gt; str:\n        return self.root.strftime(r\"%d-%b-%Y\")\n\n    def __lt__(self, other: Any) -&gt; bool:\n        if not isinstance(other, SeretoDate):\n            raise SeretoValueError(\"comparing SeretoDate with unsupported type\")\n        return self.root &lt; other.root\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if not isinstance(other, SeretoDate):\n            raise SeretoValueError(\"comparing SeretoDate with unsupported type\")\n        return self.root == other.root\n\n    def __add__(self, other: Any) -&gt; \"SeretoDate\":\n        if not isinstance(other, timedelta):\n            raise SeretoValueError(\"adding SeretoDate with unsupported type\")\n        return SeretoDate.model_construct(root=self.root + other)\n\n    def __hash__(self) -&gt; int:\n        return hash(self.root)\n\n    def raw(self) -&gt; date:\n        return self.root\n</code></pre>"},{"location":"reference/models/date/#sereto.models.date.SeretoDate.from_str","title":"<code>from_str(v, fmt='%d-%b-%Y')</code>  <code>classmethod</code>","text":"<p>Create a SeretoDate instance from a string.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>String to convert.</p> required <code>fmt</code> <code>str</code> <p>Format of the input string.</p> <code>'%d-%b-%Y'</code> <p>Returns:</p> Type Description <code>SeretoDate</code> <p>The resulting SeretoDate instance.</p> Source code in <code>sereto/models/date.py</code> <pre><code>@classmethod\ndef from_str(cls, v: str, fmt: str = r\"%d-%b-%Y\") -&gt; \"SeretoDate\":\n    \"\"\"Create a SeretoDate instance from a string.\n\n    Args:\n        v: String to convert.\n        fmt: Format of the input string.\n\n    Returns:\n        The resulting SeretoDate instance.\n    \"\"\"\n    date = datetime.strptime(v, fmt).date()\n    return cls.model_construct(root=date)\n</code></pre>"},{"location":"reference/models/finding/","title":"Finding","text":""},{"location":"reference/models/finding/#sereto.models.finding","title":"<code>sereto.models.finding</code>","text":""},{"location":"reference/models/finding/#sereto.models.finding.FindingGroupModel","title":"<code>FindingGroupModel</code>","text":"<p>               Bases: <code>SeretoBaseModel</code></p> <p>Representation of a single finding group from <code>findings.toml</code>.</p> <p>Attributes:</p> Name Type Description <code>risks</code> <p>Explicit risks associated with the finding group for specific versions.</p> <code>findings</code> <code>list[str]</code> <p>The list of sub-findings in the format of their unique name to include in the report.</p> <code>locators</code> <code>list[LocatorModel]</code> <p>A list of locators used to find the finding group.</p> <code>show_locator_types</code> <code>list[str]</code> <p>A list of locator types to return from the FindingGroup.locators() property.</p> Source code in <code>sereto/models/finding.py</code> <pre><code>class FindingGroupModel(SeretoBaseModel):\n    \"\"\"Representation of a single finding group from `findings.toml`.\n\n    Attributes:\n        risks: Explicit risks associated with the finding group for specific versions.\n        findings: The list of sub-findings in the format of their unique name to include in the report.\n        locators: A list of locators used to find the finding group.\n        show_locator_types: A list of locator types to return from the FindingGroup.locators() property.\n    \"\"\"\n\n    risk: Risk | None = None\n    findings: list[str] = Field(min_length=1)\n    locators: list[LocatorModel] = Field(default_factory=list)\n    show_locator_types: list[str] = Field(default_factory=get_locator_types)\n\n    @field_validator(\"risk\", mode=\"before\")\n    @classmethod\n    def load_risk(cls, risk: Any) -&gt; Risk | None:\n        \"\"\"Convert risk to correct type.\"\"\"\n        match risk:\n            case Risk() | None:\n                return risk\n            case str():\n                return Risk(risk)\n            case _:\n                raise ValueError(\"invalid risk type\")\n\n    @field_validator(\"findings\", mode=\"after\")\n    @classmethod\n    def unique_finding_names(cls, findings: list[str]) -&gt; list[str]:\n        \"\"\"Ensure that all finding names are unique.\"\"\"\n        if len(findings) != len(set(findings)):\n            raise ValueError(\"finding names must be unique\")\n        return findings\n</code></pre>"},{"location":"reference/models/finding/#sereto.models.finding.FindingGroupModel.load_risk","title":"<code>load_risk(risk)</code>  <code>classmethod</code>","text":"<p>Convert risk to correct type.</p> Source code in <code>sereto/models/finding.py</code> <pre><code>@field_validator(\"risk\", mode=\"before\")\n@classmethod\ndef load_risk(cls, risk: Any) -&gt; Risk | None:\n    \"\"\"Convert risk to correct type.\"\"\"\n    match risk:\n        case Risk() | None:\n            return risk\n        case str():\n            return Risk(risk)\n        case _:\n            raise ValueError(\"invalid risk type\")\n</code></pre>"},{"location":"reference/models/finding/#sereto.models.finding.FindingGroupModel.unique_finding_names","title":"<code>unique_finding_names(findings)</code>  <code>classmethod</code>","text":"<p>Ensure that all finding names are unique.</p> Source code in <code>sereto/models/finding.py</code> <pre><code>@field_validator(\"findings\", mode=\"after\")\n@classmethod\ndef unique_finding_names(cls, findings: list[str]) -&gt; list[str]:\n    \"\"\"Ensure that all finding names are unique.\"\"\"\n    if len(findings) != len(set(findings)):\n        raise ValueError(\"finding names must be unique\")\n    return findings\n</code></pre>"},{"location":"reference/models/finding/#sereto.models.finding.FindingTemplateFrontmatterModel","title":"<code>FindingTemplateFrontmatterModel</code>","text":"<p>               Bases: <code>SeretoBaseModel</code></p> <p>Representation of the frontmatter of a finding template.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the sub-finding.</p> <code>risk</code> <code>Risk</code> <p>The risk level of the sub-finding.</p> <code>keywords</code> <code>list[str]</code> <p>A list of keywords used to search for the sub-finding.</p> <code>variables</code> <code>list[VarsMetadataModel]</code> <p>A list of variables used in the sub-finding.</p> Source code in <code>sereto/models/finding.py</code> <pre><code>class FindingTemplateFrontmatterModel(SeretoBaseModel):\n    \"\"\"Representation of the frontmatter of a finding template.\n\n    Attributes:\n        name: The name of the sub-finding.\n        risk: The risk level of the sub-finding.\n        keywords: A list of keywords used to search for the sub-finding.\n        variables: A list of variables used in the sub-finding.\n    \"\"\"\n\n    name: str\n    risk: Risk\n    keywords: list[str] = []\n    variables: list[VarsMetadataModel] = []\n\n    @field_validator(\"risk\", mode=\"before\")\n    @classmethod\n    def convert_risk_type(cls, risk: Any) -&gt; Risk:\n        match risk:\n            case Risk():\n                return risk\n            case str():\n                return Risk(risk)\n            case _:\n                raise ValueError(\"unsupported type for Risk\")\n\n    @classmethod\n    @validate_call\n    def load_from(cls, path: Path) -&gt; Self:\n        \"\"\"Load FindingTemplateFrontmatterModel from a file.\"\"\"\n        try:\n            metadata, _ = frontmatter.parse(path.read_text(encoding=\"utf-8\"), encoding=\"utf-8\")\n            return cls.model_validate(metadata)\n        except ValidationError as ex:\n            raise SeretoValueError(f\"invalid template frontmatter in '{path}'\") from ex\n</code></pre>"},{"location":"reference/models/finding/#sereto.models.finding.FindingTemplateFrontmatterModel.load_from","title":"<code>load_from(path)</code>  <code>classmethod</code>","text":"<p>Load FindingTemplateFrontmatterModel from a file.</p> Source code in <code>sereto/models/finding.py</code> <pre><code>@classmethod\n@validate_call\ndef load_from(cls, path: Path) -&gt; Self:\n    \"\"\"Load FindingTemplateFrontmatterModel from a file.\"\"\"\n    try:\n        metadata, _ = frontmatter.parse(path.read_text(encoding=\"utf-8\"), encoding=\"utf-8\")\n        return cls.model_validate(metadata)\n    except ValidationError as ex:\n        raise SeretoValueError(f\"invalid template frontmatter in '{path}'\") from ex\n</code></pre>"},{"location":"reference/models/finding/#sereto.models.finding.FindingsConfigModel","title":"<code>FindingsConfigModel</code>","text":"<p>               Bases: <code>RootModel[dict[str, FindingGroupModel]]</code></p> <p>Model representing the included findings configuration.</p> <p>The data itself is expected to be a dict where each key is the name of a finding group and the value is a FindingGroupModel.</p> Source code in <code>sereto/models/finding.py</code> <pre><code>class FindingsConfigModel(RootModel[dict[str, FindingGroupModel]]):\n    \"\"\"Model representing the included findings configuration.\n\n    The data itself is expected to be a dict where each key is\n    the name of a finding group and the value is a FindingGroupModel.\n    \"\"\"\n\n    root: dict[str, FindingGroupModel]\n\n    @field_validator(\"root\", mode=\"after\")\n    @classmethod\n    def unique_findings(cls, findings: dict[str, FindingGroupModel]) -&gt; dict[str, FindingGroupModel]:\n        all_findings: list[str] = []\n        for _, group in findings.items():\n            all_findings.extend(group.findings)\n        if len(all_findings) != len(set(all_findings)):\n            raise ValueError(\"each sub-finding must be included only once\")\n        return findings\n\n    @classmethod\n    @validate_call\n    def load_from(cls, file: FilePath) -&gt; Self:\n        try:\n            with file.open(mode=\"rb\") as f:\n                return cls.model_validate(tomllib.load(f))\n        except FileNotFoundError:\n            raise SeretoPathError(f\"file not found at '{file}'\") from None\n        except PermissionError:\n            raise SeretoPathError(f\"permission denied for '{file}'\") from None\n        except ValueError as e:\n            raise SeretoValueError(\"invalid findings.toml\") from e\n\n    def items(self) -&gt; ItemsView[str, FindingGroupModel]:\n        return self.root.items()\n</code></pre>"},{"location":"reference/models/finding/#sereto.models.finding.SubFindingFrontmatterModel","title":"<code>SubFindingFrontmatterModel</code>","text":"<p>               Bases: <code>SeretoBaseModel</code></p> <p>Frontmatter metadata for a sub-finding included in a project.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Sub-finding display name.</p> <code>risk</code> <code>Risk</code> <p>Risk classification of the sub-finding.</p> <code>category</code> <code>TypeCategoryName</code> <p>Category from which the sub-finding originates.</p> <code>variables</code> <code>dict[str, Any]</code> <p>Variable values injected into the sub-finding.</p> <code>template_path</code> <code>str | None</code> <p>Relative path to the sub-finding template file.</p> <code>locators</code> <code>list[LocatorModel]</code> <p>A list of locators used to find the sub-finding.</p> <code>format</code> <code>FileFormat</code> <p>The file format of the sub-finding (defaults to markdown).</p> <code>reported_on</code> <code>SeretoDate | None</code> <p>Date the finding was first reported. Only useful if introduced later.</p> Source code in <code>sereto/models/finding.py</code> <pre><code>class SubFindingFrontmatterModel(SeretoBaseModel):\n    \"\"\"Frontmatter metadata for a sub-finding included in a project.\n\n    Attributes:\n        name: Sub-finding display name.\n        risk: Risk classification of the sub-finding.\n        category: Category from which the sub-finding originates.\n        variables: Variable values injected into the sub-finding.\n        template_path: Relative path to the sub-finding template file.\n        locators: A list of locators used to find the sub-finding.\n        format: The file format of the sub-finding (defaults to markdown).\n        reported_on: Date the finding was first reported. Only useful if introduced later.\n    \"\"\"\n\n    name: str\n    risk: Risk\n    category: TypeCategoryName\n    variables: dict[str, Any] = {}\n    template_path: str | None = None\n    locators: list[LocatorModel] = Field(default_factory=list)\n    format: FileFormat = Field(default=FileFormat.md)\n    reported_on: SeretoDate | None = None\n\n    @field_validator(\"risk\", mode=\"before\")\n    @classmethod\n    def convert_risk_type(cls, risk: Any) -&gt; Risk:\n        \"\"\"Convert risk to Risk enum.\"\"\"\n        match risk:\n            case Risk():\n                return risk\n            case str():\n                return Risk(risk)\n            case _:\n                raise ValueError(\"unsupported type for Risk\")\n\n    def dumps_toml(self) -&gt; str:\n        \"\"\"Dump the model to a TOML-formatted string using a TOML library.\"\"\"\n        # Prepare the data dict in the desired structure\n        data: dict[str, Any] = {\n            \"name\": self.name,\n            \"risk\": self.risk.value,\n            \"category\": self.category.lower(),\n            \"locators\": [locator.model_dump(exclude_none=True) for locator in self.locators],\n        }\n        if self.template_path:\n            data[\"template_path\"] = self.template_path\n        if len(self.variables) &gt; 0 and any(v is not None for v in self.variables.values()):\n            data[\"variables\"] = {k: v for k, v in self.variables.items() if v is not None}\n\n        # Dump to TOML string\n        return toml_dumps(data)\n\n    @classmethod\n    @validate_call\n    def load_from(cls, path: Path) -&gt; Self:\n        \"\"\"Load FindingFrontmatterModel from a file.\"\"\"\n        try:\n            metadata, _ = frontmatter.parse(path.read_text(encoding=\"utf-8\"), encoding=\"utf-8\")\n            return cls.model_validate(metadata)\n        except ValidationError as ex:\n            raise SeretoValueError(f\"invalid finding frontmatter in '{path}'\") from ex\n</code></pre>"},{"location":"reference/models/finding/#sereto.models.finding.SubFindingFrontmatterModel.convert_risk_type","title":"<code>convert_risk_type(risk)</code>  <code>classmethod</code>","text":"<p>Convert risk to Risk enum.</p> Source code in <code>sereto/models/finding.py</code> <pre><code>@field_validator(\"risk\", mode=\"before\")\n@classmethod\ndef convert_risk_type(cls, risk: Any) -&gt; Risk:\n    \"\"\"Convert risk to Risk enum.\"\"\"\n    match risk:\n        case Risk():\n            return risk\n        case str():\n            return Risk(risk)\n        case _:\n            raise ValueError(\"unsupported type for Risk\")\n</code></pre>"},{"location":"reference/models/finding/#sereto.models.finding.SubFindingFrontmatterModel.dumps_toml","title":"<code>dumps_toml()</code>","text":"<p>Dump the model to a TOML-formatted string using a TOML library.</p> Source code in <code>sereto/models/finding.py</code> <pre><code>def dumps_toml(self) -&gt; str:\n    \"\"\"Dump the model to a TOML-formatted string using a TOML library.\"\"\"\n    # Prepare the data dict in the desired structure\n    data: dict[str, Any] = {\n        \"name\": self.name,\n        \"risk\": self.risk.value,\n        \"category\": self.category.lower(),\n        \"locators\": [locator.model_dump(exclude_none=True) for locator in self.locators],\n    }\n    if self.template_path:\n        data[\"template_path\"] = self.template_path\n    if len(self.variables) &gt; 0 and any(v is not None for v in self.variables.values()):\n        data[\"variables\"] = {k: v for k, v in self.variables.items() if v is not None}\n\n    # Dump to TOML string\n    return toml_dumps(data)\n</code></pre>"},{"location":"reference/models/finding/#sereto.models.finding.SubFindingFrontmatterModel.load_from","title":"<code>load_from(path)</code>  <code>classmethod</code>","text":"<p>Load FindingFrontmatterModel from a file.</p> Source code in <code>sereto/models/finding.py</code> <pre><code>@classmethod\n@validate_call\ndef load_from(cls, path: Path) -&gt; Self:\n    \"\"\"Load FindingFrontmatterModel from a file.\"\"\"\n    try:\n        metadata, _ = frontmatter.parse(path.read_text(encoding=\"utf-8\"), encoding=\"utf-8\")\n        return cls.model_validate(metadata)\n    except ValidationError as ex:\n        raise SeretoValueError(f\"invalid finding frontmatter in '{path}'\") from ex\n</code></pre>"},{"location":"reference/models/finding/#sereto.models.finding.VarsMetadataModel","title":"<code>VarsMetadataModel</code>","text":"<p>               Bases: <code>SeretoBaseModel</code></p> Source code in <code>sereto/models/finding.py</code> <pre><code>class VarsMetadataModel(SeretoBaseModel):\n    name: str\n    description: str\n    required: bool = False\n    is_list: bool = Field(False, alias=\"list\")\n    type: Literal[\"string\", \"integer\", \"boolean\"] = \"string\"\n\n    @property\n    def type_annotation(self) -&gt; str:\n        \"\"\"Get description of the variable type and required state.\"\"\"\n        type_annotation = f\"list[{self.type}]\" if self.is_list else self.type\n        required = \"required\" if self.required else \"optional\"\n        return f\"{type_annotation}, {required}\"\n</code></pre>"},{"location":"reference/models/finding/#sereto.models.finding.VarsMetadataModel.type_annotation","title":"<code>type_annotation</code>  <code>property</code>","text":"<p>Get description of the variable type and required state.</p>"},{"location":"reference/models/locator/","title":"Locator","text":""},{"location":"reference/models/locator/#sereto.models.locator","title":"<code>sereto.models.locator</code>","text":""},{"location":"reference/models/locator/#sereto.models.locator.BaseLocatorModel","title":"<code>BaseLocatorModel</code>","text":"<p>               Bases: <code>SeretoBaseModel</code></p> <p>Common base model for all locator types.</p> <p>You should typically use <code>LocatorModel</code> instead of this class directly.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>The type of locator (discriminator field).</p> <code>description</code> <code>str | None</code> <p>An optional description of the locator.</p> Source code in <code>sereto/models/locator.py</code> <pre><code>class BaseLocatorModel(SeretoBaseModel):\n    \"\"\"Common base model for all locator types.\n\n    You should typically use `LocatorModel` instead of this class directly.\n\n    Attributes:\n        type: The type of locator (discriminator field).\n        description: An optional description of the locator.\n    \"\"\"\n\n    type: str\n    description: str | None = None\n</code></pre>"},{"location":"reference/models/locator/#sereto.models.locator.DomainLocatorModel","title":"<code>DomainLocatorModel</code>","text":"<p>               Bases: <code>BaseLocatorModel</code></p> <p>Model representing a domain locator.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['domain']</code> <p>The discriminator for the locator type, which is always \"domain\".</p> <code>value</code> <code>str</code> <p>The domain of the locator.</p> <code>description</code> <code>str | None</code> <p>Optional description of the domain locator.</p> Source code in <code>sereto/models/locator.py</code> <pre><code>class DomainLocatorModel(BaseLocatorModel):\n    \"\"\"Model representing a domain locator.\n\n    Attributes:\n        type: The discriminator for the locator type, which is always \"domain\".\n        value: The domain of the locator.\n        description: Optional description of the domain locator.\n    \"\"\"\n\n    type: Literal[\"domain\"] = \"domain\"\n    value: str  # Domain as a string\n</code></pre>"},{"location":"reference/models/locator/#sereto.models.locator.FileLocatorModel","title":"<code>FileLocatorModel</code>","text":"<p>               Bases: <code>BaseLocatorModel</code></p> <p>Model representing a file locator.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['file']</code> <p>The discriminator for the locator type, which is always \"file\".</p> <code>value</code> <code>str</code> <p>The path to the file, may contain specific line.</p> <code>description</code> <code>str | None</code> <p>Optional description of the file locator.</p> Source code in <code>sereto/models/locator.py</code> <pre><code>class FileLocatorModel(BaseLocatorModel):\n    \"\"\"Model representing a file locator.\n\n    Attributes:\n        type: The discriminator for the locator type, which is always \"file\".\n        value: The path to the file, may contain specific line.\n        description: Optional description of the file locator.\n    \"\"\"\n\n    type: Literal[\"file\"] = \"file\"\n    value: str  # Path to the file\n</code></pre>"},{"location":"reference/models/locator/#sereto.models.locator.HostnameLocatorModel","title":"<code>HostnameLocatorModel</code>","text":"<p>               Bases: <code>BaseLocatorModel</code></p> <p>Model representing a hostname locator.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['hostname']</code> <p>The discriminator for the locator type, which is always \"hostname\".</p> <code>value</code> <code>str</code> <p>The hostname of the locator.</p> <code>description</code> <code>str | None</code> <p>Optional description of the hostname locator.</p> Source code in <code>sereto/models/locator.py</code> <pre><code>class HostnameLocatorModel(BaseLocatorModel):\n    \"\"\"Model representing a hostname locator.\n\n    Attributes:\n        type: The discriminator for the locator type, which is always \"hostname\".\n        value: The hostname of the locator.\n        description: Optional description of the hostname locator.\n    \"\"\"\n\n    type: Literal[\"hostname\"] = \"hostname\"\n    value: str  # Hostname as a string\n</code></pre>"},{"location":"reference/models/locator/#sereto.models.locator.IpLocatorModel","title":"<code>IpLocatorModel</code>","text":"<p>               Bases: <code>BaseLocatorModel</code></p> <p>Model representing an IP locator.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['ip']</code> <p>The discriminator for the locator type, which is always \"ip\".</p> <code>value</code> <code>IPvAnyAddress | IPvAnyNetwork</code> <p>The IP address or network of the locator.</p> <code>description</code> <code>str | None</code> <p>Optional description of the IP locator.</p> Source code in <code>sereto/models/locator.py</code> <pre><code>class IpLocatorModel(BaseLocatorModel):\n    \"\"\"Model representing an IP locator.\n\n    Attributes:\n        type: The discriminator for the locator type, which is always \"ip\".\n        value: The IP address or network of the locator.\n        description: Optional description of the IP locator.\n    \"\"\"\n\n    type: Literal[\"ip\"] = \"ip\"\n    value: IPvAnyAddress | IPvAnyNetwork\n\n    @field_serializer(\"value\")\n    def serialize_value(self, value: IPvAnyAddress | IPvAnyNetwork) -&gt; str:\n        return str(value)\n</code></pre>"},{"location":"reference/models/locator/#sereto.models.locator.PlatformLocatorModel","title":"<code>PlatformLocatorModel</code>","text":"<p>               Bases: <code>BaseLocatorModel</code></p> <p>Model representing a platform locator.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['platform']</code> <p>The discriminator for the locator type, which is always \"platform\".</p> <code>value</code> <code>str</code> <p>The platform name.</p> <code>description</code> <code>str | None</code> <p>Optional description of the platform locator.</p> Source code in <code>sereto/models/locator.py</code> <pre><code>class PlatformLocatorModel(BaseLocatorModel):\n    \"\"\"Model representing a platform locator.\n\n    Attributes:\n        type: The discriminator for the locator type, which is always \"platform\".\n        value: The platform name.\n        description: Optional description of the platform locator.\n    \"\"\"\n\n    type: Literal[\"platform\"] = \"platform\"\n    value: str\n</code></pre>"},{"location":"reference/models/locator/#sereto.models.locator.UrlLocatorModel","title":"<code>UrlLocatorModel</code>","text":"<p>               Bases: <code>BaseLocatorModel</code></p> <p>Model representing a URL locator.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['url']</code> <p>The discriminator for the locator type, which is always \"url\".</p> <code>value</code> <code>AnyUrl</code> <p>The URL of the locator.</p> <code>description</code> <code>str | None</code> <p>Optional description of the URL locator.</p> Source code in <code>sereto/models/locator.py</code> <pre><code>class UrlLocatorModel(BaseLocatorModel):\n    \"\"\"Model representing a URL locator.\n\n    Attributes:\n        type: The discriminator for the locator type, which is always \"url\".\n        value: The URL of the locator.\n        description: Optional description of the URL locator.\n    \"\"\"\n\n    type: Literal[\"url\"] = \"url\"\n    value: AnyUrl\n\n    @field_serializer(\"value\")\n    def serialize_value(self, value: AnyUrl) -&gt; str:\n        return str(value)\n</code></pre>"},{"location":"reference/models/locator/#sereto.models.locator.dump_locators_to_toml","title":"<code>dump_locators_to_toml(locators)</code>","text":"<p>Dump locators to a TOML string.</p> <p>Parameters:</p> Name Type Description Default <code>locators</code> <code>Iterable[LocatorModel]</code> <p>An iterable of LocatorModel instances.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A TOML formatted string representing the locators.</p> Source code in <code>sereto/models/locator.py</code> <pre><code>@validate_call\ndef dump_locators_to_toml(locators: Iterable[LocatorModel]) -&gt; str:\n    \"\"\"Dump locators to a TOML string.\n\n    Args:\n        locators: An iterable of LocatorModel instances.\n\n    Returns:\n        A TOML formatted string representing the locators.\n    \"\"\"\n    if len(loc_list := list(locators)) == 0:\n        return \"[]\"\n\n    lines: list[str] = []\n    for loc in loc_list:\n        desc = f', description=\"{loc.description}\"' if loc.description else \"\"\n        lines.append(f'{{type=\"{loc.type}\", value=\"{loc.value}\"{desc}}},')\n    return \"[\\n    \" + \"\\n    \".join(lines) + \"\\n]\"\n</code></pre>"},{"location":"reference/models/locator/#sereto.models.locator.get_locator_types","title":"<code>get_locator_types()</code>","text":"<p>Get all locator types defined in LocatorModel.</p> Source code in <code>sereto/models/locator.py</code> <pre><code>def get_locator_types() -&gt; list[str]:\n    \"\"\"Get all locator types defined in LocatorModel.\"\"\"\n    union_type, *_ = get_args(LocatorModel)  # first arg is `UrlLocatorModel | HostnameLocatorModel | ...`\n    locator_classes = get_args(union_type)  # the individual model classes\n    return [cls.model_fields[\"type\"].default for cls in locator_classes]\n</code></pre>"},{"location":"reference/models/person/","title":"Person","text":""},{"location":"reference/models/person/#sereto.models.person","title":"<code>sereto.models.person</code>","text":""},{"location":"reference/models/person/#sereto.models.person.Person","title":"<code>Person</code>","text":"<p>               Bases: <code>SeretoBaseModel</code></p> <p>Model representing a person.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>PersonType</code> <p>Type of the person in relation to the assessment.</p> <code>name</code> <code>str | None</code> <p>Full name of the person.</p> <code>business_unit</code> <code>str | None</code> <p>Business unit the person belongs to.</p> <code>email</code> <code>EmailStr | None</code> <p>Email address of the person.</p> <code>role</code> <code>str | None</code> <p>Role of the person within the organization.</p> Source code in <code>sereto/models/person.py</code> <pre><code>class Person(SeretoBaseModel):\n    \"\"\"Model representing a person.\n\n    Attributes:\n        type: Type of the person in relation to the assessment.\n        name: Full name of the person.\n        business_unit: Business unit the person belongs to.\n        email: Email address of the person.\n        role: Role of the person within the organization.\n    \"\"\"\n\n    type: PersonType = Field(strict=False)  # `strict=False` allows coercion from string\n    name: str | None = None\n    business_unit: str | None = None\n    email: EmailStr | None = None\n    role: str | None = None\n</code></pre>"},{"location":"reference/models/person/#sereto.models.person.PersonType","title":"<code>PersonType</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum representing a person's role in regards to the current assessment.</p> <p>Attributes:</p> Name Type Description <code>author</code> <p>Author of the report.</p> <code>requestor</code> <p>Person who requested the assessment.</p> <code>asset_owner</code> <p>Owner of the asset being tested.</p> <code>security_officer</code> <p>Security officer responsible for the asset.</p> <code>technical_contact</code> <p>Person who can answer technical questions about the asset.</p> <code>reviewer</code> <p>Reviewer of the report.</p> Source code in <code>sereto/models/person.py</code> <pre><code>class PersonType(StrEnum):\n    \"\"\"Enum representing a person's role in regards to the current assessment.\n\n    Attributes:\n        author: Author of the report.\n        requestor: Person who requested the assessment.\n        asset_owner: Owner of the asset being tested.\n        security_officer: Security officer responsible for the asset.\n        technical_contact: Person who can answer technical questions about the asset.\n        reviewer: Reviewer of the report.\n    \"\"\"\n\n    author = \"author\"\n    requestor = \"requestor\"\n    asset_owner = \"asset_owner\"\n    security_officer = \"security_officer\"\n    technical_contact = \"technical_contact\"\n    reviewer = \"reviewer\"\n</code></pre>"},{"location":"reference/models/settings/","title":"Settings","text":""},{"location":"reference/models/settings/#sereto.models.settings","title":"<code>sereto.models.settings</code>","text":""},{"location":"reference/models/settings/#sereto.models.settings.BaseRecipe","title":"<code>BaseRecipe</code>","text":"<p>               Bases: <code>SeretoBaseModel</code></p> <p>Base recipe for rendering and converting files using <code>RenderTool</code>s.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>name of the recipe</p> <code>tools</code> <code>Annotated[list[str], MinLen(1)]</code> <p>list of <code>RenderTool</code> names to run</p> Source code in <code>sereto/models/settings.py</code> <pre><code>class BaseRecipe(SeretoBaseModel):\n    \"\"\"Base recipe for rendering and converting files using `RenderTool`s.\n\n    Attributes:\n        name: name of the recipe\n        tools: list of `RenderTool` names to run\n    \"\"\"\n\n    name: str\n    tools: Annotated[list[str], MinLen(1)]\n</code></pre>"},{"location":"reference/models/settings/#sereto.models.settings.ConvertRecipe","title":"<code>ConvertRecipe</code>","text":"<p>               Bases: <code>BaseRecipe</code></p> <p>Recipe for converting between file formats using <code>RenderTool</code>s.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>name of the recipe</p> <code>tools</code> <code>Annotated[list[str], MinLen(1)]</code> <p>list of <code>RenderTool</code> names to run</p> <code>input_format</code> <code>FileFormat</code> <p>input file format</p> <code>output_format</code> <code>FileFormat</code> <p>output file format</p> Source code in <code>sereto/models/settings.py</code> <pre><code>class ConvertRecipe(BaseRecipe):\n    \"\"\"Recipe for converting between file formats using `RenderTool`s.\n\n    Attributes:\n        name: name of the recipe\n        tools: list of `RenderTool` names to run\n        input_format: input file format\n        output_format: output file format\n    \"\"\"\n\n    input_format: FileFormat = Field(strict=False)\n    output_format: FileFormat = Field(strict=False)\n</code></pre>"},{"location":"reference/models/settings/#sereto.models.settings.Plugins","title":"<code>Plugins</code>","text":"<p>               Bases: <code>SeretoBaseModel</code></p> <p>Plugins settings.</p> <p>Attributes:</p> Name Type Description <code>enabled</code> <code>bool</code> <p>whether plugins are enabled</p> <code>directory</code> <code>str</code> <p>path to the directory containing plugins (<code>%TEMPLATES%</code> will be replaced with the templates path`)</p> Source code in <code>sereto/models/settings.py</code> <pre><code>class Plugins(SeretoBaseModel):\n    \"\"\"Plugins settings.\n\n    Attributes:\n        enabled: whether plugins are enabled\n        directory: path to the directory containing plugins (`%TEMPLATES%` will be replaced with the templates path`)\n    \"\"\"\n\n    enabled: bool = False\n    directory: str = \"%TEMPLATES%/plugins\"\n</code></pre>"},{"location":"reference/models/settings/#sereto.models.settings.Render","title":"<code>Render</code>","text":"<p>               Bases: <code>SeretoBaseModel</code></p> <p>Rendering settings.</p> <p>Attributes:</p> Name Type Description <code>report_recipes</code> <code>Annotated[list[RenderRecipe], MinLen(1)]</code> <p>list of <code>RenderRecipe</code>s for rendering reports</p> <code>finding_group_recipes</code> <code>Annotated[list[RenderRecipe], MinLen(1)]</code> <p>list of <code>RenderRecipe</code>s for rendering finding groups</p> <code>sow_recipes</code> <code>Annotated[list[RenderRecipe], MinLen(1)]</code> <p>list of <code>RenderRecipe</code>s for rendering SoWs</p> <code>target_recipes</code> <code>Annotated[list[RenderRecipe], MinLen(1)]</code> <p>list of <code>RenderRecipe</code>s for rendering targets</p> <code>convert_recipes</code> <code>Annotated[list[ConvertRecipe], MinLen(1)]</code> <p>list of <code>ConvertRecipe</code>s for converting between file formats</p> <code>tools</code> <code>Annotated[list[RenderTool], MinLen(1)]</code> <p>list of <code>RenderTool</code>s used in recipes</p> Source code in <code>sereto/models/settings.py</code> <pre><code>class Render(SeretoBaseModel):\n    \"\"\"Rendering settings.\n\n    Attributes:\n        report_recipes: list of `RenderRecipe`s for rendering reports\n        finding_group_recipes: list of `RenderRecipe`s for rendering finding groups\n        sow_recipes: list of `RenderRecipe`s for rendering SoWs\n        target_recipes: list of `RenderRecipe`s for rendering targets\n        convert_recipes: list of `ConvertRecipe`s for converting between file formats\n        tools: list of `RenderTool`s used in recipes\n    \"\"\"\n\n    report_recipes: Annotated[list[RenderRecipe], MinLen(1)]\n    finding_group_recipes: Annotated[list[RenderRecipe], MinLen(1)]\n    sow_recipes: Annotated[list[RenderRecipe], MinLen(1)]\n    target_recipes: Annotated[list[RenderRecipe], MinLen(1)]\n    convert_recipes: Annotated[list[ConvertRecipe], MinLen(1)]\n    tools: Annotated[list[RenderTool], MinLen(1)]\n\n    @model_validator(mode=\"after\")\n    def render_validator(self) -&gt; Self:\n        for recipe in self.report_recipes + self.finding_group_recipes + self.sow_recipes:\n            if not all(tool in [t.name for t in self.tools] for tool in recipe.tools):\n                raise ValueError(f\"unknown tools in recipe {recipe.name!r}\")\n        tool_names = [t.name for t in self.tools]\n        if len(tool_names) != len(set(tool_names)):\n            raise ValueError(\"tools with duplicate name detected\")\n        return self\n\n    @validate_call\n    def get_report_recipe(self, name: str | None) -&gt; RenderRecipe:\n        \"\"\"Get a report recipe by name.\n\n        Args:\n            name: The name of the recipe to get. If None, the first recipe is returned.\n        \"\"\"\n        if name is None:\n            return self.report_recipes[0]\n\n        if len(res := [r for r in self.report_recipes if r.name == name]) != 1:\n            raise SeretoValueError(f\"no report recipe found with name {name!r}\")\n\n        return res[0]\n\n    @validate_call\n    def get_finding_group_recipe(self, name: str | None) -&gt; RenderRecipe:\n        \"\"\"Get a finding group recipe by name.\n\n        Args:\n            name: The name of the recipe to get. If None, the first recipe is returned.\n        \"\"\"\n        if name is None:\n            return self.finding_group_recipes[0]\n\n        if len(res := [r for r in self.finding_group_recipes if r.name == name]) != 1:\n            raise SeretoValueError(f\"no finding recipe found with name {name!r}\")\n\n        return res[0]\n\n    @validate_call\n    def get_sow_recipe(self, name: str | None) -&gt; RenderRecipe:\n        \"\"\"Get a SoW recipe by name.\n\n        Args:\n            name: The name of the recipe to get. If None, the first recipe is returned.\n        \"\"\"\n        if name is None:\n            return self.sow_recipes[0]\n\n        if len(res := [r for r in self.sow_recipes if r.name == name]) != 1:\n            raise SeretoValueError(f\"no SoW recipe found with name {name!r}\")\n\n        return res[0]\n\n    @validate_call\n    def get_target_recipe(self, name: str | None) -&gt; RenderRecipe:\n        \"\"\"Get a target recipe by name.\n\n        Args:\n            name: The name of the recipe to get. If None, the first recipe is returned.\n        \"\"\"\n        if name is None:\n            return self.target_recipes[0]\n\n        if len(res := [r for r in self.target_recipes if r.name == name]) != 1:\n            raise SeretoValueError(f\"no target recipe found with name {name!r}\")\n\n        return res[0]\n\n    @validate_call\n    def get_convert_recipe(\n        self, name: str | None, input_format: FileFormat, output_format: FileFormat\n    ) -&gt; ConvertRecipe:\n        \"\"\"Get a convert recipe by name, input format, and output format.\n\n        Args:\n            name: The name of the recipe to get. If None, the first matching recipe is returned.\n            input_format: The input file format.\n            output_format: The output file format.\n        \"\"\"\n        acceptable_recipes = [\n            r for r in self.convert_recipes if r.input_format == input_format and r.output_format == output_format\n        ]\n        if len(acceptable_recipes) == 0:\n            raise SeretoValueError(f\"no convert recipe found for {input_format.value} -&gt; {output_format.value}\")\n\n        if name is None:\n            return acceptable_recipes[0]\n\n        if len(res := [r for r in acceptable_recipes if r.name == name]) != 1:\n            raise SeretoValueError(\n                f\"no convert recipe found for {input_format.value} -&gt; {output_format.value} with name {name!r}\"\n            )\n\n        return res[0]\n</code></pre>"},{"location":"reference/models/settings/#sereto.models.settings.Render.get_convert_recipe","title":"<code>get_convert_recipe(name, input_format, output_format)</code>","text":"<p>Get a convert recipe by name, input format, and output format.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The name of the recipe to get. If None, the first matching recipe is returned.</p> required <code>input_format</code> <code>FileFormat</code> <p>The input file format.</p> required <code>output_format</code> <code>FileFormat</code> <p>The output file format.</p> required Source code in <code>sereto/models/settings.py</code> <pre><code>@validate_call\ndef get_convert_recipe(\n    self, name: str | None, input_format: FileFormat, output_format: FileFormat\n) -&gt; ConvertRecipe:\n    \"\"\"Get a convert recipe by name, input format, and output format.\n\n    Args:\n        name: The name of the recipe to get. If None, the first matching recipe is returned.\n        input_format: The input file format.\n        output_format: The output file format.\n    \"\"\"\n    acceptable_recipes = [\n        r for r in self.convert_recipes if r.input_format == input_format and r.output_format == output_format\n    ]\n    if len(acceptable_recipes) == 0:\n        raise SeretoValueError(f\"no convert recipe found for {input_format.value} -&gt; {output_format.value}\")\n\n    if name is None:\n        return acceptable_recipes[0]\n\n    if len(res := [r for r in acceptable_recipes if r.name == name]) != 1:\n        raise SeretoValueError(\n            f\"no convert recipe found for {input_format.value} -&gt; {output_format.value} with name {name!r}\"\n        )\n\n    return res[0]\n</code></pre>"},{"location":"reference/models/settings/#sereto.models.settings.Render.get_finding_group_recipe","title":"<code>get_finding_group_recipe(name)</code>","text":"<p>Get a finding group recipe by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The name of the recipe to get. If None, the first recipe is returned.</p> required Source code in <code>sereto/models/settings.py</code> <pre><code>@validate_call\ndef get_finding_group_recipe(self, name: str | None) -&gt; RenderRecipe:\n    \"\"\"Get a finding group recipe by name.\n\n    Args:\n        name: The name of the recipe to get. If None, the first recipe is returned.\n    \"\"\"\n    if name is None:\n        return self.finding_group_recipes[0]\n\n    if len(res := [r for r in self.finding_group_recipes if r.name == name]) != 1:\n        raise SeretoValueError(f\"no finding recipe found with name {name!r}\")\n\n    return res[0]\n</code></pre>"},{"location":"reference/models/settings/#sereto.models.settings.Render.get_report_recipe","title":"<code>get_report_recipe(name)</code>","text":"<p>Get a report recipe by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The name of the recipe to get. If None, the first recipe is returned.</p> required Source code in <code>sereto/models/settings.py</code> <pre><code>@validate_call\ndef get_report_recipe(self, name: str | None) -&gt; RenderRecipe:\n    \"\"\"Get a report recipe by name.\n\n    Args:\n        name: The name of the recipe to get. If None, the first recipe is returned.\n    \"\"\"\n    if name is None:\n        return self.report_recipes[0]\n\n    if len(res := [r for r in self.report_recipes if r.name == name]) != 1:\n        raise SeretoValueError(f\"no report recipe found with name {name!r}\")\n\n    return res[0]\n</code></pre>"},{"location":"reference/models/settings/#sereto.models.settings.Render.get_sow_recipe","title":"<code>get_sow_recipe(name)</code>","text":"<p>Get a SoW recipe by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The name of the recipe to get. If None, the first recipe is returned.</p> required Source code in <code>sereto/models/settings.py</code> <pre><code>@validate_call\ndef get_sow_recipe(self, name: str | None) -&gt; RenderRecipe:\n    \"\"\"Get a SoW recipe by name.\n\n    Args:\n        name: The name of the recipe to get. If None, the first recipe is returned.\n    \"\"\"\n    if name is None:\n        return self.sow_recipes[0]\n\n    if len(res := [r for r in self.sow_recipes if r.name == name]) != 1:\n        raise SeretoValueError(f\"no SoW recipe found with name {name!r}\")\n\n    return res[0]\n</code></pre>"},{"location":"reference/models/settings/#sereto.models.settings.Render.get_target_recipe","title":"<code>get_target_recipe(name)</code>","text":"<p>Get a target recipe by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The name of the recipe to get. If None, the first recipe is returned.</p> required Source code in <code>sereto/models/settings.py</code> <pre><code>@validate_call\ndef get_target_recipe(self, name: str | None) -&gt; RenderRecipe:\n    \"\"\"Get a target recipe by name.\n\n    Args:\n        name: The name of the recipe to get. If None, the first recipe is returned.\n    \"\"\"\n    if name is None:\n        return self.target_recipes[0]\n\n    if len(res := [r for r in self.target_recipes if r.name == name]) != 1:\n        raise SeretoValueError(f\"no target recipe found with name {name!r}\")\n\n    return res[0]\n</code></pre>"},{"location":"reference/models/settings/#sereto.models.settings.RenderRecipe","title":"<code>RenderRecipe</code>","text":"<p>               Bases: <code>BaseRecipe</code></p> <p>Recipe for rendering files using <code>RenderTool</code>s.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>name of the recipe</p> <code>tools</code> <code>Annotated[list[str], MinLen(1)]</code> <p>list of <code>RenderTool</code> names to run</p> <code>intermediate_format</code> <code>FileFormat</code> <p>supported <code>FileFormat</code></p> Source code in <code>sereto/models/settings.py</code> <pre><code>class RenderRecipe(BaseRecipe):\n    \"\"\"Recipe for rendering files using `RenderTool`s.\n\n    Attributes:\n        name: name of the recipe\n        tools: list of `RenderTool` names to run\n        intermediate_format: supported `FileFormat`\n    \"\"\"\n\n    intermediate_format: FileFormat = Field(strict=False, default=FileFormat.tex)\n</code></pre>"},{"location":"reference/models/settings/#sereto.models.settings.RenderTool","title":"<code>RenderTool</code>","text":"<p>               Bases: <code>SeretoBaseModel</code></p> <p>Commands used in recipes.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>name of the tool</p> <code>command</code> <code>str</code> <p>command to run</p> <code>args</code> <code>list[str]</code> <p>list of arguments to pass to the command</p> Source code in <code>sereto/models/settings.py</code> <pre><code>class RenderTool(SeretoBaseModel):\n    \"\"\"Commands used in recipes.\n\n    Attributes:\n        name: name of the tool\n        command: command to run\n        args: list of arguments to pass to the command\n    \"\"\"\n\n    name: str\n    command: str\n    args: list[str]\n\n    @validate_call\n    def run(\n        self, cwd: DirectoryPath | None = None, input: bytes | None = None, replacements: dict[str, str] | None = None\n    ) -&gt; bytes:\n        # Prepare the command\n        command = [self.command] + self.args\n        if replacements is not None:\n            command = replace_strings(text=command, replacements=replacements)\n        logger.info(\"Running command: {}\", \" \".join(command))\n        command_preview = escape(\" \".join(command))\n        logger.info(\"[bold bright_cyan]\u25b6 Running command[/]: [italic dim]{}[/]\", command_preview, markup=True)\n\n        # Run the command and measure the execution time\n        start_time = time.time()\n        result = subprocess.run(command, cwd=cwd, input=input, capture_output=True)\n        end_time = time.time()\n\n        # Check if the command failed\n        if result.returncode != 0:\n            stderr_raw = result.stderr.decode(\"utf-8\", errors=\"replace\").rstrip()\n            stderr = escape(stderr_raw) if stderr_raw else \"no stderr output\"\n            logger.error(\n                \"[bold bright_red]\u2716 Command failed[/] (exit code {}): [italic dim]{}[/]\\n\"\n                \"[bright_black]\u250c\u2500 stderr \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[/]\\n\"\n                \"[bright_black]\u2502[/] [red]{}[/]\\n\"\n                \"[bright_black]\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[/]\",\n                result.returncode,\n                command_preview,\n                stderr,\n                markup=True,\n            )\n            raise SeretoCalledProcessError(\"command execution failed\")\n\n        # Report success\n        logger.info(\"Command finished in {:.2f} s\", end_time - start_time)\n\n        # Return the command output\n        return result.stdout\n</code></pre>"},{"location":"reference/models/settings/#sereto.models.settings.Settings","title":"<code>Settings</code>","text":"<p>               Bases: <code>SeretoBaseSettings</code></p> <p>Global settings:</p> <p>Attributes:</p> Name Type Description <code>projects_path</code> <code>DirectoryPath</code> <p>path to the directory containing all projects</p> <code>templates_path</code> <code>DirectoryPath</code> <p>path to the directory containing templates</p> <code>default_people</code> <code>list[Person]</code> <p>list of default people to use in new projects</p> <code>render</code> <code>Render</code> <p>rendering settings</p> <code>categories</code> <code>TypeCategories</code> <p>supported categories - list of strings (2-20 lower-alpha characters; also dash and underscore is possible in all positions except the first and last one)</p> <code>risk_due_dates</code> <code>dict[Risk, timedelta]</code> <p>due dates for fixing the findings, for each risk level, as a timedelta</p> <code>plugins</code> <code>Plugins</code> <p>plugins settings</p> <p>Raises:</p> Type Description <code>SeretoPathError</code> <p>If the file is not found or permission is denied.</p> <code>SeretoValueError</code> <p>If the JSON file is invalid.</p> Source code in <code>sereto/models/settings.py</code> <pre><code>class Settings(SeretoBaseSettings):\n    \"\"\"Global settings:\n\n    Attributes:\n        projects_path: path to the directory containing all projects\n        templates_path: path to the directory containing templates\n        default_people: list of default people to use in new projects\n        render: rendering settings\n        categories: supported categories - list of strings (2-20 lower-alpha characters; also dash and underscore is\n            possible in all positions except the first and last one)\n        risk_due_dates: due dates for fixing the findings, for each risk level, as a timedelta\n        plugins: plugins settings\n\n    Raises:\n        SeretoPathError: If the file is not found or permission is denied.\n        SeretoValueError: If the JSON file is invalid.\n    \"\"\"\n\n    projects_path: DirectoryPath\n    templates_path: DirectoryPath\n    default_people: list[Person] = Field(default_factory=list)\n    render: Render = Field(default=DEFAULT_RENDER_CONFIG)\n    categories: TypeCategories = Field(default=DEFAULT_CATEGORIES)\n    risk_due_dates: dict[Risk, timedelta] = Field(\n        default_factory=lambda: {\n            Risk.critical: timedelta(days=7),\n            Risk.high: timedelta(days=14),\n            Risk.medium: timedelta(days=30),\n            Risk.low: timedelta(days=90),\n        },\n        strict=False,\n    )\n    plugins: Plugins = Field(default_factory=Plugins)\n\n    @field_validator(\"categories\", mode=\"after\")\n    @classmethod\n    def unique_categories(cls, categories: TypeCategories) -&gt; TypeCategories:\n        \"\"\"Ensure that all category names are unique and preserves their original order.\"\"\"\n\n        if not categories:\n            return []\n        seen: set[str] = set()\n        unique: TypeCategories = []\n        for category in categories:\n            if category is None or category in seen:\n                continue\n            seen.add(category)\n            unique.append(category)\n        return unique\n\n    @staticmethod\n    def get_path() -&gt; Path:\n        return Path(get_app_dir(app_name=\"sereto\")) / \"settings.json\"\n\n    @classmethod\n    def load_from(cls, file: FilePath) -&gt; Self:\n        try:\n            return cls.model_validate_json(file.read_bytes())\n        except FileNotFoundError:\n            raise SeretoPathError(f\"file not found at '{file}'\") from None\n        except PermissionError:\n            raise SeretoPathError(f\"permission denied for '{file}'\") from None\n        except ValidationError as e:\n            raise SeretoValueError(f\"invalid settings\\n\\n{e}\") from e\n</code></pre>"},{"location":"reference/models/settings/#sereto.models.settings.Settings.unique_categories","title":"<code>unique_categories(categories)</code>  <code>classmethod</code>","text":"<p>Ensure that all category names are unique and preserves their original order.</p> Source code in <code>sereto/models/settings.py</code> <pre><code>@field_validator(\"categories\", mode=\"after\")\n@classmethod\ndef unique_categories(cls, categories: TypeCategories) -&gt; TypeCategories:\n    \"\"\"Ensure that all category names are unique and preserves their original order.\"\"\"\n\n    if not categories:\n        return []\n    seen: set[str] = set()\n    unique: TypeCategories = []\n    for category in categories:\n        if category is None or category in seen:\n            continue\n        seen.add(category)\n        unique.append(category)\n    return unique\n</code></pre>"},{"location":"reference/models/target/","title":"Target","text":""},{"location":"reference/models/target/#sereto.models.target","title":"<code>sereto.models.target</code>","text":""},{"location":"reference/models/target/#sereto.models.target.TargetDastModel","title":"<code>TargetDastModel</code>","text":"<p>               Bases: <code>TargetModel</code></p> <p>Model representing a target which is characterized by IP address.</p> Source code in <code>sereto/models/target.py</code> <pre><code>class TargetDastModel(TargetModel):\n    \"\"\"Model representing a target which is characterized by IP address.\"\"\"\n\n    dst_ips_dynamic: bool = False\n    dst_ips_dynamic_details: str | None = None\n    src_ips: list[IPvAnyAddress | IPvAnyNetwork] = []\n    ip_filtering: bool = False\n    ip_allowed: bool | None = None\n    authentication: bool = False\n    credentials_provided: bool | None = None\n    internal: bool = False\n    environment: Environment = Environment.acceptance\n    waf_present: bool = False\n    waf_whitelisted: bool | None = None\n    clickpath: str | None = None\n    api: str | None = None\n</code></pre>"},{"location":"reference/models/target/#sereto.models.target.TargetMobileModel","title":"<code>TargetMobileModel</code>","text":"<p>               Bases: <code>TargetModel</code></p> <p>Model representing the details of the 'mobile' category.</p> Source code in <code>sereto/models/target.py</code> <pre><code>class TargetMobileModel(TargetModel):\n    \"\"\"Model representing the details of the 'mobile' category.\"\"\"\n\n    class MobilePlatform(SeretoBaseModel):\n        file_integrity: dict[str, str] = {}\n\n    class AndroidMobilePlatform(MobilePlatform):\n        package_name: str | None = None\n        version_name: str | None = None\n        version_code: str | None = None\n\n    class iOSMobilePlatform(MobilePlatform):\n        bundle_id: str | None = None\n        short_version_string: str | None = None\n        version: str | None = None\n\n    clickpath: str | None = None\n    android: AndroidMobilePlatform | None = AndroidMobilePlatform()\n    ios: iOSMobilePlatform | None = iOSMobilePlatform()\n</code></pre>"},{"location":"reference/models/target/#sereto.models.target.TargetModel","title":"<code>TargetModel</code>","text":"<p>               Bases: <code>SeretoBaseModel</code></p> <p>Base class for model representing the details of a target.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str | None</code> <p>Unique identifier for the target, optional.</p> <code>category</code> <code>str</code> <p>The category of the target.</p> <code>name</code> <code>str</code> <p>The name of the target (e.g. DAST, SAST).</p> <code>locators</code> <code>list[LocatorModel]</code> <p>List of locators for the target, such as URLs or IP addresses, source code files, etc.</p> Source code in <code>sereto/models/target.py</code> <pre><code>class TargetModel(SeretoBaseModel, extra=\"allow\"):\n    \"\"\"Base class for model representing the details of a target.\n\n    Attributes:\n        id: Unique identifier for the target, optional.\n        category: The category of the target.\n        name: The name of the target (e.g. DAST, SAST).\n        locators: List of locators for the target, such as URLs or IP addresses, source code files, etc.\n    \"\"\"\n\n    id: str | None = None\n    category: str\n    name: str\n    locators: list[LocatorModel] = Field(default_factory=list)\n\n    @field_validator(\"category\")\n    @classmethod\n    def category_valid(cls, v: str) -&gt; str:\n        settings = load_settings_function()\n        if v in settings.categories:\n            return v\n        else:\n            raise ValueError(f'category \"{v}\" is unknown')\n\n    @property\n    def uname(self) -&gt; str:\n        \"\"\"Unique name for the target instance (version is not included).\"\"\"\n        return lower_alphanum(f\"target_{self.category}_{self.name}\")\n</code></pre>"},{"location":"reference/models/target/#sereto.models.target.TargetModel.uname","title":"<code>uname</code>  <code>property</code>","text":"<p>Unique name for the target instance (version is not included).</p>"},{"location":"reference/models/target/#sereto.models.target.TargetSastModel","title":"<code>TargetSastModel</code>","text":"<p>               Bases: <code>TargetModel</code></p> <p>Model representing the details of the 'sast' category.</p> <p>Attributes:</p> Name Type Description <code>code_origin</code> <code>Literal['vcs', 'archive'] | None</code> <p>where we obtained the code - Version Control System or archive (ZIP/TAR/...)</p> <code>code_origin_name</code> <code>str | None</code> <p>origin details - e.g. \"Gitlab\" or \"project_source.zip\"</p> <code>code_integrity</code> <code>dict[str, str]</code> <p>dictionary containing file name with hash type as the key and corresponding hash as the value</p> <code>source_code_analyzer_files</code> <code>list[str]</code> <p>additional files from source code analyzers (like Fortify SCA or Sonarqube)</p> Source code in <code>sereto/models/target.py</code> <pre><code>class TargetSastModel(TargetModel):\n    \"\"\"Model representing the details of the 'sast' category.\n\n    Attributes:\n        code_origin: where we obtained the code - Version Control System or archive (ZIP/TAR/...)\n        code_origin_name: origin details - e.g. \"Gitlab\" or \"project_source.zip\"\n        code_integrity: dictionary containing file name with hash type as the key and corresponding hash as the value\n        source_code_analyzer_files: additional files from source code analyzers (like Fortify SCA or Sonarqube)\n    \"\"\"\n\n    code_origin: Literal[\"vcs\", \"archive\"] | None = None\n    code_origin_name: str | None = None\n    code_integrity: dict[str, str] = {}\n    source_code_analyzer_files: list[str] = []\n</code></pre>"},{"location":"reference/models/version/","title":"Version","text":""},{"location":"reference/models/version/#sereto.models.version","title":"<code>sereto.models.version</code>","text":""},{"location":"reference/models/version/#sereto.models.version.ProjectVersion","title":"<code>ProjectVersion</code>","text":"<p>               Bases: <code>RootModel[VersionVPrefixPydanticAnnotation]</code></p> Source code in <code>sereto/models/version.py</code> <pre><code>@total_ordering\nclass ProjectVersion(RootModel[VersionVPrefixPydanticAnnotation]):\n    root: VersionVPrefixPydanticAnnotation\n\n    @field_validator(\"root\", mode=\"after\")\n    @classmethod\n    def prerelease_build_not_set(cls, v: Version) -&gt; Version:\n        if v.prerelease is not None or v.build is not None or v.patch != 0:\n            raise ValueError(\"only major, minor parts are supported\")\n        return v\n\n    @model_serializer()\n    def serialize_model(self) -&gt; str:\n        return self.__str__()\n\n    def __lt__(self, other: Any) -&gt; bool:\n        if type(self) is not type(other):\n            raise SeretoTypeError(\"incompatible types for comparison\")\n        return self.root &lt; other.root\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if type(self) is not type(other):\n            raise SeretoTypeError(\"incompatible types for comparison\")\n        return self.root == other.root\n\n    def __hash__(self) -&gt; int:\n        return self.root.__hash__()\n\n    def __str__(self) -&gt; str:\n        return f\"v{self.root.major}.{self.root.minor}\"\n\n    @classmethod\n    def from_str(cls, v: str) -&gt; \"ProjectVersion\":\n        \"\"\"Create a ProjectVersion instance from a string.\n\n        This method primarily exists to satisfy type checker.\n\n        Args:\n            v: The string representation of the version, e.g. \"v2.0\".\n\n        Returns:\n            A ProjectVersion instance constructed from the string representation.\n        \"\"\"\n        if len(v) == 0 or v[0] != \"v\" or len(v.split(\".\")) != 2:\n            raise ValueError(\"invalid format: use vMAJOR.MINOR\")\n        return ProjectVersion.model_construct(root=Version.parse(v[1:], optional_minor_and_patch=True))\n\n    def next_major_version(self) -&gt; \"ProjectVersion\":\n        return ProjectVersion(f\"v{self.root.major + 1}.{self.root.minor}\")  # type: ignore[arg-type]\n\n    def next_minor_version(self) -&gt; \"ProjectVersion\":\n        return ProjectVersion(f\"v{self.root.major}.{self.root.minor + 1}\")  # type: ignore[arg-type]\n\n    @property\n    def path_suffix(self) -&gt; str:\n        return f\"_{self.__str__()}\" if self.root.major != 1 or self.root.minor != 0 else \"\"\n</code></pre>"},{"location":"reference/models/version/#sereto.models.version.ProjectVersion.from_str","title":"<code>from_str(v)</code>  <code>classmethod</code>","text":"<p>Create a ProjectVersion instance from a string.</p> <p>This method primarily exists to satisfy type checker.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>The string representation of the version, e.g. \"v2.0\".</p> required <p>Returns:</p> Type Description <code>ProjectVersion</code> <p>A ProjectVersion instance constructed from the string representation.</p> Source code in <code>sereto/models/version.py</code> <pre><code>@classmethod\ndef from_str(cls, v: str) -&gt; \"ProjectVersion\":\n    \"\"\"Create a ProjectVersion instance from a string.\n\n    This method primarily exists to satisfy type checker.\n\n    Args:\n        v: The string representation of the version, e.g. \"v2.0\".\n\n    Returns:\n        A ProjectVersion instance constructed from the string representation.\n    \"\"\"\n    if len(v) == 0 or v[0] != \"v\" or len(v.split(\".\")) != 2:\n        raise ValueError(\"invalid format: use vMAJOR.MINOR\")\n    return ProjectVersion.model_construct(root=Version.parse(v[1:], optional_minor_and_patch=True))\n</code></pre>"},{"location":"reference/models/version/#sereto.models.version.SeretoVersion","title":"<code>SeretoVersion</code>","text":"<p>               Bases: <code>RootModel[VersionPydanticAnnotation]</code></p> Source code in <code>sereto/models/version.py</code> <pre><code>@total_ordering\nclass SeretoVersion(RootModel[VersionPydanticAnnotation]):\n    root: VersionPydanticAnnotation\n\n    @field_validator(\"root\", mode=\"after\")\n    @classmethod\n    def prerelease_build_not_set(cls, v: Version) -&gt; Version:\n        if v.prerelease is not None or v.build is not None:\n            raise ValueError(\"only major, minor, patch parts supported\")\n        return v\n\n    @model_serializer()\n    def serialize_model(self) -&gt; str:\n        return self.__str__()\n\n    def __str__(self) -&gt; str:\n        return self.root.__str__()\n\n    def __lt__(self, other: Any) -&gt; bool:\n        if type(self) is not type(other):\n            raise SeretoTypeError(\"incompatible types for comparison\")\n        return self.root &lt; other.root\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if type(self) is not type(other):\n            raise SeretoTypeError(\"incompatible types for comparison\")\n        return self.root == other.root\n\n    def __hash__(self) -&gt; int:\n        return self.root.__hash__()\n\n    @classmethod\n    def from_str(cls, v: str) -&gt; \"SeretoVersion\":\n        \"\"\"Create a SeretoVersion instance from a string.\n\n        This method primarily exists to satisfy type checker.\n\n        Args:\n            v: The string representation of the version, e.g. \"1.2.3\".\n\n        Returns:\n            A SeretoVersion instance constructed from the string representation.\n        \"\"\"\n        return SeretoVersion.model_construct(root=Version.parse(v))\n</code></pre>"},{"location":"reference/models/version/#sereto.models.version.SeretoVersion.from_str","title":"<code>from_str(v)</code>  <code>classmethod</code>","text":"<p>Create a SeretoVersion instance from a string.</p> <p>This method primarily exists to satisfy type checker.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>The string representation of the version, e.g. \"1.2.3\".</p> required <p>Returns:</p> Type Description <code>SeretoVersion</code> <p>A SeretoVersion instance constructed from the string representation.</p> Source code in <code>sereto/models/version.py</code> <pre><code>@classmethod\ndef from_str(cls, v: str) -&gt; \"SeretoVersion\":\n    \"\"\"Create a SeretoVersion instance from a string.\n\n    This method primarily exists to satisfy type checker.\n\n    Args:\n        v: The string representation of the version, e.g. \"1.2.3\".\n\n    Returns:\n        A SeretoVersion instance constructed from the string representation.\n    \"\"\"\n    return SeretoVersion.model_construct(root=Version.parse(v))\n</code></pre>"},{"location":"reference/models/version/#sereto.models.version.VersionVPrefix","title":"<code>VersionVPrefix</code>","text":"<p>               Bases: <code>Version</code></p> <p>A subclass of Version which allows a \"v\" prefix.</p> Source code in <code>sereto/models/version.py</code> <pre><code>class VersionVPrefix(Version):\n    \"\"\"A subclass of Version which allows a \"v\" prefix.\"\"\"\n\n    @classmethod\n    def parse(cls, v: str) -&gt; \"Version\":  # type: ignore[override]\n        \"\"\"Parse version string to a Version instance.\n\n        Args:\n            v: version string with \"v\" prefix\n\n        Raises:\n            ValueError: when version does not start with \"v\"\n\n        Returns:\n            A new Version instance\n        \"\"\"\n        if len(v) == 0 or v[0] != \"v\" or len(v.split(\".\")) != 2:\n            raise ValueError(\"invalid format: use vMAJOR.MINOR\")\n        return Version.parse(v[1:], optional_minor_and_patch=True)\n\n    def __str__(self) -&gt; str:\n        return f\"v{super().__str__()}\"\n</code></pre>"},{"location":"reference/models/version/#sereto.models.version.VersionVPrefix.parse","title":"<code>parse(v)</code>  <code>classmethod</code>","text":"<p>Parse version string to a Version instance.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>version string with \"v\" prefix</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>when version does not start with \"v\"</p> <p>Returns:</p> Type Description <code>Version</code> <p>A new Version instance</p> Source code in <code>sereto/models/version.py</code> <pre><code>@classmethod\ndef parse(cls, v: str) -&gt; \"Version\":  # type: ignore[override]\n    \"\"\"Parse version string to a Version instance.\n\n    Args:\n        v: version string with \"v\" prefix\n\n    Raises:\n        ValueError: when version does not start with \"v\"\n\n    Returns:\n        A new Version instance\n    \"\"\"\n    if len(v) == 0 or v[0] != \"v\" or len(v.split(\".\")) != 2:\n        raise ValueError(\"invalid format: use vMAJOR.MINOR\")\n    return Version.parse(v[1:], optional_minor_and_patch=True)\n</code></pre>"},{"location":"reference/tui/finding/","title":"Finding","text":""},{"location":"reference/tui/finding/#sereto.tui.finding","title":"<code>sereto.tui.finding</code>","text":""},{"location":"reference/tui/finding/#sereto.tui.finding.AddFindingScreen","title":"<code>AddFindingScreen</code>","text":"<p>               Bases: <code>ModalScreen[None]</code></p> Source code in <code>sereto/tui/finding.py</code> <pre><code>class AddFindingScreen(ModalScreen[None]):\n    BINDINGS = [(\"escape\", \"dismiss\", \"Dismiss finding\")]\n\n    def __init__(self, templates: DirectoryPath, finding: FindingMetadata, title: str) -&gt; None:\n        super().__init__()\n        self.templates = templates\n        self.finding = finding\n        self.title = title\n\n    def compose(self) -&gt; ComposeResult:\n        app: SeretoApp = self.app  # type: ignore[assignment]\n        all_targets = [t for v in app.project.config.versions for t in app.project.config.at_version(v).targets]\n\n        with ScrollableContainer(id=\"add-finding\"):\n            # Name\n            self.input_name = Input(value=self.finding.name)\n            yield InputWithLabel(self.input_name, label=\"Name\")\n            # Risk\n            risks = [r.capitalize() for r in Risk]\n            self.select_risk = SelectWithLabel[str](options=[(r, r) for r in risks], label=\"Risk\")\n            yield self.select_risk\n            # Target\n            self.select_target = SelectWithLabel[str](\n                options=[(t.uname, t.uname) for t in all_targets],\n                label=\"Target\",\n                allow_blank=False,\n            )\n            yield self.select_target\n\n            # Existing finding warning + overwrite switch\n            self.overwrite_switch = Switch(value=False, name=\"overwrite\", id=\"overwrite-switch\")\n            self.overwrite_warning = Horizontal(\n                self.overwrite_switch,\n                Static(\n                    \"[b red]Warning:[/b red] A finding with this name already exists in the selected target.\\n\"\n                    \"  [b]Switch OFF:[/b] Keep the original and create a new one with a random suffix.\\n\"\n                    \"  [b]Switch ON:[/b] Overwrite the existing finding.\"\n                ),\n                id=\"overwrite-warning\",\n            )\n            self.overwrite_warning.display = False\n            yield self.overwrite_warning\n\n            yield Static(\"[b]Variables\", classes=\"section-header\")\n            yield Rule()\n\n            for var in self.finding.variables:\n                yield Static(f\"[b]{var.name}:[/b] {escape(var.type_annotation)}\\n  {var.description}\", classes=\"pl-1\")\n                if var.is_list:\n                    match var.type:\n                        case \"boolean\":\n                            yield ListWidget(\n                                widget_factory=lambda var=var: Select(  # type: ignore[misc]\n                                    options=[\n                                        (\"True\", True),\n                                        (\"False\", False),\n                                    ],\n                                    allow_blank=not var.required,\n                                ),\n                                id=f\"var-{var.name}\",\n                            )\n                        case \"integer\":\n                            yield ListWidget(\n                                widget_factory=lambda: Input(type=\"integer\", classes=\"m-1\"),\n                                id=f\"var-{var.name}\",\n                            )\n                        case _:\n                            yield ListWidget(\n                                widget_factory=lambda: Input(classes=\"m-1\"),\n                                id=f\"var-{var.name}\",\n                            )\n                else:\n                    match var.type:\n                        case \"boolean\":\n                            yield Select(\n                                options=[\n                                    (\"True\", True),\n                                    (\"False\", False),\n                                ],\n                                allow_blank=not var.required,\n                                id=f\"var-{var.name}\",\n                            )\n                        case \"integer\":\n                            yield Input(id=f\"var-{var.name}\", type=\"integer\", classes=\"m-1\")\n                        case _:\n                            yield Input(id=f\"var-{var.name}\", classes=\"m-1\")\n                yield Rule()\n\n            self.btn_save_finding = Button.success(\"Save\", id=\"save-finding\", classes=\"m-1\")\n            yield self.btn_save_finding\n\n    def on_mount(self) -&gt; None:\n        add_finding = self.query_one(\"#add-finding\")\n        add_finding.border_title = self.title\n        add_finding.border_subtitle = \"Esc to close\"\n\n    def on_select_changed(self, event: Select.Changed) -&gt; None:\n        if event.select is self.select_target.query_one(Select):\n            self.update_overwrite_warning()\n\n    def update_overwrite_warning(self) -&gt; None:\n        \"\"\"Update the overwrite warning and switch dynamically.\"\"\"\n        try:\n            target = self._retrieve_target()\n        except Exception:\n            self.overwrite_warning.display = False\n            return\n\n        finding_path = target.findings.get_path(\n            name=self.finding.path.name.removesuffix(\".md.j2\"),\n            category=self.finding.category.lower(),\n        )\n        self.overwrite_warning.display = finding_path.is_file()\n\n    def _load_variables(self) -&gt; dict[str, Any]:\n        \"\"\"Load variables from the inputs.\n        Raises:\n            SeretoValueError: If a required variable is not set.\n        \"\"\"\n        variables: dict[str, Any] = {}\n\n        for var in self.finding.variables:\n            if var.is_list:\n                widgets = list(self.query_one(f\"#var-{var.name}\", ListWidget).query(\".widget\").results())\n\n                match var.type:\n                    case \"boolean\":\n                        # get values, filter out NoSelection\n                        values = [\n                            w.value for w in widgets if isinstance(w, Select) and not isinstance(w.value, NoSelection)\n                        ]\n                    case \"integer\":\n                        values_str = [\n                            w.value.strip() for w in widgets if isinstance(w, Input) and len(w.value.strip()) &gt; 0\n                        ]\n                        try:\n                            values = [int(v) for v in values_str]\n                        except ValueError:\n                            raise SeretoValueError(f\"variable '{var.name}' must be an integer\") from None\n                    case _:\n                        values = [\n                            w.value.strip() for w in widgets if isinstance(w, Input) and len(w.value.strip()) &gt; 0\n                        ]\n\n                if var.required and len(values) == 0:\n                    raise SeretoValueError(f\"variable '{var.name}' is required\")\n                elif len(values) == 0:\n                    # don't set the variable if not required and empty\n                    continue\n                # always set list variables, even if empty\n                variables[var.name] = values\n                continue\n            else:\n                match var.type:\n                    case \"boolean\":\n                        value_select: Select[bool] = self.query_one(f\"#var-{var.name}\", Select)\n                        value: int | str | None = (\n                            value_select.value if not isinstance(value_select.value, NoSelection) else None\n                        )\n                    case \"integer\":\n                        value_str = self.query_one(f\"#var-{var.name}\", Input).value.strip()\n                        if len(value_str) == 0:\n                            if var.required:\n                                raise SeretoValueError(f\"variable '{var.name}' is required\")\n                            else:\n                                continue\n                        try:\n                            value = int(value_str)\n                        except ValueError:\n                            raise SeretoValueError(f\"variable '{var.name}' must be an integer\") from None\n                    case _:\n                        value = self.query_one(f\"#var-{var.name}\", Input).value.strip()\n                        if len(value) == 0:\n                            if var.required:\n                                raise SeretoValueError(f\"variable '{var.name}' is required\")\n                            else:\n                                # don't set the variable if not required and empty\n                                continue\n                variables[var.name] = value\n\n        return variables\n\n    def _retrieve_target(self) -&gt; Target:\n        \"\"\"Retrieve the target from the select input.\n\n        Returns:\n            The target object corresponding to the selected value.\n\n        Raises:\n            SeretoValueError: If the target is not found.\n        \"\"\"\n        app: SeretoApp = self.app  # type: ignore[assignment]\n\n        target_select: Select[str] = self.select_target.query_one(Select)\n        all_targets = [t for v in app.project.config.versions for t in app.project.config.at_version(v).targets]\n\n        matching_target = [t for t in all_targets if t.uname == target_select.value]\n        if len(matching_target) != 1:\n            raise SeretoValueError(f\"target with uname {target_select.value!r} not found\")\n\n        return matching_target[0]\n\n    def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n        \"\"\"Handle Save button press event.\"\"\"\n        if event.button is not self.btn_save_finding:\n            return\n\n        app: SeretoApp = self.app  # type: ignore[assignment]\n\n        # Retrieve the values from the inputs\n        # - name\n        name = self.input_name.value\n        # - risk\n        risk_select: Select[str] = self.select_risk.query_one(Select)\n        risk = Risk(risk_select.value.lower()) if not isinstance(risk_select.value, NoSelection) else None\n        # - target\n        target = self._retrieve_target()\n\n        # - variables\n        try:\n            variables = self._load_variables()\n        except SeretoValueError as ex:\n            self.notify(title=\"Validation error\", message=str(ex), severity=\"error\")\n            return\n\n        # Create the sub-finding\n        target.findings.add_from_template(\n            templates=self.templates,\n            template_path=self.finding.path,\n            category=self.finding.category.lower(),\n            name=name,\n            risk=risk,\n            variables=variables,\n            overwrite=self.overwrite_switch.display and self.overwrite_switch.value,\n        )\n\n        # Navigate back, focus on the search input field\n        self.dismiss()\n        self.notify(message=name, title=\"Finding successfully added\")\n        app.action_focus_search()\n</code></pre>"},{"location":"reference/tui/finding/#sereto.tui.finding.AddFindingScreen.on_button_pressed","title":"<code>on_button_pressed(event)</code>","text":"<p>Handle Save button press event.</p> Source code in <code>sereto/tui/finding.py</code> <pre><code>def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    \"\"\"Handle Save button press event.\"\"\"\n    if event.button is not self.btn_save_finding:\n        return\n\n    app: SeretoApp = self.app  # type: ignore[assignment]\n\n    # Retrieve the values from the inputs\n    # - name\n    name = self.input_name.value\n    # - risk\n    risk_select: Select[str] = self.select_risk.query_one(Select)\n    risk = Risk(risk_select.value.lower()) if not isinstance(risk_select.value, NoSelection) else None\n    # - target\n    target = self._retrieve_target()\n\n    # - variables\n    try:\n        variables = self._load_variables()\n    except SeretoValueError as ex:\n        self.notify(title=\"Validation error\", message=str(ex), severity=\"error\")\n        return\n\n    # Create the sub-finding\n    target.findings.add_from_template(\n        templates=self.templates,\n        template_path=self.finding.path,\n        category=self.finding.category.lower(),\n        name=name,\n        risk=risk,\n        variables=variables,\n        overwrite=self.overwrite_switch.display and self.overwrite_switch.value,\n    )\n\n    # Navigate back, focus on the search input field\n    self.dismiss()\n    self.notify(message=name, title=\"Finding successfully added\")\n    app.action_focus_search()\n</code></pre>"},{"location":"reference/tui/finding/#sereto.tui.finding.AddFindingScreen.update_overwrite_warning","title":"<code>update_overwrite_warning()</code>","text":"<p>Update the overwrite warning and switch dynamically.</p> Source code in <code>sereto/tui/finding.py</code> <pre><code>def update_overwrite_warning(self) -&gt; None:\n    \"\"\"Update the overwrite warning and switch dynamically.\"\"\"\n    try:\n        target = self._retrieve_target()\n    except Exception:\n        self.overwrite_warning.display = False\n        return\n\n    finding_path = target.findings.get_path(\n        name=self.finding.path.name.removesuffix(\".md.j2\"),\n        category=self.finding.category.lower(),\n    )\n    self.overwrite_warning.display = finding_path.is_file()\n</code></pre>"},{"location":"reference/tui/finding/#sereto.tui.finding.FindingOption","title":"<code>FindingOption</code>","text":"<p>               Bases: <code>Option</code></p> <p>An Option representing a finding, with name and keywords optionally highlighted.</p> Source code in <code>sereto/tui/finding.py</code> <pre><code>class FindingOption(Option):\n    \"\"\"An Option representing a finding, with name and keywords optionally highlighted.\"\"\"\n\n    def __init__(self, finding: FindingMetadata, matchers: dict[str, FuzzyMatcher]) -&gt; None:\n        name_matcher = matchers.get(\"name\")\n        keyword_matcher = matchers.get(\"keyword\")\n\n        name_text = name_matcher.highlight([finding.name]) if name_matcher else Text(finding.name)\n\n        keywords_text = (\n            keyword_matcher.highlight(finding.keywords) if keyword_matcher else Text(\", \".join(finding.keywords))\n        )\n\n        text = Text.assemble(name_text + \"\\n\", Text(style=\"italic dim\") + keywords_text)\n        super().__init__(text, id=str(finding.path))\n        self.finding = finding\n</code></pre>"},{"location":"reference/tui/finding/#sereto.tui.finding.FuzzyMatcher","title":"<code>FuzzyMatcher</code>","text":"Source code in <code>sereto/tui/finding.py</code> <pre><code>class FuzzyMatcher:\n    def __init__(self, query: list[str]) -&gt; None:\n        self.query = [q.lower() for q in query]\n\n    def max_score(self, values: list[str]) -&gt; float:\n        \"\"\"Calculate the average fuzzy match score between the query and the given values.\"\"\"\n        if not self.query:\n            return 0.0\n\n        combined = \"; \".join(values).lower()\n        scores: list[float] = []\n\n        for q in self.query:\n            raw_score = fuzz.partial_ratio(q, combined)\n            # Bonus for matching first letter\n            bonus = 5 if combined and combined[0] == q[0] else 0\n            scores.append(raw_score + bonus)\n        return round(sum(scores) / len(scores), 2)\n\n    def highlight(self, text: list[str]) -&gt; Text:\n        \"\"\"Highlight all fuzzy matches of the query in the given text (used in names and keywords).\"\"\"\n        combined = \"; \".join(text)\n        combined_lower = combined.lower()\n        result_text = Text(combined)\n\n        for q in self.query:\n            if q in combined_lower:\n                start = 0\n                while True:\n                    idx = combined_lower.find(q, start)\n                    if idx == -1:\n                        break\n                    end = idx + len(q)\n                    result_text.stylize(\"bold yellow\", idx, end)\n                    start = end\n            else:\n                for span in Matcher(q).highlight(combined).spans:\n                    span_text = combined[span.start : span.end]\n                    if len(span_text) &lt;= len(q) + 2:\n                        result_text.stylize(\"bold yellow\", span.start, span.end)\n\n        return result_text\n</code></pre>"},{"location":"reference/tui/finding/#sereto.tui.finding.FuzzyMatcher.highlight","title":"<code>highlight(text)</code>","text":"<p>Highlight all fuzzy matches of the query in the given text (used in names and keywords).</p> Source code in <code>sereto/tui/finding.py</code> <pre><code>def highlight(self, text: list[str]) -&gt; Text:\n    \"\"\"Highlight all fuzzy matches of the query in the given text (used in names and keywords).\"\"\"\n    combined = \"; \".join(text)\n    combined_lower = combined.lower()\n    result_text = Text(combined)\n\n    for q in self.query:\n        if q in combined_lower:\n            start = 0\n            while True:\n                idx = combined_lower.find(q, start)\n                if idx == -1:\n                    break\n                end = idx + len(q)\n                result_text.stylize(\"bold yellow\", idx, end)\n                start = end\n        else:\n            for span in Matcher(q).highlight(combined).spans:\n                span_text = combined[span.start : span.end]\n                if len(span_text) &lt;= len(q) + 2:\n                    result_text.stylize(\"bold yellow\", span.start, span.end)\n\n    return result_text\n</code></pre>"},{"location":"reference/tui/finding/#sereto.tui.finding.FuzzyMatcher.max_score","title":"<code>max_score(values)</code>","text":"<p>Calculate the average fuzzy match score between the query and the given values.</p> Source code in <code>sereto/tui/finding.py</code> <pre><code>def max_score(self, values: list[str]) -&gt; float:\n    \"\"\"Calculate the average fuzzy match score between the query and the given values.\"\"\"\n    if not self.query:\n        return 0.0\n\n    combined = \"; \".join(values).lower()\n    scores: list[float] = []\n\n    for q in self.query:\n        raw_score = fuzz.partial_ratio(q, combined)\n        # Bonus for matching first letter\n        bonus = 5 if combined and combined[0] == q[0] else 0\n        scores.append(raw_score + bonus)\n    return round(sum(scores) / len(scores), 2)\n</code></pre>"},{"location":"reference/tui/finding/#sereto.tui.finding.SearchWidget","title":"<code>SearchWidget</code>","text":"<p>               Bases: <code>Widget</code></p> Source code in <code>sereto/tui/finding.py</code> <pre><code>class SearchWidget(Widget):\n    BINDINGS = [\n        (\"ctrl+s\", \"add_finding\", \"Add finding\"),\n        (\"down\", \"cursor_down\", \"Next result\"),\n        (\"up\", \"cursor_up\", \"Previous result\"),\n    ]\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.findings: list[FindingMetadata] = []\n        self.filtered_findings: list[FindingMetadata] = []\n        self._load_findings()\n\n    def _load_findings(self) -&gt; None:\n        app: SeretoApp = self.app  # type: ignore[assignment]\n\n        for category in app.categories:\n            findings_path = app.project.settings.templates_path / \"categories\" / category.lower() / \"findings\"\n            for finding in findings_path.glob(\"*.md.j2\"):\n                file_text = finding.read_text(encoding=\"utf-8\")\n                metadata, content = frontmatter.parse(file_text)\n                # Extract clean text from the template file\n                env = Environment()\n                ast = env.parse(content)\n                extracted_text = extract_text_from_jinja(ast)\n\n                try:\n                    data = FindingTemplateFrontmatterModel.model_validate(metadata)\n                except ValidationError as ex:\n                    raise SeretoValueError(f\"invalid template metadata in '{finding}'\") from ex\n\n                self.findings.append(\n                    FindingMetadata(\n                        path=finding,\n                        category=category,\n                        name=data.name,\n                        variables=data.variables,\n                        keywords=data.keywords,\n                        text=extracted_text,\n                    )\n                )\n\n    def compose(self) -&gt; ComposeResult:\n        app: SeretoApp = self.app  # type: ignore[assignment]\n\n        self.input_field = Input(placeholder=\"Type to search...\", classes=\"input-field\")\n        self.category_filter = SelectionList[str](*[(category, category, True) for category in app.categories])\n\n        class NoFocusOptionList(OptionList):\n            \"\"\"An OptionList subclass whose items are not focusable.\"\"\"\n\n            can_focus = False\n\n        self.result_list = NoFocusOptionList(classes=\"search-result\")\n\n        with Horizontal(classes=\"search-panel\"):\n            with Vertical(), Container(classes=\"search-palette\"):\n                yield self.input_field\n                yield self.result_list\n            with Container(classes=\"category-filter\"):\n                yield self.category_filter\n\n    def on_mount(self) -&gt; None:\n        self.input_field.focus()\n\n    @on(Input.Changed)\n    @on(SelectionList.SelectedChanged)\n    def update_results(self) -&gt; None:\n        query = self.input_field.value.strip()\n        keys = {\n            \"name\": \"n\",\n            \"keyword\": \"k\",\n            \"description\": \"d\",\n            \"likelihood\": \"l\",\n            \"impact\": \"i\",\n            \"recommendation\": \"r\",\n        }\n        parsed = parse_query(query, keys)\n\n        self.result_list.clear_options()\n\n        if len(query) == 0:\n            return\n\n        selected_categories = [c.lower() for c in self.category_filter.selected]\n        filtered_findings = [f for f in self.findings if f.category.lower() in selected_categories]\n\n        # reusable fuzzy matchers for scoring and highlighting\n        self.matcher_dict = {key: FuzzyMatcher(parsed[key]) for key in keys if parsed[key]}\n        if not self.matcher_dict:\n            return\n\n        # compute search similarity\n        for f in filtered_findings:\n            scores: list[float] = []\n\n            for key, _ in self.matcher_dict.items():\n                matcher = self.matcher_dict[key]\n\n                if key == \"name\":\n                    name_score = matcher.max_score([f.name]) or 0\n                    scores.append(name_score)\n                elif key == \"keyword\":\n                    name_score = matcher.max_score(f.keywords) or 0\n                    scores.append(name_score)\n                else:\n                    if key in f.text:\n                        name_score = matcher.max_score([f.text[key]]) or 0\n                        scores.append(name_score)\n\n            f.search_similarity = sum(scores) / len(scores) if scores else 0.0\n\n        # display matching findings\n        result_item = [\n            f\n            for f in sorted(\n                filtered_findings,\n                key=lambda f: f.search_similarity,\n                reverse=True,\n            )\n            if f.search_similarity &gt; 80.0\n        ]\n\n        options: list[FindingOption | None] = []\n        for f in result_item:\n            options.append(FindingOption(f, self.matcher_dict))\n            options.append(None)  # insert a separator line\n\n        self.result_list.clear_options()\n        self.result_list.add_options(options)\n\n        # highlight the first search result\n        if options:\n            self.result_list.highlighted = 0\n            self.result_list.scroll_to_highlight()\n\n    def on_key(self, event: events.Key) -&gt; None:\n        \"\"\"Intercepts key presses and handles the Enter key.\"\"\"\n        if event.key == \"enter\":\n            if self.category_filter.has_focus:\n                return\n\n            if self.input_field.has_focus:\n                self.action_select_item()\n            return\n\n    # up/down scrolling without focusing the OptionList\n    def action_cursor_down(self) -&gt; None:\n        if not self.result_list.options:\n            return\n\n        if self.result_list.highlighted is None:\n            self.result_list.highlighted = 0\n        else:\n            if self.result_list.highlighted &lt; len(self.result_list.options) - 1:\n                self.result_list.highlighted += 1\n        self.result_list.scroll_to_highlight(top=True)\n\n    def action_cursor_up(self) -&gt; None:\n        if not self.result_list.options:\n            return\n\n        if self.result_list.highlighted is None:\n            self.result_list.highlighted = 0\n        else:\n            if self.result_list.highlighted &gt; 0:\n                self.result_list.highlighted -= 1\n        self.result_list.scroll_to_highlight(top=True)\n\n    def assemble_template(self, file: str) -&gt; str | Text:\n        \"\"\"Highlight matching words in specific Jinja blocks and returns reconstructed template.\"\"\"\n        code = Text(file)\n        found_match = False\n\n        for key in (\"likelihood\", \"description\", \"impact\", \"recommendation\"):\n            matcher = self.matcher_dict.get(key)\n            if not matcher:\n                continue\n            # extract the full content of the block\n            block_text, start, end = extract_block_from_jinja(file, key)\n            highlighted_block = matcher.highlight([block_text])\n            if highlighted_block.spans:\n                found_match = True\n                # reassemble template\n                code = code[:start] + highlighted_block + code[end:]\n\n        final_code = code if found_match else file\n        return final_code\n\n    @on(OptionList.OptionSelected)\n    def select_item(self, event: OptionList.OptionSelected) -&gt; None:\n        option = event.option\n        if not isinstance(option, FindingOption):\n            return\n        file = option.finding.path.read_text(encoding=\"utf-8\")\n        final_code = self.assemble_template(file)\n\n        self.app.push_screen(\n            FindingPreviewScreen(\n                title=\"Finding preview\",\n                code=final_code,\n            )\n        )\n\n    def action_select_item(self) -&gt; None:\n        if self.result_list.highlighted is None:\n            return\n\n        option = self.result_list.get_option_at_index(self.result_list.highlighted)\n        if not isinstance(option, FindingOption):\n            return\n        file = option.finding.path.read_text(encoding=\"utf-8\")\n        final_code = self.assemble_template(file)\n        self.app.push_screen(\n            FindingPreviewScreen(\n                title=\"Finding preview\",\n                code=final_code,\n            )\n        )\n\n    def action_add_finding(self) -&gt; None:\n        if not self.input_field.has_focus:\n            return\n\n        if self.result_list.highlighted is None:\n            return\n        option = self.result_list.get_option_at_index(self.result_list.highlighted)\n        if isinstance(option, FindingOption):\n            self.app.push_screen(\n                AddFindingScreen(\n                    templates=self.app.project.settings.templates_path,  # type: ignore[attr-defined]\n                    finding=option.finding,\n                    title=\"Add finding\",\n                )\n            )\n</code></pre>"},{"location":"reference/tui/finding/#sereto.tui.finding.SearchWidget.assemble_template","title":"<code>assemble_template(file)</code>","text":"<p>Highlight matching words in specific Jinja blocks and returns reconstructed template.</p> Source code in <code>sereto/tui/finding.py</code> <pre><code>def assemble_template(self, file: str) -&gt; str | Text:\n    \"\"\"Highlight matching words in specific Jinja blocks and returns reconstructed template.\"\"\"\n    code = Text(file)\n    found_match = False\n\n    for key in (\"likelihood\", \"description\", \"impact\", \"recommendation\"):\n        matcher = self.matcher_dict.get(key)\n        if not matcher:\n            continue\n        # extract the full content of the block\n        block_text, start, end = extract_block_from_jinja(file, key)\n        highlighted_block = matcher.highlight([block_text])\n        if highlighted_block.spans:\n            found_match = True\n            # reassemble template\n            code = code[:start] + highlighted_block + code[end:]\n\n    final_code = code if found_match else file\n    return final_code\n</code></pre>"},{"location":"reference/tui/finding/#sereto.tui.finding.SearchWidget.on_key","title":"<code>on_key(event)</code>","text":"<p>Intercepts key presses and handles the Enter key.</p> Source code in <code>sereto/tui/finding.py</code> <pre><code>def on_key(self, event: events.Key) -&gt; None:\n    \"\"\"Intercepts key presses and handles the Enter key.\"\"\"\n    if event.key == \"enter\":\n        if self.category_filter.has_focus:\n            return\n\n        if self.input_field.has_focus:\n            self.action_select_item()\n        return\n</code></pre>"},{"location":"reference/tui/finding/#sereto.tui.finding.SeretoApp","title":"<code>SeretoApp</code>","text":"<p>               Bases: <code>App[None]</code></p> <p>A SeReTo Textual CLI interface.</p> Source code in <code>sereto/tui/finding.py</code> <pre><code>class SeretoApp(App[None]):\n    \"\"\"A SeReTo Textual CLI interface.\"\"\"\n\n    CSS_PATH = \"finding.tcss\"\n    TITLE = \"SeReTo\"\n    SUB_TITLE = \"Security Reporting Tool\"\n    BINDINGS = [(\"/\", \"focus_search\", \"Focus on search\")]\n\n    def __init__(\n        self,\n        project: Project,\n        categories: list[str],\n    ) -&gt; None:\n        super().__init__()\n        self.project = project\n        self.categories = categories\n\n    def compose(self) -&gt; ComposeResult:\n        \"\"\"Add widgets to the app.\"\"\"\n        # adding findings only works if there is at least one target\n        if len(self.project.config.last_config.targets) == 0:\n            raise SeretoValueError(\"no targets found in the configuration\")\n\n        search = SearchWidget()\n        search.id = \"search\"\n        search.classes = \"dropdown\"\n\n        yield Header()\n        yield search\n        yield Footer()\n\n    def action_focus_search(self) -&gt; None:\n        \"\"\"Focus on the search input field.\"\"\"\n        self.query_one(\"#search\", SearchWidget).input_field.focus()\n</code></pre>"},{"location":"reference/tui/finding/#sereto.tui.finding.SeretoApp.action_focus_search","title":"<code>action_focus_search()</code>","text":"<p>Focus on the search input field.</p> Source code in <code>sereto/tui/finding.py</code> <pre><code>def action_focus_search(self) -&gt; None:\n    \"\"\"Focus on the search input field.\"\"\"\n    self.query_one(\"#search\", SearchWidget).input_field.focus()\n</code></pre>"},{"location":"reference/tui/finding/#sereto.tui.finding.SeretoApp.compose","title":"<code>compose()</code>","text":"<p>Add widgets to the app.</p> Source code in <code>sereto/tui/finding.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Add widgets to the app.\"\"\"\n    # adding findings only works if there is at least one target\n    if len(self.project.config.last_config.targets) == 0:\n        raise SeretoValueError(\"no targets found in the configuration\")\n\n    search = SearchWidget()\n    search.id = \"search\"\n    search.classes = \"dropdown\"\n\n    yield Header()\n    yield search\n    yield Footer()\n</code></pre>"}]}